./.gitignore
1: # Binaries for programs and plugins
2: *.exe
3: *.exe~
4: *.dll
5: *.so
6: *.dylib
7: bin/*
8: 
9: # Test binary, build with `go test -c`
10: *.test
11: 
12: # Output of the go coverage tool, specifically when used with LiteIDE
13: *.out
14: 
15: # go mod vendor
16: vendor
17: 
18: # GoLand
19: .idea/*
20: 
21: # macOS file
22: .DS_Store
23: 
24: # test suite
25: test/config/cache*
26: 
27: # docs site generator
28: node_modules
29: package-lock.json
30: pnpm-lock.yaml
31: 
32: # docs site cache
33: docs/.vitepress/cache
34: 
35: # docs site build files
36: docs/.vitepress/dist


./.golangci.yaml
1: linters:
2:   disable-all: true
3:   enable:
4:     - gci
5:     - gofumpt
6:     - gosimple
7:     - govet
8:     - ineffassign
9:     - misspell
10:     - staticcheck
11:     - unconvert
12:     - unused
13:     - usestdlibvars
14:     - exhaustive
15: 
16: linters-settings:
17:   gci:
18:     custom-order: true
19:     sections:
20:       - standard
21:       - prefix(github.com/Dreamacro/clash)
22:       - default
23:   staticcheck:
24:     go: '1.21'
25:   exhaustive:
26:     default-signifies-exhaustive: true


./config.json
1: {
2:     "ignore_paths": ["node_modules", ".git"],
3:     "ignore_extensions": [".log", ".tmp", ".png", ".jpg", ".img", ".mbr"]
4:   }
5:   

./Dockerfile
1: FROM --platform=${BUILDPLATFORM} golang:alpine as builder
2: 
3: RUN apk add --no-cache make git ca-certificates && \
4:     wget -O /Country.mmdb https://github.com/Dreamacro/maxmind-geoip/releases/latest/download/Country.mmdb
5: WORKDIR /workdir
6: COPY --from=tonistiigi/xx:golang / /
7: ARG TARGETOS TARGETARCH TARGETVARIANT
8: 
9: RUN --mount=target=. \
10:     --mount=type=cache,target=/root/.cache/go-build \
11:     --mount=type=cache,target=/go/pkg/mod \
12:     make BINDIR= ${TARGETOS}-${TARGETARCH}${TARGETVARIANT} && \
13:     mv /clash* /clash
14: 
15: FROM alpine:latest
16: LABEL org.opencontainers.image.source="https://github.com/Dreamacro/clash"
17: 
18: COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
19: COPY --from=builder /Country.mmdb /root/.config/clash/
20: COPY --from=builder /clash /
21: ENTRYPOINT ["/clash"]


./extract.py
1: import json
2: import os
3: 
4: def load_config(config_path):
5:     with open(config_path, 'r') as config_file:
6:         return json.load(config_file)
7: 
8: def is_binary_file(file_path):
9:     try:
10:         with open(file_path, 'r', encoding='utf-8') as file:
11:             # 尝试读取文件内容，检查是否包含非文本字符
12:             if '\0' in file.read(1024):
13:                 return True
14:     except Exception as e:
15:         print(f"Cannot read file {file_path} due to {e}, assuming binary.")
16:         return True
17:     return False
18: 
19: def should_ignore(path, filename, config):
20:     for ignore_path in config['ignore_paths']:
21:         if ignore_path in path.split(os.sep):
22:             return True
23:     for ignore_ext in config['ignore_extensions']:
24:         if filename.endswith(ignore_ext):
25:             return True
26:     return False
27: 
28: def format_file_content(file_path, is_binary):
29:     # 如果文件是二进制文件，只记录文件名
30:     if is_binary:
31:         return f"{file_path}\n- BINARY FILE -\n\n"
32:     else:
33:         # 文本文件，记录文件路径及内容，并忽略无法解码的字节
34:         try:
35:             with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
36:                 lines = file.readlines()
37:             content_with_line_numbers = ''.join(f"{idx + 1}: {line}" for idx, line in enumerate(lines))
38:             formatted_content = f"{file_path}\n{content_with_line_numbers}\n\n"
39:         except Exception as e:
40:             # 如果读取文件时发生了未知错误，记录错误并跳过文件
41:             formatted_content = f"{file_path}\n- ERROR READING FILE: {e} -\n\n"
42:         return formatted_content
43: 
44: def traverse_and_extract(project_path, output_path, config):
45:     with open(output_path, 'w', encoding='utf-8') as output_file:  # 指定UTF-8编码
46:         for root, dirs, files in os.walk(project_path):
47:             # 过滤掉忽略配置中的目录
48:             dirs[:] = [d for d in dirs if not should_ignore(root, d, config)]
49:             for filename in files:
50:                 # 忽略配置中指定要忽略的文件
51:                 if should_ignore(root, filename, config):
52:                     continue
53:                 # 不被忽略的文件，将其内容写入输出文件
54:                 file_path = os.path.join(root, filename)
55:                 is_binary = is_binary_file(file_path)
56:                 output_file.write(format_file_content(file_path, is_binary))
57: 
58: # 示例配置，默认所有文件都被遍历，除了配置中忽略的文件类型和路径
59: config = {
60:     "ignore_paths": [],
61:     "ignore_extensions": []
62: }
63: 
64: # 使用示例
65: config_file_path = 'config.json'  # 更改为你的配置文件路径
66: output_file_path = 'output.txt'   # 更改为你的输出文件路径
67: project_path = './'          # 更改为你的项目目录路径
68: 
69: # 加载配置
70: config = load_config(config_file_path)
71: 
72: # 提取文件内容并写入到输出文件中
73: traverse_and_extract(project_path, output_file_path, config)

./go.mod
1: module github.com/Dreamacro/clash
2: 
3: go 1.21
4: 
5: require (
6: 	github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158
7: 	github.com/dlclark/regexp2 v1.10.0
8: 	github.com/go-chi/chi/v5 v5.0.10
9: 	github.com/go-chi/cors v1.2.1
10: 	github.com/go-chi/render v1.0.3
11: 	github.com/gofrs/uuid/v5 v5.0.0
12: 	github.com/gorilla/websocket v1.5.0
13: 	github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d
14: 	github.com/mdlayher/netlink v1.7.2
15: 	github.com/miekg/dns v1.1.55
16: 	github.com/oschwald/geoip2-golang v1.9.0
17: 	github.com/samber/lo v1.38.1
18: 	github.com/sirupsen/logrus v1.9.3
19: 	github.com/stretchr/testify v1.8.4
20: 	github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01
21: 	go.etcd.io/bbolt v1.3.7
22: 	go.uber.org/atomic v1.11.0
23: 	go.uber.org/automaxprocs v1.5.3
24: 	golang.org/x/crypto v0.12.0
25: 	golang.org/x/net v0.14.0
26: 	golang.org/x/sync v0.3.0
27: 	golang.org/x/sys v0.11.0
28: 	gopkg.in/yaml.v3 v3.0.1
29: )
30: 
31: require (
32: 	github.com/ajg/form v1.5.1 // indirect
33: 	github.com/davecgh/go-spew v1.1.1 // indirect
34: 	github.com/google/go-cmp v0.5.9 // indirect
35: 	github.com/josharian/native v1.1.0 // indirect
36: 	github.com/kr/text v0.2.0 // indirect
37: 	github.com/mdlayher/socket v0.4.1 // indirect
38: 	github.com/oschwald/maxminddb-golang v1.11.0 // indirect
39: 	github.com/pierrec/lz4/v4 v4.1.14 // indirect
40: 	github.com/pmezard/go-difflib v1.0.0 // indirect
41: 	github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923 // indirect
42: 	github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae // indirect
43: 	golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 // indirect
44: 	golang.org/x/mod v0.8.0 // indirect
45: 	golang.org/x/text v0.12.0 // indirect
46: 	golang.org/x/tools v0.6.0 // indirect
47: )


./go.sum
1: github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158 h1:JFnwKplz9hj8ubqYjm8HkgZS1Rvz9yW+u/XCNNTxr0k=
2: github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158/go.mod h1:QvmEZ/h6KXszPOr2wUFl7Zn3hfFNYdfbXwPVDTyZs6k=
3: github.com/ajg/form v1.5.1 h1:t9c7v8JUKu/XxOGBU0yjNpaMloxGEJhUkqFRq0ibGeU=
4: github.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=
5: github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
6: github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
7: github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
8: github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
9: github.com/dlclark/regexp2 v1.10.0 h1:+/GIL799phkJqYW+3YbOd8LCcbHzT0Pbo8zl70MHsq0=
10: github.com/dlclark/regexp2 v1.10.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=
11: github.com/go-chi/chi/v5 v5.0.10 h1:rLz5avzKpjqxrYwXNfmjkrYYXOyLJd37pz53UFHC6vk=
12: github.com/go-chi/chi/v5 v5.0.10/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=
13: github.com/go-chi/cors v1.2.1 h1:xEC8UT3Rlp2QuWNEr4Fs/c2EAGVKBwy/1vHx3bppil4=
14: github.com/go-chi/cors v1.2.1/go.mod h1:sSbTewc+6wYHBBCW7ytsFSn836hqM7JxpglAy2Vzc58=
15: github.com/go-chi/render v1.0.3 h1:AsXqd2a1/INaIfUSKq3G5uA8weYx20FOsM7uSoCyyt4=
16: github.com/go-chi/render v1.0.3/go.mod h1:/gr3hVkmYR0YlEy3LxCuVRFzEu9Ruok+gFqbIofjao0=
17: github.com/gofrs/uuid/v5 v5.0.0 h1:p544++a97kEL+svbcFbCQVM9KFu0Yo25UoISXGNNH9M=
18: github.com/gofrs/uuid/v5 v5.0.0/go.mod h1:CDOjlDMVAtN56jqyRUZh58JT31Tiw7/oQyEXZV+9bD8=
19: github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=
20: github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
21: github.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=
22: github.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
23: github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d h1:Ka64cclWedOkGzm9M2/XYuwJUdmWRUozmsxW0PyKA3A=
24: github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d/go.mod h1:7474bZ1YNCvarT6WFKie4kEET6J0KYRDC4XJqqXzQW4=
25: github.com/josharian/native v1.0.1-0.20221213033349-c1e37c09b531/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=
26: github.com/josharian/native v1.1.0 h1:uuaP0hAbW7Y4l0ZRQ6C9zfb7Mg1mbFKry/xzDAfmtLA=
27: github.com/josharian/native v1.1.0/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=
28: github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
29: github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
30: github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
31: github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
32: github.com/mdlayher/netlink v1.7.2 h1:/UtM3ofJap7Vl4QWCPDGXY8d3GIY2UGSDbK+QWmY8/g=
33: github.com/mdlayher/netlink v1.7.2/go.mod h1:xraEF7uJbxLhc5fpHL4cPe221LI2bdttWlU+ZGLfQSw=
34: github.com/mdlayher/socket v0.4.1 h1:eM9y2/jlbs1M615oshPQOHZzj6R6wMT7bX5NPiQvn2U=
35: github.com/mdlayher/socket v0.4.1/go.mod h1:cAqeGjoufqdxWkD7DkpyS+wcefOtmu5OQ8KuoJGIReA=
36: github.com/miekg/dns v1.1.55 h1:GoQ4hpsj0nFLYe+bWiCToyrBEJXkQfOOIvFGFy0lEgo=
37: github.com/miekg/dns v1.1.55/go.mod h1:uInx36IzPl7FYnDcMeVWxj9byh7DutNykX4G9Sj60FY=
38: github.com/oschwald/geoip2-golang v1.9.0 h1:uvD3O6fXAXs+usU+UGExshpdP13GAqp4GBrzN7IgKZc=
39: github.com/oschwald/geoip2-golang v1.9.0/go.mod h1:BHK6TvDyATVQhKNbQBdrj9eAvuwOMi2zSFXizL3K81Y=
40: github.com/oschwald/maxminddb-golang v1.11.0 h1:aSXMqYR/EPNjGE8epgqwDay+P30hCBZIveY0WZbAWh0=
41: github.com/oschwald/maxminddb-golang v1.11.0/go.mod h1:YmVI+H0zh3ySFR3w+oz8PCfglAFj3PuCmui13+P9zDg=
42: github.com/pierrec/lz4/v4 v4.1.14 h1:+fL8AQEZtz/ijeNnpduH0bROTu0O3NZAlPjQxGn8LwE=
43: github.com/pierrec/lz4/v4 v4.1.14/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=
44: github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
45: github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
46: github.com/prashantv/gostub v1.1.0 h1:BTyx3RfQjRHnUWaGF9oQos79AlQ5k8WNktv7VGvVH4g=
47: github.com/prashantv/gostub v1.1.0/go.mod h1:A5zLQHz7ieHGG7is6LLXLz7I8+3LZzsrV0P1IAHhP5U=
48: github.com/samber/lo v1.38.1 h1:j2XEAqXKb09Am4ebOg31SpvzUTTs6EN3VfgeLUhPdXM=
49: github.com/samber/lo v1.38.1/go.mod h1:+m/ZKRl6ClXCE2Lgf3MsQlWfh4bn1bz6CXEOxnEXnEA=
50: github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
51: github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
52: github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
53: github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
54: github.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=
55: github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
56: github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923 h1:tHNk7XK9GkmKUR6Gh8gVBKXc2MVSZ4G/NnWLtzw4gNA=
57: github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923/go.mod h1:eLL9Nub3yfAho7qB0MzZizFhTU2QkLeoVsWdHtDW264=
58: github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01 h1:F9xjJm4IH8VjcqG4ujciOF+GIM4mjPkHhWLLzOghPtM=
59: github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01/go.mod h1:cAAsePK2e15YDAMJNyOpGYEWNe4sIghTY7gpz4cX/Ik=
60: github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae h1:4hwBBUfQCFe3Cym0ZtKyq7L16eZUtYKs+BaHDN6mAns=
61: github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae/go.mod h1:DD4vA1DwXk04H54A1oHXtwZmA0grkVMdPxx/VGLCah0=
62: go.etcd.io/bbolt v1.3.7 h1:j+zJOnnEjF/kyHlDDgGnVL/AIqIJPq8UoB2GSNfkUfQ=
63: go.etcd.io/bbolt v1.3.7/go.mod h1:N9Mkw9X8x5fupy0IKsmuqVtoGDyxsaDlbk4Rd05IAQw=
64: go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
65: go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
66: go.uber.org/automaxprocs v1.5.3 h1:kWazyxZUrS3Gs4qUpbwo5kEIMGe/DAvi5Z4tl2NW4j8=
67: go.uber.org/automaxprocs v1.5.3/go.mod h1:eRbA25aqJrxAbsLO0xy5jVwPt7FQnRgjW+efnwa1WM0=
68: golang.org/x/crypto v0.12.0 h1:tFM/ta59kqch6LlvYnPa0yx5a83cL2nHflFhYKvv9Yk=
69: golang.org/x/crypto v0.12.0/go.mod h1:NF0Gs7EO5K4qLn+Ylc+fih8BSTeIjAP05siRnAh98yw=
70: golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 h1:3MTrJm4PyNL9NBqvYDSj3DHl46qQakyfqfWo4jgfaEM=
71: golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17/go.mod h1:lgLbSvA5ygNOMpwM/9anMpWVlVJ7Z+cHWq/eFuinpGE=
72: golang.org/x/mod v0.8.0 h1:LUYupSeNrTNCGzR/hVBk2NHZO4hXcVaW1k4Qx7rjPx8=
73: golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
74: golang.org/x/net v0.14.0 h1:BONx9s002vGdD9umnlX1Po8vOZmrgH34qlHcD1MfK14=
75: golang.org/x/net v0.14.0/go.mod h1:PpSgVXXLK0OxS0F31C1/tv6XNguvCrnXIDrFMspZIUI=
76: golang.org/x/sync v0.3.0 h1:ftCYgMx6zT/asHUrPw8BLLscYtGznsLAnjq5RH9P66E=
77: golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
78: golang.org/x/sys v0.0.0-20200217220822-9197077df867/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
79: golang.org/x/sys v0.0.0-20220622161953-175b2fd9d664/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
80: golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
81: golang.org/x/sys v0.0.0-20220804214406-8e32c043e418/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
82: golang.org/x/sys v0.11.0 h1:eG7RXZHdqOJ1i+0lgLgCpSXAp6M3LYlAo6osgSi0xOM=
83: golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
84: golang.org/x/text v0.12.0 h1:k+n5B8goJNdU7hSvEtMUz3d1Q6D/XW4COJSJR6fN0mc=
85: golang.org/x/text v0.12.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
86: golang.org/x/tools v0.6.0 h1:BOw41kyTf3PuCW1pVQf8+Cyg8pMlkYB1oo9iJ6D/lKM=
87: golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
88: gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
89: gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
90: gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
91: gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
92: gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
93: gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


./LICENSE
1:                     GNU GENERAL PUBLIC LICENSE
2:                        Version 3, 29 June 2007
3: 
4:  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
5:  Everyone is permitted to copy and distribute verbatim copies
6:  of this license document, but changing it is not allowed.
7: 
8:                             Preamble
9: 
10:   The GNU General Public License is a free, copyleft license for
11: software and other kinds of works.
12: 
13:   The licenses for most software and other practical works are designed
14: to take away your freedom to share and change the works.  By contrast,
15: the GNU General Public License is intended to guarantee your freedom to
16: share and change all versions of a program--to make sure it remains free
17: software for all its users.  We, the Free Software Foundation, use the
18: GNU General Public License for most of our software; it applies also to
19: any other work released this way by its authors.  You can apply it to
20: your programs, too.
21: 
22:   When we speak of free software, we are referring to freedom, not
23: price.  Our General Public Licenses are designed to make sure that you
24: have the freedom to distribute copies of free software (and charge for
25: them if you wish), that you receive source code or can get it if you
26: want it, that you can change the software or use pieces of it in new
27: free programs, and that you know you can do these things.
28: 
29:   To protect your rights, we need to prevent others from denying you
30: these rights or asking you to surrender the rights.  Therefore, you have
31: certain responsibilities if you distribute copies of the software, or if
32: you modify it: responsibilities to respect the freedom of others.
33: 
34:   For example, if you distribute copies of such a program, whether
35: gratis or for a fee, you must pass on to the recipients the same
36: freedoms that you received.  You must make sure that they, too, receive
37: or can get the source code.  And you must show them these terms so they
38: know their rights.
39: 
40:   Developers that use the GNU GPL protect your rights with two steps:
41: (1) assert copyright on the software, and (2) offer you this License
42: giving you legal permission to copy, distribute and/or modify it.
43: 
44:   For the developers' and authors' protection, the GPL clearly explains
45: that there is no warranty for this free software.  For both users' and
46: authors' sake, the GPL requires that modified versions be marked as
47: changed, so that their problems will not be attributed erroneously to
48: authors of previous versions.
49: 
50:   Some devices are designed to deny users access to install or run
51: modified versions of the software inside them, although the manufacturer
52: can do so.  This is fundamentally incompatible with the aim of
53: protecting users' freedom to change the software.  The systematic
54: pattern of such abuse occurs in the area of products for individuals to
55: use, which is precisely where it is most unacceptable.  Therefore, we
56: have designed this version of the GPL to prohibit the practice for those
57: products.  If such problems arise substantially in other domains, we
58: stand ready to extend this provision to those domains in future versions
59: of the GPL, as needed to protect the freedom of users.
60: 
61:   Finally, every program is threatened constantly by software patents.
62: States should not allow patents to restrict development and use of
63: software on general-purpose computers, but in those that do, we wish to
64: avoid the special danger that patents applied to a free program could
65: make it effectively proprietary.  To prevent this, the GPL assures that
66: patents cannot be used to render the program non-free.
67: 
68:   The precise terms and conditions for copying, distribution and
69: modification follow.
70: 
71:                        TERMS AND CONDITIONS
72: 
73:   0. Definitions.
74: 
75:   "This License" refers to version 3 of the GNU General Public License.
76: 
77:   "Copyright" also means copyright-like laws that apply to other kinds of
78: works, such as semiconductor masks.
79: 
80:   "The Program" refers to any copyrightable work licensed under this
81: License.  Each licensee is addressed as "you".  "Licensees" and
82: "recipients" may be individuals or organizations.
83: 
84:   To "modify" a work means to copy from or adapt all or part of the work
85: in a fashion requiring copyright permission, other than the making of an
86: exact copy.  The resulting work is called a "modified version" of the
87: earlier work or a work "based on" the earlier work.
88: 
89:   A "covered work" means either the unmodified Program or a work based
90: on the Program.
91: 
92:   To "propagate" a work means to do anything with it that, without
93: permission, would make you directly or secondarily liable for
94: infringement under applicable copyright law, except executing it on a
95: computer or modifying a private copy.  Propagation includes copying,
96: distribution (with or without modification), making available to the
97: public, and in some countries other activities as well.
98: 
99:   To "convey" a work means any kind of propagation that enables other
100: parties to make or receive copies.  Mere interaction with a user through
101: a computer network, with no transfer of a copy, is not conveying.
102: 
103:   An interactive user interface displays "Appropriate Legal Notices"
104: to the extent that it includes a convenient and prominently visible
105: feature that (1) displays an appropriate copyright notice, and (2)
106: tells the user that there is no warranty for the work (except to the
107: extent that warranties are provided), that licensees may convey the
108: work under this License, and how to view a copy of this License.  If
109: the interface presents a list of user commands or options, such as a
110: menu, a prominent item in the list meets this criterion.
111: 
112:   1. Source Code.
113: 
114:   The "source code" for a work means the preferred form of the work
115: for making modifications to it.  "Object code" means any non-source
116: form of a work.
117: 
118:   A "Standard Interface" means an interface that either is an official
119: standard defined by a recognized standards body, or, in the case of
120: interfaces specified for a particular programming language, one that
121: is widely used among developers working in that language.
122: 
123:   The "System Libraries" of an executable work include anything, other
124: than the work as a whole, that (a) is included in the normal form of
125: packaging a Major Component, but which is not part of that Major
126: Component, and (b) serves only to enable use of the work with that
127: Major Component, or to implement a Standard Interface for which an
128: implementation is available to the public in source code form.  A
129: "Major Component", in this context, means a major essential component
130: (kernel, window system, and so on) of the specific operating system
131: (if any) on which the executable work runs, or a compiler used to
132: produce the work, or an object code interpreter used to run it.
133: 
134:   The "Corresponding Source" for a work in object code form means all
135: the source code needed to generate, install, and (for an executable
136: work) run the object code and to modify the work, including scripts to
137: control those activities.  However, it does not include the work's
138: System Libraries, or general-purpose tools or generally available free
139: programs which are used unmodified in performing those activities but
140: which are not part of the work.  For example, Corresponding Source
141: includes interface definition files associated with source files for
142: the work, and the source code for shared libraries and dynamically
143: linked subprograms that the work is specifically designed to require,
144: such as by intimate data communication or control flow between those
145: subprograms and other parts of the work.
146: 
147:   The Corresponding Source need not include anything that users
148: can regenerate automatically from other parts of the Corresponding
149: Source.
150: 
151:   The Corresponding Source for a work in source code form is that
152: same work.
153: 
154:   2. Basic Permissions.
155: 
156:   All rights granted under this License are granted for the term of
157: copyright on the Program, and are irrevocable provided the stated
158: conditions are met.  This License explicitly affirms your unlimited
159: permission to run the unmodified Program.  The output from running a
160: covered work is covered by this License only if the output, given its
161: content, constitutes a covered work.  This License acknowledges your
162: rights of fair use or other equivalent, as provided by copyright law.
163: 
164:   You may make, run and propagate covered works that you do not
165: convey, without conditions so long as your license otherwise remains
166: in force.  You may convey covered works to others for the sole purpose
167: of having them make modifications exclusively for you, or provide you
168: with facilities for running those works, provided that you comply with
169: the terms of this License in conveying all material for which you do
170: not control copyright.  Those thus making or running the covered works
171: for you must do so exclusively on your behalf, under your direction
172: and control, on terms that prohibit them from making any copies of
173: your copyrighted material outside their relationship with you.
174: 
175:   Conveying under any other circumstances is permitted solely under
176: the conditions stated below.  Sublicensing is not allowed; section 10
177: makes it unnecessary.
178: 
179:   3. Protecting Users' Legal Rights From Anti-Circumvention Law.
180: 
181:   No covered work shall be deemed part of an effective technological
182: measure under any applicable law fulfilling obligations under article
183: 11 of the WIPO copyright treaty adopted on 20 December 1996, or
184: similar laws prohibiting or restricting circumvention of such
185: measures.
186: 
187:   When you convey a covered work, you waive any legal power to forbid
188: circumvention of technological measures to the extent such circumvention
189: is effected by exercising rights under this License with respect to
190: the covered work, and you disclaim any intention to limit operation or
191: modification of the work as a means of enforcing, against the work's
192: users, your or third parties' legal rights to forbid circumvention of
193: technological measures.
194: 
195:   4. Conveying Verbatim Copies.
196: 
197:   You may convey verbatim copies of the Program's source code as you
198: receive it, in any medium, provided that you conspicuously and
199: appropriately publish on each copy an appropriate copyright notice;
200: keep intact all notices stating that this License and any
201: non-permissive terms added in accord with section 7 apply to the code;
202: keep intact all notices of the absence of any warranty; and give all
203: recipients a copy of this License along with the Program.
204: 
205:   You may charge any price or no price for each copy that you convey,
206: and you may offer support or warranty protection for a fee.
207: 
208:   5. Conveying Modified Source Versions.
209: 
210:   You may convey a work based on the Program, or the modifications to
211: produce it from the Program, in the form of source code under the
212: terms of section 4, provided that you also meet all of these conditions:
213: 
214:     a) The work must carry prominent notices stating that you modified
215:     it, and giving a relevant date.
216: 
217:     b) The work must carry prominent notices stating that it is
218:     released under this License and any conditions added under section
219:     7.  This requirement modifies the requirement in section 4 to
220:     "keep intact all notices".
221: 
222:     c) You must license the entire work, as a whole, under this
223:     License to anyone who comes into possession of a copy.  This
224:     License will therefore apply, along with any applicable section 7
225:     additional terms, to the whole of the work, and all its parts,
226:     regardless of how they are packaged.  This License gives no
227:     permission to license the work in any other way, but it does not
228:     invalidate such permission if you have separately received it.
229: 
230:     d) If the work has interactive user interfaces, each must display
231:     Appropriate Legal Notices; however, if the Program has interactive
232:     interfaces that do not display Appropriate Legal Notices, your
233:     work need not make them do so.
234: 
235:   A compilation of a covered work with other separate and independent
236: works, which are not by their nature extensions of the covered work,
237: and which are not combined with it such as to form a larger program,
238: in or on a volume of a storage or distribution medium, is called an
239: "aggregate" if the compilation and its resulting copyright are not
240: used to limit the access or legal rights of the compilation's users
241: beyond what the individual works permit.  Inclusion of a covered work
242: in an aggregate does not cause this License to apply to the other
243: parts of the aggregate.
244: 
245:   6. Conveying Non-Source Forms.
246: 
247:   You may convey a covered work in object code form under the terms
248: of sections 4 and 5, provided that you also convey the
249: machine-readable Corresponding Source under the terms of this License,
250: in one of these ways:
251: 
252:     a) Convey the object code in, or embodied in, a physical product
253:     (including a physical distribution medium), accompanied by the
254:     Corresponding Source fixed on a durable physical medium
255:     customarily used for software interchange.
256: 
257:     b) Convey the object code in, or embodied in, a physical product
258:     (including a physical distribution medium), accompanied by a
259:     written offer, valid for at least three years and valid for as
260:     long as you offer spare parts or customer support for that product
261:     model, to give anyone who possesses the object code either (1) a
262:     copy of the Corresponding Source for all the software in the
263:     product that is covered by this License, on a durable physical
264:     medium customarily used for software interchange, for a price no
265:     more than your reasonable cost of physically performing this
266:     conveying of source, or (2) access to copy the
267:     Corresponding Source from a network server at no charge.
268: 
269:     c) Convey individual copies of the object code with a copy of the
270:     written offer to provide the Corresponding Source.  This
271:     alternative is allowed only occasionally and noncommercially, and
272:     only if you received the object code with such an offer, in accord
273:     with subsection 6b.
274: 
275:     d) Convey the object code by offering access from a designated
276:     place (gratis or for a charge), and offer equivalent access to the
277:     Corresponding Source in the same way through the same place at no
278:     further charge.  You need not require recipients to copy the
279:     Corresponding Source along with the object code.  If the place to
280:     copy the object code is a network server, the Corresponding Source
281:     may be on a different server (operated by you or a third party)
282:     that supports equivalent copying facilities, provided you maintain
283:     clear directions next to the object code saying where to find the
284:     Corresponding Source.  Regardless of what server hosts the
285:     Corresponding Source, you remain obligated to ensure that it is
286:     available for as long as needed to satisfy these requirements.
287: 
288:     e) Convey the object code using peer-to-peer transmission, provided
289:     you inform other peers where the object code and Corresponding
290:     Source of the work are being offered to the general public at no
291:     charge under subsection 6d.
292: 
293:   A separable portion of the object code, whose source code is excluded
294: from the Corresponding Source as a System Library, need not be
295: included in conveying the object code work.
296: 
297:   A "User Product" is either (1) a "consumer product", which means any
298: tangible personal property which is normally used for personal, family,
299: or household purposes, or (2) anything designed or sold for incorporation
300: into a dwelling.  In determining whether a product is a consumer product,
301: doubtful cases shall be resolved in favor of coverage.  For a particular
302: product received by a particular user, "normally used" refers to a
303: typical or common use of that class of product, regardless of the status
304: of the particular user or of the way in which the particular user
305: actually uses, or expects or is expected to use, the product.  A product
306: is a consumer product regardless of whether the product has substantial
307: commercial, industrial or non-consumer uses, unless such uses represent
308: the only significant mode of use of the product.
309: 
310:   "Installation Information" for a User Product means any methods,
311: procedures, authorization keys, or other information required to install
312: and execute modified versions of a covered work in that User Product from
313: a modified version of its Corresponding Source.  The information must
314: suffice to ensure that the continued functioning of the modified object
315: code is in no case prevented or interfered with solely because
316: modification has been made.
317: 
318:   If you convey an object code work under this section in, or with, or
319: specifically for use in, a User Product, and the conveying occurs as
320: part of a transaction in which the right of possession and use of the
321: User Product is transferred to the recipient in perpetuity or for a
322: fixed term (regardless of how the transaction is characterized), the
323: Corresponding Source conveyed under this section must be accompanied
324: by the Installation Information.  But this requirement does not apply
325: if neither you nor any third party retains the ability to install
326: modified object code on the User Product (for example, the work has
327: been installed in ROM).
328: 
329:   The requirement to provide Installation Information does not include a
330: requirement to continue to provide support service, warranty, or updates
331: for a work that has been modified or installed by the recipient, or for
332: the User Product in which it has been modified or installed.  Access to a
333: network may be denied when the modification itself materially and
334: adversely affects the operation of the network or violates the rules and
335: protocols for communication across the network.
336: 
337:   Corresponding Source conveyed, and Installation Information provided,
338: in accord with this section must be in a format that is publicly
339: documented (and with an implementation available to the public in
340: source code form), and must require no special password or key for
341: unpacking, reading or copying.
342: 
343:   7. Additional Terms.
344: 
345:   "Additional permissions" are terms that supplement the terms of this
346: License by making exceptions from one or more of its conditions.
347: Additional permissions that are applicable to the entire Program shall
348: be treated as though they were included in this License, to the extent
349: that they are valid under applicable law.  If additional permissions
350: apply only to part of the Program, that part may be used separately
351: under those permissions, but the entire Program remains governed by
352: this License without regard to the additional permissions.
353: 
354:   When you convey a copy of a covered work, you may at your option
355: remove any additional permissions from that copy, or from any part of
356: it.  (Additional permissions may be written to require their own
357: removal in certain cases when you modify the work.)  You may place
358: additional permissions on material, added by you to a covered work,
359: for which you have or can give appropriate copyright permission.
360: 
361:   Notwithstanding any other provision of this License, for material you
362: add to a covered work, you may (if authorized by the copyright holders of
363: that material) supplement the terms of this License with terms:
364: 
365:     a) Disclaiming warranty or limiting liability differently from the
366:     terms of sections 15 and 16 of this License; or
367: 
368:     b) Requiring preservation of specified reasonable legal notices or
369:     author attributions in that material or in the Appropriate Legal
370:     Notices displayed by works containing it; or
371: 
372:     c) Prohibiting misrepresentation of the origin of that material, or
373:     requiring that modified versions of such material be marked in
374:     reasonable ways as different from the original version; or
375: 
376:     d) Limiting the use for publicity purposes of names of licensors or
377:     authors of the material; or
378: 
379:     e) Declining to grant rights under trademark law for use of some
380:     trade names, trademarks, or service marks; or
381: 
382:     f) Requiring indemnification of licensors and authors of that
383:     material by anyone who conveys the material (or modified versions of
384:     it) with contractual assumptions of liability to the recipient, for
385:     any liability that these contractual assumptions directly impose on
386:     those licensors and authors.
387: 
388:   All other non-permissive additional terms are considered "further
389: restrictions" within the meaning of section 10.  If the Program as you
390: received it, or any part of it, contains a notice stating that it is
391: governed by this License along with a term that is a further
392: restriction, you may remove that term.  If a license document contains
393: a further restriction but permits relicensing or conveying under this
394: License, you may add to a covered work material governed by the terms
395: of that license document, provided that the further restriction does
396: not survive such relicensing or conveying.
397: 
398:   If you add terms to a covered work in accord with this section, you
399: must place, in the relevant source files, a statement of the
400: additional terms that apply to those files, or a notice indicating
401: where to find the applicable terms.
402: 
403:   Additional terms, permissive or non-permissive, may be stated in the
404: form of a separately written license, or stated as exceptions;
405: the above requirements apply either way.
406: 
407:   8. Termination.
408: 
409:   You may not propagate or modify a covered work except as expressly
410: provided under this License.  Any attempt otherwise to propagate or
411: modify it is void, and will automatically terminate your rights under
412: this License (including any patent licenses granted under the third
413: paragraph of section 11).
414: 
415:   However, if you cease all violation of this License, then your
416: license from a particular copyright holder is reinstated (a)
417: provisionally, unless and until the copyright holder explicitly and
418: finally terminates your license, and (b) permanently, if the copyright
419: holder fails to notify you of the violation by some reasonable means
420: prior to 60 days after the cessation.
421: 
422:   Moreover, your license from a particular copyright holder is
423: reinstated permanently if the copyright holder notifies you of the
424: violation by some reasonable means, this is the first time you have
425: received notice of violation of this License (for any work) from that
426: copyright holder, and you cure the violation prior to 30 days after
427: your receipt of the notice.
428: 
429:   Termination of your rights under this section does not terminate the
430: licenses of parties who have received copies or rights from you under
431: this License.  If your rights have been terminated and not permanently
432: reinstated, you do not qualify to receive new licenses for the same
433: material under section 10.
434: 
435:   9. Acceptance Not Required for Having Copies.
436: 
437:   You are not required to accept this License in order to receive or
438: run a copy of the Program.  Ancillary propagation of a covered work
439: occurring solely as a consequence of using peer-to-peer transmission
440: to receive a copy likewise does not require acceptance.  However,
441: nothing other than this License grants you permission to propagate or
442: modify any covered work.  These actions infringe copyright if you do
443: not accept this License.  Therefore, by modifying or propagating a
444: covered work, you indicate your acceptance of this License to do so.
445: 
446:   10. Automatic Licensing of Downstream Recipients.
447: 
448:   Each time you convey a covered work, the recipient automatically
449: receives a license from the original licensors, to run, modify and
450: propagate that work, subject to this License.  You are not responsible
451: for enforcing compliance by third parties with this License.
452: 
453:   An "entity transaction" is a transaction transferring control of an
454: organization, or substantially all assets of one, or subdividing an
455: organization, or merging organizations.  If propagation of a covered
456: work results from an entity transaction, each party to that
457: transaction who receives a copy of the work also receives whatever
458: licenses to the work the party's predecessor in interest had or could
459: give under the previous paragraph, plus a right to possession of the
460: Corresponding Source of the work from the predecessor in interest, if
461: the predecessor has it or can get it with reasonable efforts.
462: 
463:   You may not impose any further restrictions on the exercise of the
464: rights granted or affirmed under this License.  For example, you may
465: not impose a license fee, royalty, or other charge for exercise of
466: rights granted under this License, and you may not initiate litigation
467: (including a cross-claim or counterclaim in a lawsuit) alleging that
468: any patent claim is infringed by making, using, selling, offering for
469: sale, or importing the Program or any portion of it.
470: 
471:   11. Patents.
472: 
473:   A "contributor" is a copyright holder who authorizes use under this
474: License of the Program or a work on which the Program is based.  The
475: work thus licensed is called the contributor's "contributor version".
476: 
477:   A contributor's "essential patent claims" are all patent claims
478: owned or controlled by the contributor, whether already acquired or
479: hereafter acquired, that would be infringed by some manner, permitted
480: by this License, of making, using, or selling its contributor version,
481: but do not include claims that would be infringed only as a
482: consequence of further modification of the contributor version.  For
483: purposes of this definition, "control" includes the right to grant
484: patent sublicenses in a manner consistent with the requirements of
485: this License.
486: 
487:   Each contributor grants you a non-exclusive, worldwide, royalty-free
488: patent license under the contributor's essential patent claims, to
489: make, use, sell, offer for sale, import and otherwise run, modify and
490: propagate the contents of its contributor version.
491: 
492:   In the following three paragraphs, a "patent license" is any express
493: agreement or commitment, however denominated, not to enforce a patent
494: (such as an express permission to practice a patent or covenant not to
495: sue for patent infringement).  To "grant" such a patent license to a
496: party means to make such an agreement or commitment not to enforce a
497: patent against the party.
498: 
499:   If you convey a covered work, knowingly relying on a patent license,
500: and the Corresponding Source of the work is not available for anyone
501: to copy, free of charge and under the terms of this License, through a
502: publicly available network server or other readily accessible means,
503: then you must either (1) cause the Corresponding Source to be so
504: available, or (2) arrange to deprive yourself of the benefit of the
505: patent license for this particular work, or (3) arrange, in a manner
506: consistent with the requirements of this License, to extend the patent
507: license to downstream recipients.  "Knowingly relying" means you have
508: actual knowledge that, but for the patent license, your conveying the
509: covered work in a country, or your recipient's use of the covered work
510: in a country, would infringe one or more identifiable patents in that
511: country that you have reason to believe are valid.
512: 
513:   If, pursuant to or in connection with a single transaction or
514: arrangement, you convey, or propagate by procuring conveyance of, a
515: covered work, and grant a patent license to some of the parties
516: receiving the covered work authorizing them to use, propagate, modify
517: or convey a specific copy of the covered work, then the patent license
518: you grant is automatically extended to all recipients of the covered
519: work and works based on it.
520: 
521:   A patent license is "discriminatory" if it does not include within
522: the scope of its coverage, prohibits the exercise of, or is
523: conditioned on the non-exercise of one or more of the rights that are
524: specifically granted under this License.  You may not convey a covered
525: work if you are a party to an arrangement with a third party that is
526: in the business of distributing software, under which you make payment
527: to the third party based on the extent of your activity of conveying
528: the work, and under which the third party grants, to any of the
529: parties who would receive the covered work from you, a discriminatory
530: patent license (a) in connection with copies of the covered work
531: conveyed by you (or copies made from those copies), or (b) primarily
532: for and in connection with specific products or compilations that
533: contain the covered work, unless you entered into that arrangement,
534: or that patent license was granted, prior to 28 March 2007.
535: 
536:   Nothing in this License shall be construed as excluding or limiting
537: any implied license or other defenses to infringement that may
538: otherwise be available to you under applicable patent law.
539: 
540:   12. No Surrender of Others' Freedom.
541: 
542:   If conditions are imposed on you (whether by court order, agreement or
543: otherwise) that contradict the conditions of this License, they do not
544: excuse you from the conditions of this License.  If you cannot convey a
545: covered work so as to satisfy simultaneously your obligations under this
546: License and any other pertinent obligations, then as a consequence you may
547: not convey it at all.  For example, if you agree to terms that obligate you
548: to collect a royalty for further conveying from those to whom you convey
549: the Program, the only way you could satisfy both those terms and this
550: License would be to refrain entirely from conveying the Program.
551: 
552:   13. Use with the GNU Affero General Public License.
553: 
554:   Notwithstanding any other provision of this License, you have
555: permission to link or combine any covered work with a work licensed
556: under version 3 of the GNU Affero General Public License into a single
557: combined work, and to convey the resulting work.  The terms of this
558: License will continue to apply to the part which is the covered work,
559: but the special requirements of the GNU Affero General Public License,
560: section 13, concerning interaction through a network will apply to the
561: combination as such.
562: 
563:   14. Revised Versions of this License.
564: 
565:   The Free Software Foundation may publish revised and/or new versions of
566: the GNU General Public License from time to time.  Such new versions will
567: be similar in spirit to the present version, but may differ in detail to
568: address new problems or concerns.
569: 
570:   Each version is given a distinguishing version number.  If the
571: Program specifies that a certain numbered version of the GNU General
572: Public License "or any later version" applies to it, you have the
573: option of following the terms and conditions either of that numbered
574: version or of any later version published by the Free Software
575: Foundation.  If the Program does not specify a version number of the
576: GNU General Public License, you may choose any version ever published
577: by the Free Software Foundation.
578: 
579:   If the Program specifies that a proxy can decide which future
580: versions of the GNU General Public License can be used, that proxy's
581: public statement of acceptance of a version permanently authorizes you
582: to choose that version for the Program.
583: 
584:   Later license versions may give you additional or different
585: permissions.  However, no additional obligations are imposed on any
586: author or copyright holder as a result of your choosing to follow a
587: later version.
588: 
589:   15. Disclaimer of Warranty.
590: 
591:   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
592: APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
593: HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
594: OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
595: THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
596: PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
597: IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
598: ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
599: 
600:   16. Limitation of Liability.
601: 
602:   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
603: WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
604: THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
605: GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
606: USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
607: DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
608: PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
609: EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
610: SUCH DAMAGES.
611: 
612:   17. Interpretation of Sections 15 and 16.
613: 
614:   If the disclaimer of warranty and limitation of liability provided
615: above cannot be given local legal effect according to their terms,
616: reviewing courts shall apply local law that most closely approximates
617: an absolute waiver of all civil liability in connection with the
618: Program, unless a warranty or assumption of liability accompanies a
619: copy of the Program in return for a fee.
620: 
621:                      END OF TERMS AND CONDITIONS
622: 
623:             How to Apply These Terms to Your New Programs
624: 
625:   If you develop a new program, and you want it to be of the greatest
626: possible use to the public, the best way to achieve this is to make it
627: free software which everyone can redistribute and change under these terms.
628: 
629:   To do so, attach the following notices to the program.  It is safest
630: to attach them to the start of each source file to most effectively
631: state the exclusion of warranty; and each file should have at least
632: the "copyright" line and a pointer to where the full notice is found.
633: 
634:     <one line to give the program's name and a brief idea of what it does.>
635:     Copyright (C) <year>  <name of author>
636: 
637:     This program is free software: you can redistribute it and/or modify
638:     it under the terms of the GNU General Public License as published by
639:     the Free Software Foundation, either version 3 of the License, or
640:     (at your option) any later version.
641: 
642:     This program is distributed in the hope that it will be useful,
643:     but WITHOUT ANY WARRANTY; without even the implied warranty of
644:     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
645:     GNU General Public License for more details.
646: 
647:     You should have received a copy of the GNU General Public License
648:     along with this program.  If not, see <https://www.gnu.org/licenses/>.
649: 
650: Also add information on how to contact you by electronic and paper mail.
651: 
652:   If the program does terminal interaction, make it output a short
653: notice like this when it starts in an interactive mode:
654: 
655:     <program>  Copyright (C) <year>  <name of author>
656:     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
657:     This is free software, and you are welcome to redistribute it
658:     under certain conditions; type `show c' for details.
659: 
660: The hypothetical commands `show w' and `show c' should show the appropriate
661: parts of the General Public License.  Of course, your program's commands
662: might be different; for a GUI interface, you would use an "about box".
663: 
664:   You should also get your employer (if you work as a programmer) or school,
665: if any, to sign a "copyright disclaimer" for the program, if necessary.
666: For more information on this, and how to apply and follow the GNU GPL, see
667: <https://www.gnu.org/licenses/>.
668: 
669:   The GNU General Public License does not permit incorporating your program
670: into proprietary programs.  If your program is a subroutine library, you
671: may consider it more useful to permit linking proprietary applications with
672: the library.  If this is what you want to do, use the GNU Lesser General
673: Public License instead of this License.  But first, please read
674: <https://www.gnu.org/licenses/why-not-lgpl.html>.


./main.go
1: package main
2: 
3: import (
4: 	"flag"
5: 	"fmt"
6: 	"os"
7: 	"os/signal"
8: 	"path/filepath"
9: 	"runtime"
10: 	"syscall"
11: 	_ "time/tzdata"
12: 
13: 	"github.com/Dreamacro/clash/config"
14: 	C "github.com/Dreamacro/clash/constant"
15: 	"github.com/Dreamacro/clash/hub"
16: 	"github.com/Dreamacro/clash/hub/executor"
17: 	"github.com/Dreamacro/clash/log"
18: 
19: 	"go.uber.org/automaxprocs/maxprocs"
20: )
21: 
22: var (
23: 	version            bool
24: 	testConfig         bool
25: 	homeDir            string
26: 	configFile         string
27: 	externalUI         string
28: 	externalController string
29: 	secret             string
30: )
31: 
32: func init() {
33: 	flag.StringVar(&homeDir, "d", os.Getenv("CLASH_HOME_DIR"), "set configuration directory")
34: 	flag.StringVar(&configFile, "f", os.Getenv("CLASH_CONFIG_FILE"), "specify configuration file")
35: 	flag.StringVar(&externalUI, "ext-ui", os.Getenv("CLASH_OVERRIDE_EXTERNAL_UI_DIR"), "override external ui directory")
36: 	flag.StringVar(&externalController, "ext-ctl", os.Getenv("CLASH_OVERRIDE_EXTERNAL_CONTROLLER"), "override external controller address")
37: 	flag.StringVar(&secret, "secret", os.Getenv("CLASH_OVERRIDE_SECRET"), "override secret for RESTful API")
38: 	flag.BoolVar(&version, "v", false, "show current version of clash")
39: 	flag.BoolVar(&testConfig, "t", false, "test configuration and exit")
40: 	flag.Parse()
41: }
42: 
43: func main() {
44: 	maxprocs.Set(maxprocs.Logger(func(string, ...any) {}))
45: 	if version {
46: 		fmt.Printf("Clash %s %s %s with %s %s\n", C.Version, runtime.GOOS, runtime.GOARCH, runtime.Version(), C.BuildTime)
47: 		return
48: 	}
49: 
50: 	if homeDir != "" {
51: 		if !filepath.IsAbs(homeDir) {
52: 			currentDir, _ := os.Getwd()
53: 			homeDir = filepath.Join(currentDir, homeDir)
54: 		}
55: 		C.SetHomeDir(homeDir)
56: 	}
57: 
58: 	if configFile != "" {
59: 		if !filepath.IsAbs(configFile) {
60: 			currentDir, _ := os.Getwd()
61: 			configFile = filepath.Join(currentDir, configFile)
62: 		}
63: 		C.SetConfig(configFile)
64: 	} else {
65: 		configFile := filepath.Join(C.Path.HomeDir(), C.Path.Config())
66: 		C.SetConfig(configFile)
67: 	}
68: 
69: 	if err := config.Init(C.Path.HomeDir()); err != nil {
70: 		log.Fatalln("Initial configuration directory error: %s", err.Error())
71: 	}
72: 
73: 	if testConfig {
74: 		if _, err := executor.Parse(); err != nil {
75: 			log.Errorln(err.Error())
76: 			fmt.Printf("configuration file %s test failed\n", C.Path.Config())
77: 			os.Exit(1)
78: 		}
79: 		fmt.Printf("configuration file %s test is successful\n", C.Path.Config())
80: 		return
81: 	}
82: 
83: 	var options []hub.Option
84: 	if externalUI != "" {
85: 		options = append(options, hub.WithExternalUI(externalUI))
86: 	}
87: 	if externalController != "" {
88: 		options = append(options, hub.WithExternalController(externalController))
89: 	}
90: 	if secret != "" {
91: 		options = append(options, hub.WithSecret(secret))
92: 	}
93: 
94: 	if err := hub.Parse(options...); err != nil {
95: 		log.Fatalln("Parse config error: %s", err.Error())
96: 	}
97: 
98: 	termSign := make(chan os.Signal, 1)
99: 	hupSign := make(chan os.Signal, 1)
100: 	signal.Notify(termSign, syscall.SIGINT, syscall.SIGTERM)
101: 	signal.Notify(hupSign, syscall.SIGHUP)
102: 	for {
103: 		select {
104: 		case <-termSign:
105: 			return
106: 		case <-hupSign:
107: 			if cfg, err := executor.ParseWithPath(C.Path.Config()); err == nil {
108: 				executor.ApplyConfig(cfg, true)
109: 			} else {
110: 				log.Errorln("Parse config error: %s", err.Error())
111: 			}
112: 		}
113: 	}
114: }


./Makefile
1: NAME=clash
2: BINDIR=bin
3: VERSION=$(shell git describe --tags || echo "unknown version")
4: BUILDTIME=$(shell date -u)
5: GOBUILD=CGO_ENABLED=0 go build -trimpath -ldflags '-X "github.com/Dreamacro/clash/constant.Version=$(VERSION)" \
6: 		-X "github.com/Dreamacro/clash/constant.BuildTime=$(BUILDTIME)" \
7: 		-w -s -buildid='
8: 
9: PLATFORM_LIST = \
10: 	darwin-amd64 \
11: 	darwin-amd64-v3 \
12: 	darwin-arm64 \
13: 	linux-386 \
14: 	linux-amd64 \
15: 	linux-amd64-v3 \
16: 	linux-armv5 \
17: 	linux-armv6 \
18: 	linux-armv7 \
19: 	linux-arm64 \
20: 	linux-mips-softfloat \
21: 	linux-mips-hardfloat \
22: 	linux-mipsle-softfloat \
23: 	linux-mipsle-hardfloat \
24: 	linux-mips64 \
25: 	linux-mips64le \
26: 	linux-riscv64 \
27: 	linux-loong64 \
28: 	freebsd-386 \
29: 	freebsd-amd64 \
30: 	freebsd-amd64-v3 \
31: 	freebsd-arm64
32: 
33: WINDOWS_ARCH_LIST = \
34: 	windows-386 \
35: 	windows-amd64 \
36: 	windows-amd64-v3 \
37: 	windows-arm64 \
38: 	windows-armv7
39: 
40: all: linux-amd64 darwin-amd64 windows-amd64 # Most used
41: 
42: darwin-amd64:
43: 	GOARCH=amd64 GOOS=darwin $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
44: 
45: darwin-amd64-v3:
46: 	GOARCH=amd64 GOOS=darwin GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
47: 
48: darwin-arm64:
49: 	GOARCH=arm64 GOOS=darwin $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
50: 
51: linux-386:
52: 	GOARCH=386 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
53: 
54: linux-amd64:
55: 	GOARCH=amd64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
56: 
57: linux-amd64-v3:
58: 	GOARCH=amd64 GOOS=linux GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
59: 
60: linux-armv5:
61: 	GOARCH=arm GOOS=linux GOARM=5 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
62: 
63: linux-armv6:
64: 	GOARCH=arm GOOS=linux GOARM=6 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
65: 
66: linux-armv7:
67: 	GOARCH=arm GOOS=linux GOARM=7 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
68: 
69: linux-arm64:
70: 	GOARCH=arm64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
71: 
72: linux-mips-softfloat:
73: 	GOARCH=mips GOMIPS=softfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
74: 
75: linux-mips-hardfloat:
76: 	GOARCH=mips GOMIPS=hardfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
77: 
78: linux-mipsle-softfloat:
79: 	GOARCH=mipsle GOMIPS=softfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
80: 
81: linux-mipsle-hardfloat:
82: 	GOARCH=mipsle GOMIPS=hardfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
83: 
84: linux-mips64:
85: 	GOARCH=mips64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
86: 
87: linux-mips64le:
88: 	GOARCH=mips64le GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
89: 
90: linux-riscv64:
91: 	GOARCH=riscv64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
92: 
93: linux-loong64:
94: 	GOARCH=loong64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
95: 
96: freebsd-386:
97: 	GOARCH=386 GOOS=freebsd $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
98: 
99: freebsd-amd64:
100: 	GOARCH=amd64 GOOS=freebsd $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
101: 
102: freebsd-amd64-v3:
103: 	GOARCH=amd64 GOOS=freebsd GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
104: 
105: freebsd-arm64:
106: 	GOARCH=arm64 GOOS=freebsd $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
107: 
108: windows-386:
109: 	GOARCH=386 GOOS=windows $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
110: 
111: windows-amd64:
112: 	GOARCH=amd64 GOOS=windows $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
113: 
114: windows-amd64-v3:
115: 	GOARCH=amd64 GOOS=windows GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
116: 
117: windows-arm64:
118: 	GOARCH=arm64 GOOS=windows $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
119: 
120: windows-armv7:
121: 	GOARCH=arm GOOS=windows GOARM=7 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
122: 
123: gz_releases=$(addsuffix .gz, $(PLATFORM_LIST))
124: zip_releases=$(addsuffix .zip, $(WINDOWS_ARCH_LIST))
125: 
126: $(gz_releases): %.gz : %
127: 	chmod +x $(BINDIR)/$(NAME)-$(basename $@)
128: 	gzip -f -S -$(VERSION).gz $(BINDIR)/$(NAME)-$(basename $@)
129: 
130: $(zip_releases): %.zip : %
131: 	zip -m -j $(BINDIR)/$(NAME)-$(basename $@)-$(VERSION).zip $(BINDIR)/$(NAME)-$(basename $@).exe
132: 
133: all-arch: $(PLATFORM_LIST) $(WINDOWS_ARCH_LIST)
134: 
135: releases: $(gz_releases) $(zip_releases)
136: 
137: LINT_OS_LIST := darwin windows linux freebsd openbsd
138: 
139: lint: $(foreach os,$(LINT_OS_LIST),$(os)-lint)
140: %-lint:
141: 	GOOS=$* golangci-lint run ./...
142: 
143: lint-fix: $(foreach os,$(LINT_OS_LIST),$(os)-lint-fix)
144: %-lint-fix:
145: 	GOOS=$* golangci-lint run --fix ./...
146: 
147: clean:
148: 	rm $(BINDIR)/*


./output.txt
1: ./.gitignore
2: 1: # Binaries for programs and plugins
3: 2: *.exe
4: 3: *.exe~
5: 4: *.dll
6: 5: *.so
7: 6: *.dylib
8: 7: bin/*
9: 8: 
10: 9: # Test binary, build with `go test -c`
11: 10: *.test
12: 11: 
13: 12: # Output of the go coverage tool, specifically when used with LiteIDE
14: 13: *.out
15: 14: 
16: 15: # go mod vendor
17: 16: vendor
18: 17: 
19: 18: # GoLand
20: 19: .idea/*
21: 20: 
22: 21: # macOS file
23: 22: .DS_Store
24: 23: 
25: 24: # test suite
26: 25: test/config/cache*
27: 26: 
28: 27: # docs site generator
29: 28: node_modules
30: 29: package-lock.json
31: 30: pnpm-lock.yaml
32: 31: 
33: 32: # docs site cache
34: 33: docs/.vitepress/cache
35: 34: 
36: 35: # docs site build files
37: 36: docs/.vitepress/dist
38: 
39: 
40: ./.golangci.yaml
41: 1: linters:
42: 2:   disable-all: true
43: 3:   enable:
44: 4:     - gci
45: 5:     - gofumpt
46: 6:     - gosimple
47: 7:     - govet
48: 8:     - ineffassign
49: 9:     - misspell
50: 10:     - staticcheck
51: 11:     - unconvert
52: 12:     - unused
53: 13:     - usestdlibvars
54: 14:     - exhaustive
55: 15: 
56: 16: linters-settings:
57: 17:   gci:
58: 18:     custom-order: true
59: 19:     sections:
60: 20:       - standard
61: 21:       - prefix(github.com/Dreamacro/clash)
62: 22:       - default
63: 23:   staticcheck:
64: 24:     go: '1.21'
65: 25:   exhaustive:
66: 26:     default-signifies-exhaustive: true
67: 
68: 
69: ./config.json
70: 1: {
71: 2:     "ignore_paths": ["node_modules", ".git"],
72: 3:     "ignore_extensions": [".log", ".tmp", ".png", ".jpg", ".img", ".mbr"]
73: 4:   }
74: 5:   
75: 
76: ./Dockerfile
77: 1: FROM --platform=${BUILDPLATFORM} golang:alpine as builder
78: 2: 
79: 3: RUN apk add --no-cache make git ca-certificates && \
80: 4:     wget -O /Country.mmdb https://github.com/Dreamacro/maxmind-geoip/releases/latest/download/Country.mmdb
81: 5: WORKDIR /workdir
82: 6: COPY --from=tonistiigi/xx:golang / /
83: 7: ARG TARGETOS TARGETARCH TARGETVARIANT
84: 8: 
85: 9: RUN --mount=target=. \
86: 10:     --mount=type=cache,target=/root/.cache/go-build \
87: 11:     --mount=type=cache,target=/go/pkg/mod \
88: 12:     make BINDIR= ${TARGETOS}-${TARGETARCH}${TARGETVARIANT} && \
89: 13:     mv /clash* /clash
90: 14: 
91: 15: FROM alpine:latest
92: 16: LABEL org.opencontainers.image.source="https://github.com/Dreamacro/clash"
93: 17: 
94: 18: COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
95: 19: COPY --from=builder /Country.mmdb /root/.config/clash/
96: 20: COPY --from=builder /clash /
97: 21: ENTRYPOINT ["/clash"]
98: 
99: 
100: ./extract.py
101: 1: import json
102: 2: import os
103: 3: 
104: 4: def load_config(config_path):
105: 5:     with open(config_path, 'r') as config_file:
106: 6:         return json.load(config_file)
107: 7: 
108: 8: def is_binary_file(file_path):
109: 9:     try:
110: 10:         with open(file_path, 'r', encoding='utf-8') as file:
111: 11:             # 尝试读取文件内容，检查是否包含非文本字符
112: 12:             if '\0' in file.read(1024):
113: 13:                 return True
114: 14:     except Exception as e:
115: 15:         print(f"Cannot read file {file_path} due to {e}, assuming binary.")
116: 16:         return True
117: 17:     return False
118: 18: 
119: 19: def should_ignore(path, filename, config):
120: 20:     for ignore_path in config['ignore_paths']:
121: 21:         if ignore_path in path.split(os.sep):
122: 22:             return True
123: 23:     for ignore_ext in config['ignore_extensions']:
124: 24:         if filename.endswith(ignore_ext):
125: 25:             return True
126: 26:     return False
127: 27: 
128: 28: def format_file_content(file_path, is_binary):
129: 29:     # 如果文件是二进制文件，只记录文件名
130: 30:     if is_binary:
131: 31:         return f"{file_path}\n- BINARY FILE -\n\n"
132: 32:     else:
133: 33:         # 文本文件，记录文件路径及内容，并忽略无法解码的字节
134: 34:         try:
135: 35:             with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
136: 36:                 lines = file.readlines()
137: 37:             content_with_line_numbers = ''.join(f"{idx + 1}: {line}" for idx, line in enumerate(lines))
138: 38:             formatted_content = f"{file_path}\n{content_with_line_numbers}\n\n"
139: 39:         except Exception as e:
140: 40:             # 如果读取文件时发生了未知错误，记录错误并跳过文件
141: 41:             formatted_content = f"{file_path}\n- ERROR READING FILE: {e} -\n\n"
142: 42:         return formatted_content
143: 43: 
144: 44: def traverse_and_extract(project_path, output_path, config):
145: 45:     with open(output_path, 'w', encoding='utf-8') as output_file:  # 指定UTF-8编码
146: 46:         for root, dirs, files in os.walk(project_path):
147: 47:             # 过滤掉忽略配置中的目录
148: 48:             dirs[:] = [d for d in dirs if not should_ignore(root, d, config)]
149: 49:             for filename in files:
150: 50:                 # 忽略配置中指定要忽略的文件
151: 51:                 if should_ignore(root, filename, config):
152: 52:                     continue
153: 53:                 # 不被忽略的文件，将其内容写入输出文件
154: 54:                 file_path = os.path.join(root, filename)
155: 55:                 is_binary = is_binary_file(file_path)
156: 56:                 output_file.write(format_file_content(file_path, is_binary))
157: 57: 
158: 58: # 示例配置，默认所有文件都被遍历，除了配置中忽略的文件类型和路径
159: 59: config = {
160: 60:     "ignore_paths": [],
161: 61:     "ignore_extensions": []
162: 62: }
163: 63: 
164: 64: # 使用示例
165: 65: config_file_path = 'config.json'  # 更改为你的配置文件路径
166: 66: output_file_path = 'output.txt'   # 更改为你的输出文件路径
167: 67: project_path = './'          # 更改为你的项目目录路径
168: 68: 
169: 69: # 加载配置
170: 70: config = load_config(config_file_path)
171: 71: 
172: 72: # 提取文件内容并写入到输出文件中
173: 73: traverse_and_extract(project_path, output_file_path, config)
174: 
175: ./go.mod
176: 1: module github.com/Dreamacro/clash
177: 2: 
178: 3: go 1.21
179: 4: 
180: 5: require (
181: 6: 	github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158
182: 7: 	github.com/dlclark/regexp2 v1.10.0
183: 8: 	github.com/go-chi/chi/v5 v5.0.10
184: 9: 	github.com/go-chi/cors v1.2.1
185: 10: 	github.com/go-chi/render v1.0.3
186: 11: 	github.com/gofrs/uuid/v5 v5.0.0
187: 12: 	github.com/gorilla/websocket v1.5.0
188: 13: 	github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d
189: 14: 	github.com/mdlayher/netlink v1.7.2
190: 15: 	github.com/miekg/dns v1.1.55
191: 16: 	github.com/oschwald/geoip2-golang v1.9.0
192: 17: 	github.com/samber/lo v1.38.1
193: 18: 	github.com/sirupsen/logrus v1.9.3
194: 19: 	github.com/stretchr/testify v1.8.4
195: 20: 	github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01
196: 21: 	go.etcd.io/bbolt v1.3.7
197: 22: 	go.uber.org/atomic v1.11.0
198: 23: 	go.uber.org/automaxprocs v1.5.3
199: 24: 	golang.org/x/crypto v0.12.0
200: 25: 	golang.org/x/net v0.14.0
201: 26: 	golang.org/x/sync v0.3.0
202: 27: 	golang.org/x/sys v0.11.0
203: 28: 	gopkg.in/yaml.v3 v3.0.1
204: 29: )
205: 30: 
206: 31: require (
207: 32: 	github.com/ajg/form v1.5.1 // indirect
208: 33: 	github.com/davecgh/go-spew v1.1.1 // indirect
209: 34: 	github.com/google/go-cmp v0.5.9 // indirect
210: 35: 	github.com/josharian/native v1.1.0 // indirect
211: 36: 	github.com/kr/text v0.2.0 // indirect
212: 37: 	github.com/mdlayher/socket v0.4.1 // indirect
213: 38: 	github.com/oschwald/maxminddb-golang v1.11.0 // indirect
214: 39: 	github.com/pierrec/lz4/v4 v4.1.14 // indirect
215: 40: 	github.com/pmezard/go-difflib v1.0.0 // indirect
216: 41: 	github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923 // indirect
217: 42: 	github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae // indirect
218: 43: 	golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 // indirect
219: 44: 	golang.org/x/mod v0.8.0 // indirect
220: 45: 	golang.org/x/text v0.12.0 // indirect
221: 46: 	golang.org/x/tools v0.6.0 // indirect
222: 47: )
223: 
224: 
225: ./go.sum
226: 1: github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158 h1:JFnwKplz9hj8ubqYjm8HkgZS1Rvz9yW+u/XCNNTxr0k=
227: 2: github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158/go.mod h1:QvmEZ/h6KXszPOr2wUFl7Zn3hfFNYdfbXwPVDTyZs6k=
228: 3: github.com/ajg/form v1.5.1 h1:t9c7v8JUKu/XxOGBU0yjNpaMloxGEJhUkqFRq0ibGeU=
229: 4: github.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=
230: 5: github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
231: 6: github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
232: 7: github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
233: 8: github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
234: 9: github.com/dlclark/regexp2 v1.10.0 h1:+/GIL799phkJqYW+3YbOd8LCcbHzT0Pbo8zl70MHsq0=
235: 10: github.com/dlclark/regexp2 v1.10.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=
236: 11: github.com/go-chi/chi/v5 v5.0.10 h1:rLz5avzKpjqxrYwXNfmjkrYYXOyLJd37pz53UFHC6vk=
237: 12: github.com/go-chi/chi/v5 v5.0.10/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=
238: 13: github.com/go-chi/cors v1.2.1 h1:xEC8UT3Rlp2QuWNEr4Fs/c2EAGVKBwy/1vHx3bppil4=
239: 14: github.com/go-chi/cors v1.2.1/go.mod h1:sSbTewc+6wYHBBCW7ytsFSn836hqM7JxpglAy2Vzc58=
240: 15: github.com/go-chi/render v1.0.3 h1:AsXqd2a1/INaIfUSKq3G5uA8weYx20FOsM7uSoCyyt4=
241: 16: github.com/go-chi/render v1.0.3/go.mod h1:/gr3hVkmYR0YlEy3LxCuVRFzEu9Ruok+gFqbIofjao0=
242: 17: github.com/gofrs/uuid/v5 v5.0.0 h1:p544++a97kEL+svbcFbCQVM9KFu0Yo25UoISXGNNH9M=
243: 18: github.com/gofrs/uuid/v5 v5.0.0/go.mod h1:CDOjlDMVAtN56jqyRUZh58JT31Tiw7/oQyEXZV+9bD8=
244: 19: github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=
245: 20: github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
246: 21: github.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=
247: 22: github.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
248: 23: github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d h1:Ka64cclWedOkGzm9M2/XYuwJUdmWRUozmsxW0PyKA3A=
249: 24: github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d/go.mod h1:7474bZ1YNCvarT6WFKie4kEET6J0KYRDC4XJqqXzQW4=
250: 25: github.com/josharian/native v1.0.1-0.20221213033349-c1e37c09b531/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=
251: 26: github.com/josharian/native v1.1.0 h1:uuaP0hAbW7Y4l0ZRQ6C9zfb7Mg1mbFKry/xzDAfmtLA=
252: 27: github.com/josharian/native v1.1.0/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=
253: 28: github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
254: 29: github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
255: 30: github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
256: 31: github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
257: 32: github.com/mdlayher/netlink v1.7.2 h1:/UtM3ofJap7Vl4QWCPDGXY8d3GIY2UGSDbK+QWmY8/g=
258: 33: github.com/mdlayher/netlink v1.7.2/go.mod h1:xraEF7uJbxLhc5fpHL4cPe221LI2bdttWlU+ZGLfQSw=
259: 34: github.com/mdlayher/socket v0.4.1 h1:eM9y2/jlbs1M615oshPQOHZzj6R6wMT7bX5NPiQvn2U=
260: 35: github.com/mdlayher/socket v0.4.1/go.mod h1:cAqeGjoufqdxWkD7DkpyS+wcefOtmu5OQ8KuoJGIReA=
261: 36: github.com/miekg/dns v1.1.55 h1:GoQ4hpsj0nFLYe+bWiCToyrBEJXkQfOOIvFGFy0lEgo=
262: 37: github.com/miekg/dns v1.1.55/go.mod h1:uInx36IzPl7FYnDcMeVWxj9byh7DutNykX4G9Sj60FY=
263: 38: github.com/oschwald/geoip2-golang v1.9.0 h1:uvD3O6fXAXs+usU+UGExshpdP13GAqp4GBrzN7IgKZc=
264: 39: github.com/oschwald/geoip2-golang v1.9.0/go.mod h1:BHK6TvDyATVQhKNbQBdrj9eAvuwOMi2zSFXizL3K81Y=
265: 40: github.com/oschwald/maxminddb-golang v1.11.0 h1:aSXMqYR/EPNjGE8epgqwDay+P30hCBZIveY0WZbAWh0=
266: 41: github.com/oschwald/maxminddb-golang v1.11.0/go.mod h1:YmVI+H0zh3ySFR3w+oz8PCfglAFj3PuCmui13+P9zDg=
267: 42: github.com/pierrec/lz4/v4 v4.1.14 h1:+fL8AQEZtz/ijeNnpduH0bROTu0O3NZAlPjQxGn8LwE=
268: 43: github.com/pierrec/lz4/v4 v4.1.14/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=
269: 44: github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
270: 45: github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
271: 46: github.com/prashantv/gostub v1.1.0 h1:BTyx3RfQjRHnUWaGF9oQos79AlQ5k8WNktv7VGvVH4g=
272: 47: github.com/prashantv/gostub v1.1.0/go.mod h1:A5zLQHz7ieHGG7is6LLXLz7I8+3LZzsrV0P1IAHhP5U=
273: 48: github.com/samber/lo v1.38.1 h1:j2XEAqXKb09Am4ebOg31SpvzUTTs6EN3VfgeLUhPdXM=
274: 49: github.com/samber/lo v1.38.1/go.mod h1:+m/ZKRl6ClXCE2Lgf3MsQlWfh4bn1bz6CXEOxnEXnEA=
275: 50: github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
276: 51: github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
277: 52: github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
278: 53: github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
279: 54: github.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=
280: 55: github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
281: 56: github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923 h1:tHNk7XK9GkmKUR6Gh8gVBKXc2MVSZ4G/NnWLtzw4gNA=
282: 57: github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923/go.mod h1:eLL9Nub3yfAho7qB0MzZizFhTU2QkLeoVsWdHtDW264=
283: 58: github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01 h1:F9xjJm4IH8VjcqG4ujciOF+GIM4mjPkHhWLLzOghPtM=
284: 59: github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01/go.mod h1:cAAsePK2e15YDAMJNyOpGYEWNe4sIghTY7gpz4cX/Ik=
285: 60: github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae h1:4hwBBUfQCFe3Cym0ZtKyq7L16eZUtYKs+BaHDN6mAns=
286: 61: github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae/go.mod h1:DD4vA1DwXk04H54A1oHXtwZmA0grkVMdPxx/VGLCah0=
287: 62: go.etcd.io/bbolt v1.3.7 h1:j+zJOnnEjF/kyHlDDgGnVL/AIqIJPq8UoB2GSNfkUfQ=
288: 63: go.etcd.io/bbolt v1.3.7/go.mod h1:N9Mkw9X8x5fupy0IKsmuqVtoGDyxsaDlbk4Rd05IAQw=
289: 64: go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
290: 65: go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
291: 66: go.uber.org/automaxprocs v1.5.3 h1:kWazyxZUrS3Gs4qUpbwo5kEIMGe/DAvi5Z4tl2NW4j8=
292: 67: go.uber.org/automaxprocs v1.5.3/go.mod h1:eRbA25aqJrxAbsLO0xy5jVwPt7FQnRgjW+efnwa1WM0=
293: 68: golang.org/x/crypto v0.12.0 h1:tFM/ta59kqch6LlvYnPa0yx5a83cL2nHflFhYKvv9Yk=
294: 69: golang.org/x/crypto v0.12.0/go.mod h1:NF0Gs7EO5K4qLn+Ylc+fih8BSTeIjAP05siRnAh98yw=
295: 70: golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 h1:3MTrJm4PyNL9NBqvYDSj3DHl46qQakyfqfWo4jgfaEM=
296: 71: golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17/go.mod h1:lgLbSvA5ygNOMpwM/9anMpWVlVJ7Z+cHWq/eFuinpGE=
297: 72: golang.org/x/mod v0.8.0 h1:LUYupSeNrTNCGzR/hVBk2NHZO4hXcVaW1k4Qx7rjPx8=
298: 73: golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
299: 74: golang.org/x/net v0.14.0 h1:BONx9s002vGdD9umnlX1Po8vOZmrgH34qlHcD1MfK14=
300: 75: golang.org/x/net v0.14.0/go.mod h1:PpSgVXXLK0OxS0F31C1/tv6XNguvCrnXIDrFMspZIUI=
301: 76: golang.org/x/sync v0.3.0 h1:ftCYgMx6zT/asHUrPw8BLLscYtGznsLAnjq5RH9P66E=
302: 77: golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
303: 78: golang.org/x/sys v0.0.0-20200217220822-9197077df867/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
304: 79: golang.org/x/sys v0.0.0-20220622161953-175b2fd9d664/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
305: 80: golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
306: 81: golang.org/x/sys v0.0.0-20220804214406-8e32c043e418/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
307: 82: golang.org/x/sys v0.11.0 h1:eG7RXZHdqOJ1i+0lgLgCpSXAp6M3LYlAo6osgSi0xOM=
308: 83: golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
309: 84: golang.org/x/text v0.12.0 h1:k+n5B8goJNdU7hSvEtMUz3d1Q6D/XW4COJSJR6fN0mc=
310: 85: golang.org/x/text v0.12.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
311: 86: golang.org/x/tools v0.6.0 h1:BOw41kyTf3PuCW1pVQf8+Cyg8pMlkYB1oo9iJ6D/lKM=
312: 87: golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
313: 88: gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
314: 89: gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
315: 90: gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
316: 91: gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
317: 92: gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
318: 93: gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
319: 
320: 
321: ./LICENSE
322: 1:                     GNU GENERAL PUBLIC LICENSE
323: 2:                        Version 3, 29 June 2007
324: 3: 
325: 4:  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
326: 5:  Everyone is permitted to copy and distribute verbatim copies
327: 6:  of this license document, but changing it is not allowed.
328: 7: 
329: 8:                             Preamble
330: 9: 
331: 10:   The GNU General Public License is a free, copyleft license for
332: 11: software and other kinds of works.
333: 12: 
334: 13:   The licenses for most software and other practical works are designed
335: 14: to take away your freedom to share and change the works.  By contrast,
336: 15: the GNU General Public License is intended to guarantee your freedom to
337: 16: share and change all versions of a program--to make sure it remains free
338: 17: software for all its users.  We, the Free Software Foundation, use the
339: 18: GNU General Public License for most of our software; it applies also to
340: 19: any other work released this way by its authors.  You can apply it to
341: 20: your programs, too.
342: 21: 
343: 22:   When we speak of free software, we are referring to freedom, not
344: 23: price.  Our General Public Licenses are designed to make sure that you
345: 24: have the freedom to distribute copies of free software (and charge for
346: 25: them if you wish), that you receive source code or can get it if you
347: 26: want it, that you can change the software or use pieces of it in new
348: 27: free programs, and that you know you can do these things.
349: 28: 
350: 29:   To protect your rights, we need to prevent others from denying you
351: 30: these rights or asking you to surrender the rights.  Therefore, you have
352: 31: certain responsibilities if you distribute copies of the software, or if
353: 32: you modify it: responsibilities to respect the freedom of others.
354: 33: 
355: 34:   For example, if you distribute copies of such a program, whether
356: 35: gratis or for a fee, you must pass on to the recipients the same
357: 36: freedoms that you received.  You must make sure that they, too, receive
358: 37: or can get the source code.  And you must show them these terms so they
359: 38: know their rights.
360: 39: 
361: 40:   Developers that use the GNU GPL protect your rights with two steps:
362: 41: (1) assert copyright on the software, and (2) offer you this License
363: 42: giving you legal permission to copy, distribute and/or modify it.
364: 43: 
365: 44:   For the developers' and authors' protection, the GPL clearly explains
366: 45: that there is no warranty for this free software.  For both users' and
367: 46: authors' sake, the GPL requires that modified versions be marked as
368: 47: changed, so that their problems will not be attributed erroneously to
369: 48: authors of previous versions.
370: 49: 
371: 50:   Some devices are designed to deny users access to install or run
372: 51: modified versions of the software inside them, although the manufacturer
373: 52: can do so.  This is fundamentally incompatible with the aim of
374: 53: protecting users' freedom to change the software.  The systematic
375: 54: pattern of such abuse occurs in the area of products for individuals to
376: 55: use, which is precisely where it is most unacceptable.  Therefore, we
377: 56: have designed this version of the GPL to prohibit the practice for those
378: 57: products.  If such problems arise substantially in other domains, we
379: 58: stand ready to extend this provision to those domains in future versions
380: 59: of the GPL, as needed to protect the freedom of users.
381: 60: 
382: 61:   Finally, every program is threatened constantly by software patents.
383: 62: States should not allow patents to restrict development and use of
384: 63: software on general-purpose computers, but in those that do, we wish to
385: 64: avoid the special danger that patents applied to a free program could
386: 65: make it effectively proprietary.  To prevent this, the GPL assures that
387: 66: patents cannot be used to render the program non-free.
388: 67: 
389: 68:   The precise terms and conditions for copying, distribution and
390: 69: modification follow.
391: 70: 
392: 71:                        TERMS AND CONDITIONS
393: 72: 
394: 73:   0. Definitions.
395: 74: 
396: 75:   "This License" refers to version 3 of the GNU General Public License.
397: 76: 
398: 77:   "Copyright" also means copyright-like laws that apply to other kinds of
399: 78: works, such as semiconductor masks.
400: 79: 
401: 80:   "The Program" refers to any copyrightable work licensed under this
402: 81: License.  Each licensee is addressed as "you".  "Licensees" and
403: 82: "recipients" may be individuals or organizations.
404: 83: 
405: 84:   To "modify" a work means to copy from or adapt all or part of the work
406: 85: in a fashion requiring copyright permission, other than the making of an
407: 86: exact copy.  The resulting work is called a "modified version" of the
408: 87: earlier work or a work "based on" the earlier work.
409: 88: 
410: 89:   A "covered work" means either the unmodified Program or a work based
411: 90: on the Program.
412: 91: 
413: 92:   To "propagate" a work means to do anything with it that, without
414: 93: permission, would make you directly or secondarily liable for
415: 94: infringement under applicable copyright law, except executing it on a
416: 95: computer or modifying a private copy.  Propagation includes copying,
417: 96: distribution (with or without modification), making available to the
418: 97: public, and in some countries other activities as well.
419: 98: 
420: 99:   To "convey" a work means any kind of propagation that enables other
421: 100: parties to make or receive copies.  Mere interaction with a user through
422: 101: a computer network, with no transfer of a copy, is not conveying.
423: 102: 
424: 103:   An interactive user interface displays "Appropriate Legal Notices"
425: 104: to the extent that it includes a convenient and prominently visible
426: 105: feature that (1) displays an appropriate copyright notice, and (2)
427: 106: tells the user that there is no warranty for the work (except to the
428: 107: extent that warranties are provided), that licensees may convey the
429: 108: work under this License, and how to view a copy of this License.  If
430: 109: the interface presents a list of user commands or options, such as a
431: 110: menu, a prominent item in the list meets this criterion.
432: 111: 
433: 112:   1. Source Code.
434: 113: 
435: 114:   The "source code" for a work means the preferred form of the work
436: 115: for making modifications to it.  "Object code" means any non-source
437: 116: form of a work.
438: 117: 
439: 118:   A "Standard Interface" means an interface that either is an official
440: 119: standard defined by a recognized standards body, or, in the case of
441: 120: interfaces specified for a particular programming language, one that
442: 121: is widely used among developers working in that language.
443: 122: 
444: 123:   The "System Libraries" of an executable work include anything, other
445: 124: than the work as a whole, that (a) is included in the normal form of
446: 125: packaging a Major Component, but which is not part of that Major
447: 126: Component, and (b) serves only to enable use of the work with that
448: 127: Major Component, or to implement a Standard Interface for which an
449: 128: implementation is available to the public in source code form.  A
450: 129: "Major Component", in this context, means a major essential component
451: 130: (kernel, window system, and so on) of the specific operating system
452: 131: (if any) on which the executable work runs, or a compiler used to
453: 132: produce the work, or an object code interpreter used to run it.
454: 133: 
455: 134:   The "Corresponding Source" for a work in object code form means all
456: 135: the source code needed to generate, install, and (for an executable
457: 136: work) run the object code and to modify the work, including scripts to
458: 137: control those activities.  However, it does not include the work's
459: 138: System Libraries, or general-purpose tools or generally available free
460: 139: programs which are used unmodified in performing those activities but
461: 140: which are not part of the work.  For example, Corresponding Source
462: 141: includes interface definition files associated with source files for
463: 142: the work, and the source code for shared libraries and dynamically
464: 143: linked subprograms that the work is specifically designed to require,
465: 144: such as by intimate data communication or control flow between those
466: 145: subprograms and other parts of the work.
467: 146: 
468: 147:   The Corresponding Source need not include anything that users
469: 148: can regenerate automatically from other parts of the Corresponding
470: 149: Source.
471: 150: 
472: 151:   The Corresponding Source for a work in source code form is that
473: 152: same work.
474: 153: 
475: 154:   2. Basic Permissions.
476: 155: 
477: 156:   All rights granted under this License are granted for the term of
478: 157: copyright on the Program, and are irrevocable provided the stated
479: 158: conditions are met.  This License explicitly affirms your unlimited
480: 159: permission to run the unmodified Program.  The output from running a
481: 160: covered work is covered by this License only if the output, given its
482: 161: content, constitutes a covered work.  This License acknowledges your
483: 162: rights of fair use or other equivalent, as provided by copyright law.
484: 163: 
485: 164:   You may make, run and propagate covered works that you do not
486: 165: convey, without conditions so long as your license otherwise remains
487: 166: in force.  You may convey covered works to others for the sole purpose
488: 167: of having them make modifications exclusively for you, or provide you
489: 168: with facilities for running those works, provided that you comply with
490: 169: the terms of this License in conveying all material for which you do
491: 170: not control copyright.  Those thus making or running the covered works
492: 171: for you must do so exclusively on your behalf, under your direction
493: 172: and control, on terms that prohibit them from making any copies of
494: 173: your copyrighted material outside their relationship with you.
495: 174: 
496: 175:   Conveying under any other circumstances is permitted solely under
497: 176: the conditions stated below.  Sublicensing is not allowed; section 10
498: 177: makes it unnecessary.
499: 178: 
500: 179:   3. Protecting Users' Legal Rights From Anti-Circumvention Law.
501: 180: 
502: 181:   No covered work shall be deemed part of an effective technological
503: 182: measure under any applicable law fulfilling obligations under article
504: 183: 11 of the WIPO copyright treaty adopted on 20 December 1996, or
505: 184: similar laws prohibiting or restricting circumvention of such
506: 185: measures.
507: 186: 
508: 187:   When you convey a covered work, you waive any legal power to forbid
509: 188: circumvention of technological measures to the extent such circumvention
510: 189: is effected by exercising rights under this License with respect to
511: 190: the covered work, and you disclaim any intention to limit operation or
512: 191: modification of the work as a means of enforcing, against the work's
513: 192: users, your or third parties' legal rights to forbid circumvention of
514: 193: technological measures.
515: 194: 
516: 195:   4. Conveying Verbatim Copies.
517: 196: 
518: 197:   You may convey verbatim copies of the Program's source code as you
519: 198: receive it, in any medium, provided that you conspicuously and
520: 199: appropriately publish on each copy an appropriate copyright notice;
521: 200: keep intact all notices stating that this License and any
522: 201: non-permissive terms added in accord with section 7 apply to the code;
523: 202: keep intact all notices of the absence of any warranty; and give all
524: 203: recipients a copy of this License along with the Program.
525: 204: 
526: 205:   You may charge any price or no price for each copy that you convey,
527: 206: and you may offer support or warranty protection for a fee.
528: 207: 
529: 208:   5. Conveying Modified Source Versions.
530: 209: 
531: 210:   You may convey a work based on the Program, or the modifications to
532: 211: produce it from the Program, in the form of source code under the
533: 212: terms of section 4, provided that you also meet all of these conditions:
534: 213: 
535: 214:     a) The work must carry prominent notices stating that you modified
536: 215:     it, and giving a relevant date.
537: 216: 
538: 217:     b) The work must carry prominent notices stating that it is
539: 218:     released under this License and any conditions added under section
540: 219:     7.  This requirement modifies the requirement in section 4 to
541: 220:     "keep intact all notices".
542: 221: 
543: 222:     c) You must license the entire work, as a whole, under this
544: 223:     License to anyone who comes into possession of a copy.  This
545: 224:     License will therefore apply, along with any applicable section 7
546: 225:     additional terms, to the whole of the work, and all its parts,
547: 226:     regardless of how they are packaged.  This License gives no
548: 227:     permission to license the work in any other way, but it does not
549: 228:     invalidate such permission if you have separately received it.
550: 229: 
551: 230:     d) If the work has interactive user interfaces, each must display
552: 231:     Appropriate Legal Notices; however, if the Program has interactive
553: 232:     interfaces that do not display Appropriate Legal Notices, your
554: 233:     work need not make them do so.
555: 234: 
556: 235:   A compilation of a covered work with other separate and independent
557: 236: works, which are not by their nature extensions of the covered work,
558: 237: and which are not combined with it such as to form a larger program,
559: 238: in or on a volume of a storage or distribution medium, is called an
560: 239: "aggregate" if the compilation and its resulting copyright are not
561: 240: used to limit the access or legal rights of the compilation's users
562: 241: beyond what the individual works permit.  Inclusion of a covered work
563: 242: in an aggregate does not cause this License to apply to the other
564: 243: parts of the aggregate.
565: 244: 
566: 245:   6. Conveying Non-Source Forms.
567: 246: 
568: 247:   You may convey a covered work in object code form under the terms
569: 248: of sections 4 and 5, provided that you also convey the
570: 249: machine-readable Corresponding Source under the terms of this License,
571: 250: in one of these ways:
572: 251: 
573: 252:     a) Convey the object code in, or embodied in, a physical product
574: 253:     (including a physical distribution medium), accompanied by the
575: 254:     Corresponding Source fixed on a durable physical medium
576: 255:     customarily used for software interchange.
577: 256: 
578: 257:     b) Convey the object code in, or embodied in, a physical product
579: 258:     (including a physical distribution medium), accompanied by a
580: 259:     written offer, valid for at least three years and valid for as
581: 260:     long as you offer spare parts or customer support for that product
582: 261:     model, to give anyone who possesses the object code either (1) a
583: 262:     copy of the Corresponding Source for all the software in the
584: 263:     product that is covered by this License, on a durable physical
585: 264:     medium customarily used for software interchange, for a price no
586: 265:     more than your reasonable cost of physically performing this
587: 266:     conveying of source, or (2) access to copy the
588: 267:     Corresponding Source from a network server at no charge.
589: 268: 
590: 269:     c) Convey individual copies of the object code with a copy of the
591: 270:     written offer to provide the Corresponding Source.  This
592: 271:     alternative is allowed only occasionally and noncommercially, and
593: 272:     only if you received the object code with such an offer, in accord
594: 273:     with subsection 6b.
595: 274: 
596: 275:     d) Convey the object code by offering access from a designated
597: 276:     place (gratis or for a charge), and offer equivalent access to the
598: 277:     Corresponding Source in the same way through the same place at no
599: 278:     further charge.  You need not require recipients to copy the
600: 279:     Corresponding Source along with the object code.  If the place to
601: 280:     copy the object code is a network server, the Corresponding Source
602: 281:     may be on a different server (operated by you or a third party)
603: 282:     that supports equivalent copying facilities, provided you maintain
604: 283:     clear directions next to the object code saying where to find the
605: 284:     Corresponding Source.  Regardless of what server hosts the
606: 285:     Corresponding Source, you remain obligated to ensure that it is
607: 286:     available for as long as needed to satisfy these requirements.
608: 287: 
609: 288:     e) Convey the object code using peer-to-peer transmission, provided
610: 289:     you inform other peers where the object code and Corresponding
611: 290:     Source of the work are being offered to the general public at no
612: 291:     charge under subsection 6d.
613: 292: 
614: 293:   A separable portion of the object code, whose source code is excluded
615: 294: from the Corresponding Source as a System Library, need not be
616: 295: included in conveying the object code work.
617: 296: 
618: 297:   A "User Product" is either (1) a "consumer product", which means any
619: 298: tangible personal property which is normally used for personal, family,
620: 299: or household purposes, or (2) anything designed or sold for incorporation
621: 300: into a dwelling.  In determining whether a product is a consumer product,
622: 301: doubtful cases shall be resolved in favor of coverage.  For a particular
623: 302: product received by a particular user, "normally used" refers to a
624: 303: typical or common use of that class of product, regardless of the status
625: 304: of the particular user or of the way in which the particular user
626: 305: actually uses, or expects or is expected to use, the product.  A product
627: 306: is a consumer product regardless of whether the product has substantial
628: 307: commercial, industrial or non-consumer uses, unless such uses represent
629: 308: the only significant mode of use of the product.
630: 309: 
631: 310:   "Installation Information" for a User Product means any methods,
632: 311: procedures, authorization keys, or other information required to install
633: 312: and execute modified versions of a covered work in that User Product from
634: 313: a modified version of its Corresponding Source.  The information must
635: 314: suffice to ensure that the continued functioning of the modified object
636: 315: code is in no case prevented or interfered with solely because
637: 316: modification has been made.
638: 317: 
639: 318:   If you convey an object code work under this section in, or with, or
640: 319: specifically for use in, a User Product, and the conveying occurs as
641: 320: part of a transaction in which the right of possession and use of the
642: 321: User Product is transferred to the recipient in perpetuity or for a
643: 322: fixed term (regardless of how the transaction is characterized), the
644: 323: Corresponding Source conveyed under this section must be accompanied
645: 324: by the Installation Information.  But this requirement does not apply
646: 325: if neither you nor any third party retains the ability to install
647: 326: modified object code on the User Product (for example, the work has
648: 327: been installed in ROM).
649: 328: 
650: 329:   The requirement to provide Installation Information does not include a
651: 330: requirement to continue to provide support service, warranty, or updates
652: 331: for a work that has been modified or installed by the recipient, or for
653: 332: the User Product in which it has been modified or installed.  Access to a
654: 333: network may be denied when the modification itself materially and
655: 334: adversely affects the operation of the network or violates the rules and
656: 335: protocols for communication across the network.
657: 336: 
658: 337:   Corresponding Source conveyed, and Installation Information provided,
659: 338: in accord with this section must be in a format that is publicly
660: 339: documented (and with an implementation available to the public in
661: 340: source code form), and must require no special password or key for
662: 341: unpacking, reading or copying.
663: 342: 
664: 343:   7. Additional Terms.
665: 344: 
666: 345:   "Additional permissions" are terms that supplement the terms of this
667: 346: License by making exceptions from one or more of its conditions.
668: 347: Additional permissions that are applicable to the entire Program shall
669: 348: be treated as though they were included in this License, to the extent
670: 349: that they are valid under applicable law.  If additional permissions
671: 350: apply only to part of the Program, that part may be used separately
672: 351: under those permissions, but the entire Program remains governed by
673: 352: this License without regard to the additional permissions.
674: 353: 
675: 354:   When you convey a copy of a covered work, you may at your option
676: 355: remove any additional permissions from that copy, or from any part of
677: 356: it.  (Additional permissions may be written to require their own
678: 357: removal in certain cases when you modify the work.)  You may place
679: 358: additional permissions on material, added by you to a covered work,
680: 359: for which you have or can give appropriate copyright permission.
681: 360: 
682: 361:   Notwithstanding any other provision of this License, for material you
683: 362: add to a covered work, you may (if authorized by the copyright holders of
684: 363: that material) supplement the terms of this License with terms:
685: 364: 
686: 365:     a) Disclaiming warranty or limiting liability differently from the
687: 366:     terms of sections 15 and 16 of this License; or
688: 367: 
689: 368:     b) Requiring preservation of specified reasonable legal notices or
690: 369:     author attributions in that material or in the Appropriate Legal
691: 370:     Notices displayed by works containing it; or
692: 371: 
693: 372:     c) Prohibiting misrepresentation of the origin of that material, or
694: 373:     requiring that modified versions of such material be marked in
695: 374:     reasonable ways as different from the original version; or
696: 375: 
697: 376:     d) Limiting the use for publicity purposes of names of licensors or
698: 377:     authors of the material; or
699: 378: 
700: 379:     e) Declining to grant rights under trademark law for use of some
701: 380:     trade names, trademarks, or service marks; or
702: 381: 
703: 382:     f) Requiring indemnification of licensors and authors of that
704: 383:     material by anyone who conveys the material (or modified versions of
705: 384:     it) with contractual assumptions of liability to the recipient, for
706: 385:     any liability that these contractual assumptions directly impose on
707: 386:     those licensors and authors.
708: 387: 
709: 388:   All other non-permissive additional terms are considered "further
710: 389: restrictions" within the meaning of section 10.  If the Program as you
711: 390: received it, or any part of it, contains a notice stating that it is
712: 391: governed by this License along with a term that is a further
713: 392: restriction, you may remove that term.  If a license document contains
714: 393: a further restriction but permits relicensing or conveying under this
715: 394: License, you may add to a covered work material governed by the terms
716: 395: of that license document, provided that the further restriction does
717: 396: not survive such relicensing or conveying.
718: 397: 
719: 398:   If you add terms to a covered work in accord with this section, you
720: 399: must place, in the relevant source files, a statement of the
721: 400: additional terms that apply to those files, or a notice indicating
722: 401: where to find the applicable terms.
723: 402: 
724: 403:   Additional terms, permissive or non-permissive, may be stated in the
725: 404: form of a separately written license, or stated as exceptions;
726: 405: the above requirements apply either way.
727: 406: 
728: 407:   8. Termination.
729: 408: 
730: 409:   You may not propagate or modify a covered work except as expressly
731: 410: provided under this License.  Any attempt otherwise to propagate or
732: 411: modify it is void, and will automatically terminate your rights under
733: 412: this License (including any patent licenses granted under the third
734: 413: paragraph of section 11).
735: 414: 
736: 415:   However, if you cease all violation of this License, then your
737: 416: license from a particular copyright holder is reinstated (a)
738: 417: provisionally, unless and until the copyright holder explicitly and
739: 418: finally terminates your license, and (b) permanently, if the copyright
740: 419: holder fails to notify you of the violation by some reasonable means
741: 420: prior to 60 days after the cessation.
742: 421: 
743: 422:   Moreover, your license from a particular copyright holder is
744: 423: reinstated permanently if the copyright holder notifies you of the
745: 424: violation by some reasonable means, this is the first time you have
746: 425: received notice of violation of this License (for any work) from that
747: 426: copyright holder, and you cure the violation prior to 30 days after
748: 427: your receipt of the notice.
749: 428: 
750: 429:   Termination of your rights under this section does not terminate the
751: 430: licenses of parties who have received copies or rights from you under
752: 431: this License.  If your rights have been terminated and not permanently
753: 432: reinstated, you do not qualify to receive new licenses for the same
754: 433: material under section 10.
755: 434: 
756: 435:   9. Acceptance Not Required for Having Copies.
757: 436: 
758: 437:   You are not required to accept this License in order to receive or
759: 438: run a copy of the Program.  Ancillary propagation of a covered work
760: 439: occurring solely as a consequence of using peer-to-peer transmission
761: 440: to receive a copy likewise does not require acceptance.  However,
762: 441: nothing other than this License grants you permission to propagate or
763: 442: modify any covered work.  These actions infringe copyright if you do
764: 443: not accept this License.  Therefore, by modifying or propagating a
765: 444: covered work, you indicate your acceptance of this License to do so.
766: 445: 
767: 446:   10. Automatic Licensing of Downstream Recipients.
768: 447: 
769: 448:   Each time you convey a covered work, the recipient automatically
770: 449: receives a license from the original licensors, to run, modify and
771: 450: propagate that work, subject to this License.  You are not responsible
772: 451: for enforcing compliance by third parties with this License.
773: 452: 
774: 453:   An "entity transaction" is a transaction transferring control of an
775: 454: organization, or substantially all assets of one, or subdividing an
776: 455: organization, or merging organizations.  If propagation of a covered
777: 456: work results from an entity transaction, each party to that
778: 457: transaction who receives a copy of the work also receives whatever
779: 458: licenses to the work the party's predecessor in interest had or could
780: 459: give under the previous paragraph, plus a right to possession of the
781: 460: Corresponding Source of the work from the predecessor in interest, if
782: 461: the predecessor has it or can get it with reasonable efforts.
783: 462: 
784: 463:   You may not impose any further restrictions on the exercise of the
785: 464: rights granted or affirmed under this License.  For example, you may
786: 465: not impose a license fee, royalty, or other charge for exercise of
787: 466: rights granted under this License, and you may not initiate litigation
788: 467: (including a cross-claim or counterclaim in a lawsuit) alleging that
789: 468: any patent claim is infringed by making, using, selling, offering for
790: 469: sale, or importing the Program or any portion of it.
791: 470: 
792: 471:   11. Patents.
793: 472: 
794: 473:   A "contributor" is a copyright holder who authorizes use under this
795: 474: License of the Program or a work on which the Program is based.  The
796: 475: work thus licensed is called the contributor's "contributor version".
797: 476: 
798: 477:   A contributor's "essential patent claims" are all patent claims
799: 478: owned or controlled by the contributor, whether already acquired or
800: 479: hereafter acquired, that would be infringed by some manner, permitted
801: 480: by this License, of making, using, or selling its contributor version,
802: 481: but do not include claims that would be infringed only as a
803: 482: consequence of further modification of the contributor version.  For
804: 483: purposes of this definition, "control" includes the right to grant
805: 484: patent sublicenses in a manner consistent with the requirements of
806: 485: this License.
807: 486: 
808: 487:   Each contributor grants you a non-exclusive, worldwide, royalty-free
809: 488: patent license under the contributor's essential patent claims, to
810: 489: make, use, sell, offer for sale, import and otherwise run, modify and
811: 490: propagate the contents of its contributor version.
812: 491: 
813: 492:   In the following three paragraphs, a "patent license" is any express
814: 493: agreement or commitment, however denominated, not to enforce a patent
815: 494: (such as an express permission to practice a patent or covenant not to
816: 495: sue for patent infringement).  To "grant" such a patent license to a
817: 496: party means to make such an agreement or commitment not to enforce a
818: 497: patent against the party.
819: 498: 
820: 499:   If you convey a covered work, knowingly relying on a patent license,
821: 500: and the Corresponding Source of the work is not available for anyone
822: 501: to copy, free of charge and under the terms of this License, through a
823: 502: publicly available network server or other readily accessible means,
824: 503: then you must either (1) cause the Corresponding Source to be so
825: 504: available, or (2) arrange to deprive yourself of the benefit of the
826: 505: patent license for this particular work, or (3) arrange, in a manner
827: 506: consistent with the requirements of this License, to extend the patent
828: 507: license to downstream recipients.  "Knowingly relying" means you have
829: 508: actual knowledge that, but for the patent license, your conveying the
830: 509: covered work in a country, or your recipient's use of the covered work
831: 510: in a country, would infringe one or more identifiable patents in that
832: 511: country that you have reason to believe are valid.
833: 512: 
834: 513:   If, pursuant to or in connection with a single transaction or
835: 514: arrangement, you convey, or propagate by procuring conveyance of, a
836: 515: covered work, and grant a patent license to some of the parties
837: 516: receiving the covered work authorizing them to use, propagate, modify
838: 517: or convey a specific copy of the covered work, then the patent license
839: 518: you grant is automatically extended to all recipients of the covered
840: 519: work and works based on it.
841: 520: 
842: 521:   A patent license is "discriminatory" if it does not include within
843: 522: the scope of its coverage, prohibits the exercise of, or is
844: 523: conditioned on the non-exercise of one or more of the rights that are
845: 524: specifically granted under this License.  You may not convey a covered
846: 525: work if you are a party to an arrangement with a third party that is
847: 526: in the business of distributing software, under which you make payment
848: 527: to the third party based on the extent of your activity of conveying
849: 528: the work, and under which the third party grants, to any of the
850: 529: parties who would receive the covered work from you, a discriminatory
851: 530: patent license (a) in connection with copies of the covered work
852: 531: conveyed by you (or copies made from those copies), or (b) primarily
853: 532: for and in connection with specific products or compilations that
854: 533: contain the covered work, unless you entered into that arrangement,
855: 534: or that patent license was granted, prior to 28 March 2007.
856: 535: 
857: 536:   Nothing in this License shall be construed as excluding or limiting
858: 537: any implied license or other defenses to infringement that may
859: 538: otherwise be available to you under applicable patent law.
860: 539: 
861: 540:   12. No Surrender of Others' Freedom.
862: 541: 
863: 542:   If conditions are imposed on you (whether by court order, agreement or
864: 543: otherwise) that contradict the conditions of this License, they do not
865: 544: excuse you from the conditions of this License.  If you cannot convey a
866: 545: covered work so as to satisfy simultaneously your obligations under this
867: 546: License and any other pertinent obligations, then as a consequence you may
868: 547: not convey it at all.  For example, if you agree to terms that obligate you
869: 548: to collect a royalty for further conveying from those to whom you convey
870: 549: the Program, the only way you could satisfy both those terms and this
871: 550: License would be to refrain entirely from conveying the Program.
872: 551: 
873: 552:   13. Use with the GNU Affero General Public License.
874: 553: 
875: 554:   Notwithstanding any other provision of this License, you have
876: 555: permission to link or combine any covered work with a work licensed
877: 556: under version 3 of the GNU Affero General Public License into a single
878: 557: combined work, and to convey the resulting work.  The terms of this
879: 558: License will continue to apply to the part which is the covered work,
880: 559: but the special requirements of the GNU Affero General Public License,
881: 560: section 13, concerning interaction through a network will apply to the
882: 561: combination as such.
883: 562: 
884: 563:   14. Revised Versions of this License.
885: 564: 
886: 565:   The Free Software Foundation may publish revised and/or new versions of
887: 566: the GNU General Public License from time to time.  Such new versions will
888: 567: be similar in spirit to the present version, but may differ in detail to
889: 568: address new problems or concerns.
890: 569: 
891: 570:   Each version is given a distinguishing version number.  If the
892: 571: Program specifies that a certain numbered version of the GNU General
893: 572: Public License "or any later version" applies to it, you have the
894: 573: option of following the terms and conditions either of that numbered
895: 574: version or of any later version published by the Free Software
896: 575: Foundation.  If the Program does not specify a version number of the
897: 576: GNU General Public License, you may choose any version ever published
898: 577: by the Free Software Foundation.
899: 578: 
900: 579:   If the Program specifies that a proxy can decide which future
901: 580: versions of the GNU General Public License can be used, that proxy's
902: 581: public statement of acceptance of a version permanently authorizes you
903: 582: to choose that version for the Program.
904: 583: 
905: 584:   Later license versions may give you additional or different
906: 585: permissions.  However, no additional obligations are imposed on any
907: 586: author or copyright holder as a result of your choosing to follow a
908: 587: later version.
909: 588: 
910: 589:   15. Disclaimer of Warranty.
911: 590: 
912: 591:   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
913: 592: APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
914: 593: HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
915: 594: OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
916: 595: THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
917: 596: PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
918: 597: IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
919: 598: ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
920: 599: 
921: 600:   16. Limitation of Liability.
922: 601: 
923: 602:   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
924: 603: WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
925: 604: THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
926: 605: GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
927: 606: USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
928: 607: DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
929: 608: PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
930: 609: EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
931: 610: SUCH DAMAGES.
932: 611: 
933: 612:   17. Interpretation of Sections 15 and 16.
934: 613: 
935: 614:   If the disclaimer of warranty and limitation of liability provided
936: 615: above cannot be given local legal effect according to their terms,
937: 616: reviewing courts shall apply local law that most closely approximates
938: 617: an absolute waiver of all civil liability in connection with the
939: 618: Program, unless a warranty or assumption of liability accompanies a
940: 619: copy of the Program in return for a fee.
941: 620: 
942: 621:                      END OF TERMS AND CONDITIONS
943: 622: 
944: 623:             How to Apply These Terms to Your New Programs
945: 624: 
946: 625:   If you develop a new program, and you want it to be of the greatest
947: 626: possible use to the public, the best way to achieve this is to make it
948: 627: free software which everyone can redistribute and change under these terms.
949: 628: 
950: 629:   To do so, attach the following notices to the program.  It is safest
951: 630: to attach them to the start of each source file to most effectively
952: 631: state the exclusion of warranty; and each file should have at least
953: 632: the "copyright" line and a pointer to where the full notice is found.
954: 633: 
955: 634:     <one line to give the program's name and a brief idea of what it does.>
956: 635:     Copyright (C) <year>  <name of author>
957: 636: 
958: 637:     This program is free software: you can redistribute it and/or modify
959: 638:     it under the terms of the GNU General Public License as published by
960: 639:     the Free Software Foundation, either version 3 of the License, or
961: 640:     (at your option) any later version.
962: 641: 
963: 642:     This program is distributed in the hope that it will be useful,
964: 643:     but WITHOUT ANY WARRANTY; without even the implied warranty of
965: 644:     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
966: 645:     GNU General Public License for more details.
967: 646: 
968: 647:     You should have received a copy of the GNU General Public License
969: 648:     along with this program.  If not, see <https://www.gnu.org/licenses/>.
970: 649: 
971: 650: Also add information on how to contact you by electronic and paper mail.
972: 651: 
973: 652:   If the program does terminal interaction, make it output a short
974: 653: notice like this when it starts in an interactive mode:
975: 654: 
976: 655:     <program>  Copyright (C) <year>  <name of author>
977: 656:     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
978: 657:     This is free software, and you are welcome to redistribute it
979: 658:     under certain conditions; type `show c' for details.
980: 659: 
981: 660: The hypothetical commands `show w' and `show c' should show the appropriate
982: 661: parts of the General Public License.  Of course, your program's commands
983: 662: might be different; for a GUI interface, you would use an "about box".
984: 663: 
985: 664:   You should also get your employer (if you work as a programmer) or school,
986: 665: if any, to sign a "copyright disclaimer" for the program, if necessary.
987: 666: For more information on this, and how to apply and follow the GNU GPL, see
988: 667: <https://www.gnu.org/licenses/>.
989: 668: 
990: 669:   The GNU General Public License does not permit incorporating your program
991: 670: into proprietary programs.  If your program is a subroutine library, you
992: 671: may consider it more useful to permit linking proprietary applications with
993: 672: the library.  If this is what you want to do, use the GNU Lesser General
994: 673: Public License instead of this License.  But first, please read
995: 674: <https://www.gnu.org/licenses/why-not-lgpl.html>.
996: 
997: 
998: ./main.go
999: 1: package main
1000: 2: 
1001: 3: import (
1002: 4: 	"flag"
1003: 5: 	"fmt"
1004: 6: 	"os"
1005: 7: 	"os/signal"
1006: 8: 	"path/filepath"
1007: 9: 	"runtime"
1008: 10: 	"syscall"
1009: 11: 	_ "time/tzdata"
1010: 12: 
1011: 13: 	"github.com/Dreamacro/clash/config"
1012: 14: 	C "github.com/Dreamacro/clash/constant"
1013: 15: 	"github.com/Dreamacro/clash/hub"
1014: 16: 	"github.com/Dreamacro/clash/hub/executor"
1015: 17: 	"github.com/Dreamacro/clash/log"
1016: 18: 
1017: 19: 	"go.uber.org/automaxprocs/maxprocs"
1018: 20: )
1019: 21: 
1020: 22: var (
1021: 23: 	version            bool
1022: 24: 	testConfig         bool
1023: 25: 	homeDir            string
1024: 26: 	configFile         string
1025: 27: 	externalUI         string
1026: 28: 	externalController string
1027: 29: 	secret             string
1028: 30: )
1029: 31: 
1030: 32: func init() {
1031: 33: 	flag.StringVar(&homeDir, "d", os.Getenv("CLASH_HOME_DIR"), "set configuration directory")
1032: 34: 	flag.StringVar(&configFile, "f", os.Getenv("CLASH_CONFIG_FILE"), "specify configuration file")
1033: 35: 	flag.StringVar(&externalUI, "ext-ui", os.Getenv("CLASH_OVERRIDE_EXTERNAL_UI_DIR"), "override external ui directory")
1034: 36: 	flag.StringVar(&externalController, "ext-ctl", os.Getenv("CLASH_OVERRIDE_EXTERNAL_CONTROLLER"), "override external controller address")
1035: 37: 	flag.StringVar(&secret, "secret", os.Getenv("CLASH_OVERRIDE_SECRET"), "override secret for RESTful API")
1036: 38: 	flag.BoolVar(&version, "v", false, "show current version of clash")
1037: 39: 	flag.BoolVar(&testConfig, "t", false, "test configuration and exit")
1038: 40: 	flag.Parse()
1039: 41: }
1040: 42: 
1041: 43: func main() {
1042: 44: 	maxprocs.Set(maxprocs.Logger(func(string, ...any) {}))
1043: 45: 	if version {
1044: 46: 		fmt.Printf("Clash %s %s %s with %s %s\n", C.Version, runtime.GOOS, runtime.GOARCH, runtime.Version(), C.BuildTime)
1045: 47: 		return
1046: 48: 	}
1047: 49: 
1048: 50: 	if homeDir != "" {
1049: 51: 		if !filepath.IsAbs(homeDir) {
1050: 52: 			currentDir, _ := os.Getwd()
1051: 53: 			homeDir = filepath.Join(currentDir, homeDir)
1052: 54: 		}
1053: 55: 		C.SetHomeDir(homeDir)
1054: 56: 	}
1055: 57: 
1056: 58: 	if configFile != "" {
1057: 59: 		if !filepath.IsAbs(configFile) {
1058: 60: 			currentDir, _ := os.Getwd()
1059: 61: 			configFile = filepath.Join(currentDir, configFile)
1060: 62: 		}
1061: 63: 		C.SetConfig(configFile)
1062: 64: 	} else {
1063: 65: 		configFile := filepath.Join(C.Path.HomeDir(), C.Path.Config())
1064: 66: 		C.SetConfig(configFile)
1065: 67: 	}
1066: 68: 
1067: 69: 	if err := config.Init(C.Path.HomeDir()); err != nil {
1068: 70: 		log.Fatalln("Initial configuration directory error: %s", err.Error())
1069: 71: 	}
1070: 72: 
1071: 73: 	if testConfig {
1072: 74: 		if _, err := executor.Parse(); err != nil {
1073: 75: 			log.Errorln(err.Error())
1074: 76: 			fmt.Printf("configuration file %s test failed\n", C.Path.Config())
1075: 77: 			os.Exit(1)
1076: 78: 		}
1077: 79: 		fmt.Printf("configuration file %s test is successful\n", C.Path.Config())
1078: 80: 		return
1079: 81: 	}
1080: 82: 
1081: 83: 	var options []hub.Option
1082: 84: 	if externalUI != "" {
1083: 85: 		options = append(options, hub.WithExternalUI(externalUI))
1084: 86: 	}
1085: 87: 	if externalController != "" {
1086: 88: 		options = append(options, hub.WithExternalController(externalController))
1087: 89: 	}
1088: 90: 	if secret != "" {
1089: 91: 		options = append(options, hub.WithSecret(secret))
1090: 92: 	}
1091: 93: 
1092: 94: 	if err := hub.Parse(options...); err != nil {
1093: 95: 		log.Fatalln("Parse config error: %s", err.Error())
1094: 96: 	}
1095: 97: 
1096: 98: 	termSign := make(chan os.Signal, 1)
1097: 99: 	hupSign := make(chan os.Signal, 1)
1098: 100: 	signal.Notify(termSign, syscall.SIGINT, syscall.SIGTERM)
1099: 101: 	signal.Notify(hupSign, syscall.SIGHUP)
1100: 102: 	for {
1101: 103: 		select {
1102: 104: 		case <-termSign:
1103: 105: 			return
1104: 106: 		case <-hupSign:
1105: 107: 			if cfg, err := executor.ParseWithPath(C.Path.Config()); err == nil {
1106: 108: 				executor.ApplyConfig(cfg, true)
1107: 109: 			} else {
1108: 110: 				log.Errorln("Parse config error: %s", err.Error())
1109: 111: 			}
1110: 112: 		}
1111: 113: 	}
1112: 114: }
1113: 
1114: 
1115: ./Makefile
1116: 1: NAME=clash
1117: 2: BINDIR=bin
1118: 3: VERSION=$(shell git describe --tags || echo "unknown version")
1119: 4: BUILDTIME=$(shell date -u)
1120: 5: GOBUILD=CGO_ENABLED=0 go build -trimpath -ldflags '-X "github.com/Dreamacro/clash/constant.Version=$(VERSION)" \
1121: 6: 		-X "github.com/Dreamacro/clash/constant.BuildTime=$(BUILDTIME)" \
1122: 7: 		-w -s -buildid='
1123: 8: 
1124: 9: PLATFORM_LIST = \
1125: 10: 	darwin-amd64 \
1126: 11: 	darwin-amd64-v3 \
1127: 12: 	darwin-arm64 \
1128: 13: 	linux-386 \
1129: 14: 	linux-amd64 \
1130: 15: 	linux-amd64-v3 \
1131: 16: 	linux-armv5 \
1132: 17: 	linux-armv6 \
1133: 18: 	linux-armv7 \
1134: 19: 	linux-arm64 \
1135: 20: 	linux-mips-softfloat \
1136: 21: 	linux-mips-hardfloat \
1137: 22: 	linux-mipsle-softfloat \
1138: 23: 	linux-mipsle-hardfloat \
1139: 24: 	linux-mips64 \
1140: 25: 	linux-mips64le \
1141: 26: 	linux-riscv64 \
1142: 27: 	linux-loong64 \
1143: 28: 	freebsd-386 \
1144: 29: 	freebsd-amd64 \
1145: 30: 	freebsd-amd64-v3 \
1146: 31: 	freebsd-arm64
1147: 32: 
1148: 33: WINDOWS_ARCH_LIST = \
1149: 34: 	windows-386 \
1150: 35: 	windows-amd64 \
1151: 36: 	windows-amd64-v3 \
1152: 37: 	windows-arm64 \
1153: 38: 	windows-armv7
1154: 39: 
1155: 40: all: linux-amd64 darwin-amd64 windows-amd64 # Most used
1156: 41: 
1157: 42: darwin-amd64:
1158: 43: 	GOARCH=amd64 GOOS=darwin $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1159: 44: 
1160: 45: darwin-amd64-v3:
1161: 46: 	GOARCH=amd64 GOOS=darwin GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1162: 47: 
1163: 48: darwin-arm64:
1164: 49: 	GOARCH=arm64 GOOS=darwin $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1165: 50: 
1166: 51: linux-386:
1167: 52: 	GOARCH=386 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1168: 53: 
1169: 54: linux-amd64:
1170: 55: 	GOARCH=amd64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1171: 56: 
1172: 57: linux-amd64-v3:
1173: 58: 	GOARCH=amd64 GOOS=linux GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1174: 59: 
1175: 60: linux-armv5:
1176: 61: 	GOARCH=arm GOOS=linux GOARM=5 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1177: 62: 
1178: 63: linux-armv6:
1179: 64: 	GOARCH=arm GOOS=linux GOARM=6 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1180: 65: 
1181: 66: linux-armv7:
1182: 67: 	GOARCH=arm GOOS=linux GOARM=7 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1183: 68: 
1184: 69: linux-arm64:
1185: 70: 	GOARCH=arm64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1186: 71: 
1187: 72: linux-mips-softfloat:
1188: 73: 	GOARCH=mips GOMIPS=softfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1189: 74: 
1190: 75: linux-mips-hardfloat:
1191: 76: 	GOARCH=mips GOMIPS=hardfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1192: 77: 
1193: 78: linux-mipsle-softfloat:
1194: 79: 	GOARCH=mipsle GOMIPS=softfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1195: 80: 
1196: 81: linux-mipsle-hardfloat:
1197: 82: 	GOARCH=mipsle GOMIPS=hardfloat GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1198: 83: 
1199: 84: linux-mips64:
1200: 85: 	GOARCH=mips64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1201: 86: 
1202: 87: linux-mips64le:
1203: 88: 	GOARCH=mips64le GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1204: 89: 
1205: 90: linux-riscv64:
1206: 91: 	GOARCH=riscv64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1207: 92: 
1208: 93: linux-loong64:
1209: 94: 	GOARCH=loong64 GOOS=linux $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1210: 95: 
1211: 96: freebsd-386:
1212: 97: 	GOARCH=386 GOOS=freebsd $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1213: 98: 
1214: 99: freebsd-amd64:
1215: 100: 	GOARCH=amd64 GOOS=freebsd $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1216: 101: 
1217: 102: freebsd-amd64-v3:
1218: 103: 	GOARCH=amd64 GOOS=freebsd GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1219: 104: 
1220: 105: freebsd-arm64:
1221: 106: 	GOARCH=arm64 GOOS=freebsd $(GOBUILD) -o $(BINDIR)/$(NAME)-$@
1222: 107: 
1223: 108: windows-386:
1224: 109: 	GOARCH=386 GOOS=windows $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
1225: 110: 
1226: 111: windows-amd64:
1227: 112: 	GOARCH=amd64 GOOS=windows $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
1228: 113: 
1229: 114: windows-amd64-v3:
1230: 115: 	GOARCH=amd64 GOOS=windows GOAMD64=v3 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
1231: 116: 
1232: 117: windows-arm64:
1233: 118: 	GOARCH=arm64 GOOS=windows $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
1234: 119: 
1235: 120: windows-armv7:
1236: 121: 	GOARCH=arm GOOS=windows GOARM=7 $(GOBUILD) -o $(BINDIR)/$(NAME)-$@.exe
1237: 122: 
1238: 123: gz_releases=$(addsuffix .gz, $(PLATFORM_LIST))
1239: 124: zip_releases=$(addsuffix .zip, $(WINDOWS_ARCH_LIST))
1240: 125: 
1241: 126: $(gz_releases): %.gz : %
1242: 127: 	chmod +x $(BINDIR)/$(NAME)-$(basename $@)
1243: 128: 	gzip -f -S -$(VERSION).gz $(BINDIR)/$(NAME)-$(basename $@)
1244: 129: 
1245: 130: $(zip_releases): %.zip : %
1246: 131: 	zip -m -j $(BINDIR)/$(NAME)-$(basename $@)-$(VERSION).zip $(BINDIR)/$(NAME)-$(basename $@).exe
1247: 132: 
1248: 133: all-arch: $(PLATFORM_LIST) $(WINDOWS_ARCH_LIST)
1249: 134: 
1250: 135: releases: $(gz_releases) $(zip_releases)
1251: 136: 
1252: 137: LINT_OS_LIST := darwin windows linux freebsd openbsd
1253: 138: 
1254: 139: lint: $(foreach os,$(LINT_OS_LIST),$(os)-lint)
1255: 140: %-lint:
1256: 141: 	GOOS=$* golangci-lint run ./...
1257: 142: 
1258: 143: lint-fix: $(foreach os,$(LINT_OS_LIST),$(os)-lint-fix)
1259: 144: %-lint-fix:
1260: 145: 	GOOS=$* golangci-lint run --fix ./...
1261: 146: 
1262: 147: clean:
1263: 148: 	rm $(BINDIR)/*
1264: 
1265: 


./README.md
1: <h1 align="center">
2:   <img src="https://github.com/Dreamacro/clash/raw/master/docs/logo.png" alt="Clash" width="200">
3:   <br>Clash<br>
4: </h1>
5: 
6: <h4 align="center">A rule-based tunnel in Go.</h4>
7: 
8: <p align="center">
9:   <a href="https://github.com/Dreamacro/clash/actions">
10:     <img src="https://img.shields.io/github/actions/workflow/status/Dreamacro/clash/release.yml?branch=master&style=flat-square" alt="Github Actions">
11:   </a>
12:   <a href="https://goreportcard.com/report/github.com/Dreamacro/clash">
13:     <img src="https://goreportcard.com/badge/github.com/Dreamacro/clash?style=flat-square">
14:   </a>
15:   <img src="https://img.shields.io/github/go-mod/go-version/Dreamacro/clash?style=flat-square">
16:   <a href="https://github.com/Dreamacro/clash/releases">
17:     <img src="https://img.shields.io/github/release/Dreamacro/clash/all.svg?style=flat-square">
18:   </a>
19:   <a href="https://github.com/Dreamacro/clash/releases/tag/premium">
20:     <img src="https://img.shields.io/badge/release-Premium-00b4f0?style=flat-square">
21:   </a>
22: </p>
23: 
24: ## Features
25: 
26: This is a general overview of the features that comes with Clash.  
27: 
28: - Inbound: HTTP, HTTPS, SOCKS5 server, TUN device
29: - Outbound: Shadowsocks(R), VMess, Trojan, Snell, SOCKS5, HTTP(S), Wireguard
30: - Rule-based Routing: dynamic scripting, domain, IP addresses, process name and more
31: - Fake-IP DNS: minimises impact on DNS pollution and improves network performance
32: - Transparent Proxy: Redirect TCP and TProxy TCP/UDP with automatic route table/rule management
33: - Proxy Groups: automatic fallback, load balancing or latency testing
34: - Remote Providers: load remote proxy lists dynamically
35: - RESTful API: update configuration in-place via a comprehensive API
36: 
37: *Some of the features may only be available in the [Premium core](https://dreamacro.github.io/clash/premium/introduction.html).*
38: 
39: ## Documentation
40: 
41: You can find the latest documentation at [https://dreamacro.github.io/clash/](https://dreamacro.github.io/clash/).
42: 
43: ## Credits
44: 
45: - [riobard/go-shadowsocks2](https://github.com/riobard/go-shadowsocks2)
46: - [v2ray/v2ray-core](https://github.com/v2ray/v2ray-core)
47: - [WireGuard/wireguard-go](https://github.com/WireGuard/wireguard-go)
48: 
49: ## License
50: 
51: This software is released under the GPL-3.0 license.
52: 
53: [![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2FDreamacro%2Fclash.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2FDreamacro%2Fclash?ref=badge_large)


./.git\config
1: [core]
2: 	repositoryformatversion = 0
3: 	filemode = false
4: 	bare = false
5: 	logallrefupdates = true
6: 	symlinks = false
7: 	ignorecase = true
8: [remote "origin"]
9: 	url = https://github.com/Dreamacro/clash.git
10: 	fetch = +refs/heads/*:refs/remotes/origin/*
11: [branch "master"]
12: 	remote = origin
13: 	merge = refs/heads/master


./.git\description
1: Unnamed repository; edit this file 'description' to name the repository.


./.git\HEAD
1: ref: refs/heads/master


./.git\index
- BINARY FILE -

./.git\packed-refs
1: # pack-refs with: peeled fully-peeled sorted 
2: d034a408be42815e98f3aea80be24949946aea83 refs/remotes/origin/dev
3: d034a408be42815e98f3aea80be24949946aea83 refs/remotes/origin/master
4: 8ff8ddc88f4ccc5405e06c0c4721cb3060ae5d92 refs/remotes/origin/rm
5: b5246f8efe63edf3c82dab5a5a7e8f0b546907b7 refs/remotes/origin/ss2022
6: 646bd4eeb4bbea6628987be55a167c45e718f77a refs/tags/premium
7: f93d6aa294ac2fdf3995c2851f6cc7c0649640ff refs/tags/v0.10.0
8: fcb1a7813ad0013411247f789ca59e0ab95399ce refs/tags/v0.10.1
9: 49635eab6cbc5c667ea1d015d4f3c06851f53a01 refs/tags/v0.10.2
10: 8da19e81a4f6768c221a125d9a901c0994f36b20 refs/tags/v0.11.0
11: 26a87f9d34d05bc16d7f1c2026d8957768d67c78 refs/tags/v0.11.1
12: e7997a035bfcbc943c0b71de2b0367a8183e8676 refs/tags/v0.12.0
13: 744728cb842080063d3ac9e744d11ce2c50d34e7 refs/tags/v0.13.0
14: 243d8a284432505ce8e77a1b8f9e5bf2c1b7282f refs/tags/v0.14.0
15: 34338e7107c1868124f8aab2446f6b71c9b0640f refs/tags/v0.15.0
16: d1fb442bd51ca697f8d9f7b3d451c9bdd83401cd refs/tags/v0.16.0
17: 93ea037230893576279a098a3429d58db2a70473 refs/tags/v0.17.0
18: 14a3ff32f6647fd0262f6239d43a8ea1762c7ca2 refs/tags/v0.17.1
19: 609869bf5a1d779b0ac6a0caca9ff9ea67b0c40f refs/tags/v0.18.0
20: c0a2473160f9da2ea2116358fed33a3e6a77ae5a refs/tags/v0.19.0
21: 646bd4eeb4bbea6628987be55a167c45e718f77a refs/tags/v0.20.0
22: f06bbe17cba3a7574c23b616fba62c2ecc989a6e refs/tags/v0.3.2
23: ^c35b2fd95826d50c1e5eef198bb4467192f2dcc8
24: 79e5338113787629817d95937976db832c6efd4c refs/tags/v0.4.0
25: 88c7ccf74919311131d63a19746a68e85a0cf871 refs/tags/v0.5.0
26: d4863e0982e211ea8c8ad9ba7150dcb84b2440c3 refs/tags/v0.6.0
27: ^ebe1cee6dc3f062fc2703eacb08a4d74a1ad4e46
28: 0caa8e05a32e3c92b8b09070485817221bfa6af5 refs/tags/v0.7.0
29: 3e68faecb2c0c73f3cd78ca57307e76e38f07065 refs/tags/v0.7.1
30: ce07eda42837f79a1f1a5e742e099bcf7fd37975 refs/tags/v0.8.0
31: 1235c9a939e2a0c8c1608afb3f036a314b4bd174 refs/tags/v0.8.1
32: 370bc769d5235ccadbc8a3a7b0512287f68f0d5b refs/tags/v0.9.0
33: 502aa61c0e82bfdd66eb5a73ddc37807103766f9 refs/tags/v0.9.1
34: 59968fff1cf8567fe390fd44fa97324ca5157d44 refs/tags/v1.0.0
35: 50d778da3c155af36181b53aa736b21fb3753f24 refs/tags/v1.1.0
36: 30d4668008b493b65e7d6982b4c43bb34871e13c refs/tags/v1.10.0
37: 5dd94c8298e2f7d0a264eb95835b9510e988441a refs/tags/v1.10.6
38: c231fd14666d6ea05d6a75eaba6db69f9eee5ae9 refs/tags/v1.11.0
39: c2469162fb1393245612be8d3fcb22d836c0f364 refs/tags/v1.11.12
40: 8c7c8f43741923d6a7650dc723b4b51b0f540777 refs/tags/v1.11.4
41: 2516169f61c03ba3a5076a56b2e3c29a381df5a5 refs/tags/v1.11.8
42: ed988dcdc55fb5aa0b76e9fdf4ded38dc5b422bc refs/tags/v1.12.0
43: 58732ee8b19f58ac397b580b9c19eb5524b2a977 refs/tags/v1.13.0
44: d808576f98019529f098476df979c7bcf2822c84 refs/tags/v1.14.0
45: 8e05fbfd6d07402027c8baea97cb673080769b5e refs/tags/v1.15.0
46: df61a586c9df496c2ab71790534b0cab5d9e47ba refs/tags/v1.15.1
47: d006b0f2b49711c7a5b967ef512198a68354a13a refs/tags/v1.16.0
48: 24186a488a395e532b9379db3d26b7672e76ea68 refs/tags/v1.17.0
49: fae10881b5c1d33cdf458391ce5e27cd49fa45d3 refs/tags/v1.18.0
50: d3b14c325f4487f57a3e2e8c7dca73e1a937ccdc refs/tags/v1.2.0
51: 1e5593f1a9e11714fbeff1d0adecfe68f48a697d refs/tags/v1.3.0
52: 3600077f3b6997c7b9e7a42a69afde6b17a5e5b1 refs/tags/v1.3.5
53: b3c1b4a84056523b6959f03d2cbfeee82c1e7fde refs/tags/v1.4.0
54: a37243cf300dcf0810299d41b3377beda5416c68 refs/tags/v1.4.1
55: 6c83ff3496542f12297eb971a611d3d3aea90297 refs/tags/v1.4.2
56: baf03b81e36e3c5d8b9a370ebb82dd2b25b4a58d refs/tags/v1.5.0
57: 3c54f99fea179ee86220052004870ce430c7638c refs/tags/v1.6.0
58: dff1e8f1ce0c6ed9d8a070c513a6b3478f701e2b refs/tags/v1.6.5
59: 5b7f0de48b6f26ce1ec5f54422b2b5e50e956c5c refs/tags/v1.7.0
60: b3cd4ebbd3c34697c9fe87f7f536421ada5004cf refs/tags/v1.7.1
61: c9be614821d5c9b4cb3582c2eaebed89341c7f6e refs/tags/v1.8.0
62: cb95326aca85b89da6182d0f72ee215354f59cc2 refs/tags/v1.9.0


./.git\hooks\applypatch-msg.sample
1: #!/bin/sh
2: #
3: # An example hook script to check the commit log message taken by
4: # applypatch from an e-mail message.
5: #
6: # The hook should exit with non-zero status after issuing an
7: # appropriate message if it wants to stop the commit.  The hook is
8: # allowed to edit the commit message file.
9: #
10: # To enable this hook, rename this file to "applypatch-msg".
11: 
12: . git-sh-setup
13: commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
14: test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
15: :


./.git\hooks\commit-msg.sample
1: #!/bin/sh
2: #
3: # An example hook script to check the commit log message.
4: # Called by "git commit" with one argument, the name of the file
5: # that has the commit message.  The hook should exit with non-zero
6: # status after issuing an appropriate message if it wants to stop the
7: # commit.  The hook is allowed to edit the commit message file.
8: #
9: # To enable this hook, rename this file to "commit-msg".
10: 
11: # Uncomment the below to add a Signed-off-by line to the message.
12: # Doing this in a hook is a bad idea in general, but the prepare-commit-msg
13: # hook is more suited to it.
14: #
15: # SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
16: # grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
17: 
18: # This example catches duplicate Signed-off-by lines.
19: 
20: test "" = "$(grep '^Signed-off-by: ' "$1" |
21: 	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
22: 	echo >&2 Duplicate Signed-off-by lines.
23: 	exit 1
24: }


./.git\hooks\fsmonitor-watchman.sample
1: #!/usr/bin/perl
2: 
3: use strict;
4: use warnings;
5: use IPC::Open2;
6: 
7: # An example hook script to integrate Watchman
8: # (https://facebook.github.io/watchman/) with git to speed up detecting
9: # new and modified files.
10: #
11: # The hook is passed a version (currently 2) and last update token
12: # formatted as a string and outputs to stdout a new update token and
13: # all files that have been modified since the update token. Paths must
14: # be relative to the root of the working tree and separated by a single NUL.
15: #
16: # To enable this hook, rename this file to "query-watchman" and set
17: # 'git config core.fsmonitor .git/hooks/query-watchman'
18: #
19: my ($version, $last_update_token) = @ARGV;
20: 
21: # Uncomment for debugging
22: # print STDERR "$0 $version $last_update_token\n";
23: 
24: # Check the hook interface version
25: if ($version ne 2) {
26: 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
27: 	    "Falling back to scanning...\n";
28: }
29: 
30: my $git_work_tree = get_working_dir();
31: 
32: my $retry = 1;
33: 
34: my $json_pkg;
35: eval {
36: 	require JSON::XS;
37: 	$json_pkg = "JSON::XS";
38: 	1;
39: } or do {
40: 	require JSON::PP;
41: 	$json_pkg = "JSON::PP";
42: };
43: 
44: launch_watchman();
45: 
46: sub launch_watchman {
47: 	my $o = watchman_query();
48: 	if (is_work_tree_watched($o)) {
49: 		output_result($o->{clock}, @{$o->{files}});
50: 	}
51: }
52: 
53: sub output_result {
54: 	my ($clockid, @files) = @_;
55: 
56: 	# Uncomment for debugging watchman output
57: 	# open (my $fh, ">", ".git/watchman-output.out");
58: 	# binmode $fh, ":utf8";
59: 	# print $fh "$clockid\n@files\n";
60: 	# close $fh;
61: 
62: 	binmode STDOUT, ":utf8";
63: 	print $clockid;
64: 	print "\0";
65: 	local $, = "\0";
66: 	print @files;
67: }
68: 
69: sub watchman_clock {
70: 	my $response = qx/watchman clock "$git_work_tree"/;
71: 	die "Failed to get clock id on '$git_work_tree'.\n" .
72: 		"Falling back to scanning...\n" if $? != 0;
73: 
74: 	return $json_pkg->new->utf8->decode($response);
75: }
76: 
77: sub watchman_query {
78: 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
79: 	or die "open2() failed: $!\n" .
80: 	"Falling back to scanning...\n";
81: 
82: 	# In the query expression below we're asking for names of files that
83: 	# changed since $last_update_token but not from the .git folder.
84: 	#
85: 	# To accomplish this, we're using the "since" generator to use the
86: 	# recency index to select candidate nodes and "fields" to limit the
87: 	# output to file names only. Then we're using the "expression" term to
88: 	# further constrain the results.
89: 	my $last_update_line = "";
90: 	if (substr($last_update_token, 0, 1) eq "c") {
91: 		$last_update_token = "\"$last_update_token\"";
92: 		$last_update_line = qq[\n"since": $last_update_token,];
93: 	}
94: 	my $query = <<"	END";
95: 		["query", "$git_work_tree", {$last_update_line
96: 			"fields": ["name"],
97: 			"expression": ["not", ["dirname", ".git"]]
98: 		}]
99: 	END
100: 
101: 	# Uncomment for debugging the watchman query
102: 	# open (my $fh, ">", ".git/watchman-query.json");
103: 	# print $fh $query;
104: 	# close $fh;
105: 
106: 	print CHLD_IN $query;
107: 	close CHLD_IN;
108: 	my $response = do {local $/; <CHLD_OUT>};
109: 
110: 	# Uncomment for debugging the watch response
111: 	# open ($fh, ">", ".git/watchman-response.json");
112: 	# print $fh $response;
113: 	# close $fh;
114: 
115: 	die "Watchman: command returned no output.\n" .
116: 	"Falling back to scanning...\n" if $response eq "";
117: 	die "Watchman: command returned invalid output: $response\n" .
118: 	"Falling back to scanning...\n" unless $response =~ /^\{/;
119: 
120: 	return $json_pkg->new->utf8->decode($response);
121: }
122: 
123: sub is_work_tree_watched {
124: 	my ($output) = @_;
125: 	my $error = $output->{error};
126: 	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
127: 		$retry--;
128: 		my $response = qx/watchman watch "$git_work_tree"/;
129: 		die "Failed to make watchman watch '$git_work_tree'.\n" .
130: 		    "Falling back to scanning...\n" if $? != 0;
131: 		$output = $json_pkg->new->utf8->decode($response);
132: 		$error = $output->{error};
133: 		die "Watchman: $error.\n" .
134: 		"Falling back to scanning...\n" if $error;
135: 
136: 		# Uncomment for debugging watchman output
137: 		# open (my $fh, ">", ".git/watchman-output.out");
138: 		# close $fh;
139: 
140: 		# Watchman will always return all files on the first query so
141: 		# return the fast "everything is dirty" flag to git and do the
142: 		# Watchman query just to get it over with now so we won't pay
143: 		# the cost in git to look up each individual file.
144: 		my $o = watchman_clock();
145: 		$error = $output->{error};
146: 
147: 		die "Watchman: $error.\n" .
148: 		"Falling back to scanning...\n" if $error;
149: 
150: 		output_result($o->{clock}, ("/"));
151: 		$last_update_token = $o->{clock};
152: 
153: 		eval { launch_watchman() };
154: 		return 0;
155: 	}
156: 
157: 	die "Watchman: $error.\n" .
158: 	"Falling back to scanning...\n" if $error;
159: 
160: 	return 1;
161: }
162: 
163: sub get_working_dir {
164: 	my $working_dir;
165: 	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
166: 		$working_dir = Win32::GetCwd();
167: 		$working_dir =~ tr/\\/\//;
168: 	} else {
169: 		require Cwd;
170: 		$working_dir = Cwd::cwd();
171: 	}
172: 
173: 	return $working_dir;
174: }


./.git\hooks\post-update.sample
1: #!/bin/sh
2: #
3: # An example hook script to prepare a packed repository for use over
4: # dumb transports.
5: #
6: # To enable this hook, rename this file to "post-update".
7: 
8: exec git update-server-info


./.git\hooks\pre-applypatch.sample
1: #!/bin/sh
2: #
3: # An example hook script to verify what is about to be committed
4: # by applypatch from an e-mail message.
5: #
6: # The hook should exit with non-zero status after issuing an
7: # appropriate message if it wants to stop the commit.
8: #
9: # To enable this hook, rename this file to "pre-applypatch".
10: 
11: . git-sh-setup
12: precommit="$(git rev-parse --git-path hooks/pre-commit)"
13: test -x "$precommit" && exec "$precommit" ${1+"$@"}
14: :


./.git\hooks\pre-commit.sample
1: #!/bin/sh
2: #
3: # An example hook script to verify what is about to be committed.
4: # Called by "git commit" with no arguments.  The hook should
5: # exit with non-zero status after issuing an appropriate message if
6: # it wants to stop the commit.
7: #
8: # To enable this hook, rename this file to "pre-commit".
9: 
10: if git rev-parse --verify HEAD >/dev/null 2>&1
11: then
12: 	against=HEAD
13: else
14: 	# Initial commit: diff against an empty tree object
15: 	against=$(git hash-object -t tree /dev/null)
16: fi
17: 
18: # If you want to allow non-ASCII filenames set this variable to true.
19: allownonascii=$(git config --type=bool hooks.allownonascii)
20: 
21: # Redirect output to stderr.
22: exec 1>&2
23: 
24: # Cross platform projects tend to avoid non-ASCII filenames; prevent
25: # them from being added to the repository. We exploit the fact that the
26: # printable range starts at the space character and ends with tilde.
27: if [ "$allownonascii" != "true" ] &&
28: 	# Note that the use of brackets around a tr range is ok here, (it's
29: 	# even required, for portability to Solaris 10's /usr/bin/tr), since
30: 	# the square bracket bytes happen to fall in the designated range.
31: 	test $(git diff --cached --name-only --diff-filter=A -z $against |
32: 	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
33: then
34: 	cat <<\EOF
35: Error: Attempt to add a non-ASCII file name.
36: 
37: This can cause problems if you want to work with people on other platforms.
38: 
39: To be portable it is advisable to rename the file.
40: 
41: If you know what you are doing you can disable this check using:
42: 
43:   git config hooks.allownonascii true
44: EOF
45: 	exit 1
46: fi
47: 
48: # If there are whitespace errors, print the offending file names and fail.
49: exec git diff-index --check --cached $against --


./.git\hooks\pre-merge-commit.sample
1: #!/bin/sh
2: #
3: # An example hook script to verify what is about to be committed.
4: # Called by "git merge" with no arguments.  The hook should
5: # exit with non-zero status after issuing an appropriate message to
6: # stderr if it wants to stop the merge commit.
7: #
8: # To enable this hook, rename this file to "pre-merge-commit".
9: 
10: . git-sh-setup
11: test -x "$GIT_DIR/hooks/pre-commit" &&
12:         exec "$GIT_DIR/hooks/pre-commit"
13: :


./.git\hooks\pre-push.sample
1: #!/bin/sh
2: 
3: # An example hook script to verify what is about to be pushed.  Called by "git
4: # push" after it has checked the remote status, but before anything has been
5: # pushed.  If this script exits with a non-zero status nothing will be pushed.
6: #
7: # This hook is called with the following parameters:
8: #
9: # $1 -- Name of the remote to which the push is being done
10: # $2 -- URL to which the push is being done
11: #
12: # If pushing without using a named remote those arguments will be equal.
13: #
14: # Information about the commits which are being pushed is supplied as lines to
15: # the standard input in the form:
16: #
17: #   <local ref> <local oid> <remote ref> <remote oid>
18: #
19: # This sample shows how to prevent push of commits where the log message starts
20: # with "WIP" (work in progress).
21: 
22: remote="$1"
23: url="$2"
24: 
25: zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
26: 
27: while read local_ref local_oid remote_ref remote_oid
28: do
29: 	if test "$local_oid" = "$zero"
30: 	then
31: 		# Handle delete
32: 		:
33: 	else
34: 		if test "$remote_oid" = "$zero"
35: 		then
36: 			# New branch, examine all commits
37: 			range="$local_oid"
38: 		else
39: 			# Update to existing branch, examine new commits
40: 			range="$remote_oid..$local_oid"
41: 		fi
42: 
43: 		# Check for WIP commit
44: 		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
45: 		if test -n "$commit"
46: 		then
47: 			echo >&2 "Found WIP commit in $local_ref, not pushing"
48: 			exit 1
49: 		fi
50: 	fi
51: done
52: 
53: exit 0


./.git\hooks\pre-rebase.sample
1: #!/bin/sh
2: #
3: # Copyright (c) 2006, 2008 Junio C Hamano
4: #
5: # The "pre-rebase" hook is run just before "git rebase" starts doing
6: # its job, and can prevent the command from running by exiting with
7: # non-zero status.
8: #
9: # The hook is called with the following parameters:
10: #
11: # $1 -- the upstream the series was forked from.
12: # $2 -- the branch being rebased (or empty when rebasing the current branch).
13: #
14: # This sample shows how to prevent topic branches that are already
15: # merged to 'next' branch from getting rebased, because allowing it
16: # would result in rebasing already published history.
17: 
18: publish=next
19: basebranch="$1"
20: if test "$#" = 2
21: then
22: 	topic="refs/heads/$2"
23: else
24: 	topic=`git symbolic-ref HEAD` ||
25: 	exit 0 ;# we do not interrupt rebasing detached HEAD
26: fi
27: 
28: case "$topic" in
29: refs/heads/??/*)
30: 	;;
31: *)
32: 	exit 0 ;# we do not interrupt others.
33: 	;;
34: esac
35: 
36: # Now we are dealing with a topic branch being rebased
37: # on top of master.  Is it OK to rebase it?
38: 
39: # Does the topic really exist?
40: git show-ref -q "$topic" || {
41: 	echo >&2 "No such branch $topic"
42: 	exit 1
43: }
44: 
45: # Is topic fully merged to master?
46: not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
47: if test -z "$not_in_master"
48: then
49: 	echo >&2 "$topic is fully merged to master; better remove it."
50: 	exit 1 ;# we could allow it, but there is no point.
51: fi
52: 
53: # Is topic ever merged to next?  If so you should not be rebasing it.
54: only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
55: only_next_2=`git rev-list ^master           ${publish} | sort`
56: if test "$only_next_1" = "$only_next_2"
57: then
58: 	not_in_topic=`git rev-list "^$topic" master`
59: 	if test -z "$not_in_topic"
60: 	then
61: 		echo >&2 "$topic is already up to date with master"
62: 		exit 1 ;# we could allow it, but there is no point.
63: 	else
64: 		exit 0
65: 	fi
66: else
67: 	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
68: 	/usr/bin/perl -e '
69: 		my $topic = $ARGV[0];
70: 		my $msg = "* $topic has commits already merged to public branch:\n";
71: 		my (%not_in_next) = map {
72: 			/^([0-9a-f]+) /;
73: 			($1 => 1);
74: 		} split(/\n/, $ARGV[1]);
75: 		for my $elem (map {
76: 				/^([0-9a-f]+) (.*)$/;
77: 				[$1 => $2];
78: 			} split(/\n/, $ARGV[2])) {
79: 			if (!exists $not_in_next{$elem->[0]}) {
80: 				if ($msg) {
81: 					print STDERR $msg;
82: 					undef $msg;
83: 				}
84: 				print STDERR " $elem->[1]\n";
85: 			}
86: 		}
87: 	' "$topic" "$not_in_next" "$not_in_master"
88: 	exit 1
89: fi
90: 
91: <<\DOC_END
92: 
93: This sample hook safeguards topic branches that have been
94: published from being rewound.
95: 
96: The workflow assumed here is:
97: 
98:  * Once a topic branch forks from "master", "master" is never
99:    merged into it again (either directly or indirectly).
100: 
101:  * Once a topic branch is fully cooked and merged into "master",
102:    it is deleted.  If you need to build on top of it to correct
103:    earlier mistakes, a new topic branch is created by forking at
104:    the tip of the "master".  This is not strictly necessary, but
105:    it makes it easier to keep your history simple.
106: 
107:  * Whenever you need to test or publish your changes to topic
108:    branches, merge them into "next" branch.
109: 
110: The script, being an example, hardcodes the publish branch name
111: to be "next", but it is trivial to make it configurable via
112: $GIT_DIR/config mechanism.
113: 
114: With this workflow, you would want to know:
115: 
116: (1) ... if a topic branch has ever been merged to "next".  Young
117:     topic branches can have stupid mistakes you would rather
118:     clean up before publishing, and things that have not been
119:     merged into other branches can be easily rebased without
120:     affecting other people.  But once it is published, you would
121:     not want to rewind it.
122: 
123: (2) ... if a topic branch has been fully merged to "master".
124:     Then you can delete it.  More importantly, you should not
125:     build on top of it -- other people may already want to
126:     change things related to the topic as patches against your
127:     "master", so if you need further changes, it is better to
128:     fork the topic (perhaps with the same name) afresh from the
129:     tip of "master".
130: 
131: Let's look at this example:
132: 
133: 		   o---o---o---o---o---o---o---o---o---o "next"
134: 		  /       /           /           /
135: 		 /   a---a---b A     /           /
136: 		/   /               /           /
137: 	       /   /   c---c---c---c B         /
138: 	      /   /   /             \         /
139: 	     /   /   /   b---b C     \       /
140: 	    /   /   /   /             \     /
141:     ---o---o---o---o---o---o---o---o---o---o---o "master"
142: 
143: 
144: A, B and C are topic branches.
145: 
146:  * A has one fix since it was merged up to "next".
147: 
148:  * B has finished.  It has been fully merged up to "master" and "next",
149:    and is ready to be deleted.
150: 
151:  * C has not merged to "next" at all.
152: 
153: We would want to allow C to be rebased, refuse A, and encourage
154: B to be deleted.
155: 
156: To compute (1):
157: 
158: 	git rev-list ^master ^topic next
159: 	git rev-list ^master        next
160: 
161: 	if these match, topic has not merged in next at all.
162: 
163: To compute (2):
164: 
165: 	git rev-list master..topic
166: 
167: 	if this is empty, it is fully merged to "master".
168: 
169: DOC_END


./.git\hooks\pre-receive.sample
1: #!/bin/sh
2: #
3: # An example hook script to make use of push options.
4: # The example simply echoes all push options that start with 'echoback='
5: # and rejects all pushes when the "reject" push option is used.
6: #
7: # To enable this hook, rename this file to "pre-receive".
8: 
9: if test -n "$GIT_PUSH_OPTION_COUNT"
10: then
11: 	i=0
12: 	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
13: 	do
14: 		eval "value=\$GIT_PUSH_OPTION_$i"
15: 		case "$value" in
16: 		echoback=*)
17: 			echo "echo from the pre-receive-hook: ${value#*=}" >&2
18: 			;;
19: 		reject)
20: 			exit 1
21: 		esac
22: 		i=$((i + 1))
23: 	done
24: fi


./.git\hooks\prepare-commit-msg.sample
1: #!/bin/sh
2: #
3: # An example hook script to prepare the commit log message.
4: # Called by "git commit" with the name of the file that has the
5: # commit message, followed by the description of the commit
6: # message's source.  The hook's purpose is to edit the commit
7: # message file.  If the hook fails with a non-zero status,
8: # the commit is aborted.
9: #
10: # To enable this hook, rename this file to "prepare-commit-msg".
11: 
12: # This hook includes three examples. The first one removes the
13: # "# Please enter the commit message..." help message.
14: #
15: # The second includes the output of "git diff --name-status -r"
16: # into the message, just before the "git status" output.  It is
17: # commented because it doesn't cope with --amend or with squashed
18: # commits.
19: #
20: # The third example adds a Signed-off-by line to the message, that can
21: # still be edited.  This is rarely a good idea.
22: 
23: COMMIT_MSG_FILE=$1
24: COMMIT_SOURCE=$2
25: SHA1=$3
26: 
27: /usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
28: 
29: # case "$COMMIT_SOURCE,$SHA1" in
30: #  ,|template,)
31: #    /usr/bin/perl -i.bak -pe '
32: #       print "\n" . `git diff --cached --name-status -r`
33: # 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
34: #  *) ;;
35: # esac
36: 
37: # SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
38: # git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
39: # if test -z "$COMMIT_SOURCE"
40: # then
41: #   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
42: # fi


./.git\hooks\push-to-checkout.sample
1: #!/bin/sh
2: 
3: # An example hook script to update a checked-out tree on a git push.
4: #
5: # This hook is invoked by git-receive-pack(1) when it reacts to git
6: # push and updates reference(s) in its repository, and when the push
7: # tries to update the branch that is currently checked out and the
8: # receive.denyCurrentBranch configuration variable is set to
9: # updateInstead.
10: #
11: # By default, such a push is refused if the working tree and the index
12: # of the remote repository has any difference from the currently
13: # checked out commit; when both the working tree and the index match
14: # the current commit, they are updated to match the newly pushed tip
15: # of the branch. This hook is to be used to override the default
16: # behaviour; however the code below reimplements the default behaviour
17: # as a starting point for convenient modification.
18: #
19: # The hook receives the commit with which the tip of the current
20: # branch is going to be updated:
21: commit=$1
22: 
23: # It can exit with a non-zero status to refuse the push (when it does
24: # so, it must not modify the index or the working tree).
25: die () {
26: 	echo >&2 "$*"
27: 	exit 1
28: }
29: 
30: # Or it can make any necessary changes to the working tree and to the
31: # index to bring them to the desired state when the tip of the current
32: # branch is updated to the new commit, and exit with a zero status.
33: #
34: # For example, the hook can simply run git read-tree -u -m HEAD "$1"
35: # in order to emulate git fetch that is run in the reverse direction
36: # with git push, as the two-tree form of git read-tree -u -m is
37: # essentially the same as git switch or git checkout that switches
38: # branches while keeping the local changes in the working tree that do
39: # not interfere with the difference between the branches.
40: 
41: # The below is a more-or-less exact translation to shell of the C code
42: # for the default behaviour for git's push-to-checkout hook defined in
43: # the push_to_deploy() function in builtin/receive-pack.c.
44: #
45: # Note that the hook will be executed from the repository directory,
46: # not from the working tree, so if you want to perform operations on
47: # the working tree, you will have to adapt your code accordingly, e.g.
48: # by adding "cd .." or using relative paths.
49: 
50: if ! git update-index -q --ignore-submodules --refresh
51: then
52: 	die "Up-to-date check failed"
53: fi
54: 
55: if ! git diff-files --quiet --ignore-submodules --
56: then
57: 	die "Working directory has unstaged changes"
58: fi
59: 
60: # This is a rough translation of:
61: #
62: #   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
63: if git cat-file -e HEAD 2>/dev/null
64: then
65: 	head=HEAD
66: else
67: 	head=$(git hash-object -t tree --stdin </dev/null)
68: fi
69: 
70: if ! git diff-index --quiet --cached --ignore-submodules $head --
71: then
72: 	die "Working directory has staged changes"
73: fi
74: 
75: if ! git read-tree -u -m "$commit"
76: then
77: 	die "Could not update working tree to new HEAD"
78: fi


./.git\hooks\update.sample
1: #!/bin/sh
2: #
3: # An example hook script to block unannotated tags from entering.
4: # Called by "git receive-pack" with arguments: refname sha1-old sha1-new
5: #
6: # To enable this hook, rename this file to "update".
7: #
8: # Config
9: # ------
10: # hooks.allowunannotated
11: #   This boolean sets whether unannotated tags will be allowed into the
12: #   repository.  By default they won't be.
13: # hooks.allowdeletetag
14: #   This boolean sets whether deleting tags will be allowed in the
15: #   repository.  By default they won't be.
16: # hooks.allowmodifytag
17: #   This boolean sets whether a tag may be modified after creation. By default
18: #   it won't be.
19: # hooks.allowdeletebranch
20: #   This boolean sets whether deleting branches will be allowed in the
21: #   repository.  By default they won't be.
22: # hooks.denycreatebranch
23: #   This boolean sets whether remotely creating branches will be denied
24: #   in the repository.  By default this is allowed.
25: #
26: 
27: # --- Command line
28: refname="$1"
29: oldrev="$2"
30: newrev="$3"
31: 
32: # --- Safety check
33: if [ -z "$GIT_DIR" ]; then
34: 	echo "Don't run this script from the command line." >&2
35: 	echo " (if you want, you could supply GIT_DIR then run" >&2
36: 	echo "  $0 <ref> <oldrev> <newrev>)" >&2
37: 	exit 1
38: fi
39: 
40: if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
41: 	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
42: 	exit 1
43: fi
44: 
45: # --- Config
46: allowunannotated=$(git config --type=bool hooks.allowunannotated)
47: allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
48: denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
49: allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
50: allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
51: 
52: # check for no description
53: projectdesc=$(sed -e '1q' "$GIT_DIR/description")
54: case "$projectdesc" in
55: "Unnamed repository"* | "")
56: 	echo "*** Project description file hasn't been set" >&2
57: 	exit 1
58: 	;;
59: esac
60: 
61: # --- Check types
62: # if $newrev is 0000...0000, it's a commit to delete a ref.
63: zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
64: if [ "$newrev" = "$zero" ]; then
65: 	newrev_type=delete
66: else
67: 	newrev_type=$(git cat-file -t $newrev)
68: fi
69: 
70: case "$refname","$newrev_type" in
71: 	refs/tags/*,commit)
72: 		# un-annotated tag
73: 		short_refname=${refname##refs/tags/}
74: 		if [ "$allowunannotated" != "true" ]; then
75: 			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
76: 			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
77: 			exit 1
78: 		fi
79: 		;;
80: 	refs/tags/*,delete)
81: 		# delete tag
82: 		if [ "$allowdeletetag" != "true" ]; then
83: 			echo "*** Deleting a tag is not allowed in this repository" >&2
84: 			exit 1
85: 		fi
86: 		;;
87: 	refs/tags/*,tag)
88: 		# annotated tag
89: 		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
90: 		then
91: 			echo "*** Tag '$refname' already exists." >&2
92: 			echo "*** Modifying a tag is not allowed in this repository." >&2
93: 			exit 1
94: 		fi
95: 		;;
96: 	refs/heads/*,commit)
97: 		# branch
98: 		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
99: 			echo "*** Creating a branch is not allowed in this repository" >&2
100: 			exit 1
101: 		fi
102: 		;;
103: 	refs/heads/*,delete)
104: 		# delete branch
105: 		if [ "$allowdeletebranch" != "true" ]; then
106: 			echo "*** Deleting a branch is not allowed in this repository" >&2
107: 			exit 1
108: 		fi
109: 		;;
110: 	refs/remotes/*,commit)
111: 		# tracking branch
112: 		;;
113: 	refs/remotes/*,delete)
114: 		# delete tracking branch
115: 		if [ "$allowdeletebranch" != "true" ]; then
116: 			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
117: 			exit 1
118: 		fi
119: 		;;
120: 	*)
121: 		# Anything else (is there anything else?)
122: 		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
123: 		exit 1
124: 		;;
125: esac
126: 
127: # --- Finished
128: exit 0


./.git\info\exclude
1: # git ls-files --others --exclude-from=.git/info/exclude
2: # Lines that start with '#' are comments.
3: # For a project mostly in C, the following would be a good set of
4: # exclude patterns (uncomment them if you want to use them):
5: # *.[oa]
6: # *~


./.git\logs\HEAD
1: 0000000000000000000000000000000000000000 d034a408be42815e98f3aea80be24949946aea83 weihongliang233 <weijohn158@gmail.com> 1698928974 +0800	clone: from https://github.com/Dreamacro/clash.git


./.git\logs\refs\heads\master
1: 0000000000000000000000000000000000000000 d034a408be42815e98f3aea80be24949946aea83 weihongliang233 <weijohn158@gmail.com> 1698928974 +0800	clone: from https://github.com/Dreamacro/clash.git


./.git\logs\refs\remotes\origin\HEAD
1: 0000000000000000000000000000000000000000 d034a408be42815e98f3aea80be24949946aea83 weihongliang233 <weijohn158@gmail.com> 1698928974 +0800	clone: from https://github.com/Dreamacro/clash.git


./.git\objects\pack\pack-65c2e5194b375dbe486361d22c0b34843d20ba74.idx
- BINARY FILE -

./.git\objects\pack\pack-65c2e5194b375dbe486361d22c0b34843d20ba74.pack
- BINARY FILE -

./.git\refs\heads\master
1: d034a408be42815e98f3aea80be24949946aea83


./.git\refs\remotes\origin\HEAD
1: ref: refs/remotes/origin/master


./.github\ISSUE_TEMPLATE\bug_report_en.yml
1: name: (English) Report a bug of the Clash core
2: description: Create a bug report to help us improve
3: labels:
4:   - bug
5: title: "[Bug] <issue title>"
6: body:
7:   - type: markdown
8:     attributes:
9:       value: "## Welcome to the official Clash open-source community"
10: 
11:   - type: markdown
12:     attributes:
13:       value: |
14:         Thank you for taking the time to report an issue with the Clash core.  
15:         
16:         Prior to submitting this issue, please read and follow the guidelines below to ensure that your issue can be resolved as quickly as possible. Options marked with an asterisk (*) are required, while others are optional. If the information you provide does not comply with the requirements, the maintainers may not respond and may directly close the issue.  
17:         
18:         If you can debug and fix the issue yourself, we welcome you to submit a pull request to merge your changes upstream.
19: 
20:   - type: checkboxes
21:     id: ensure
22:     attributes:
23:       label: Prerequisites
24:       description: "If any of the following options do not apply, please do not submit this issue as we will close it"
25:       options:
26:         - label: "I understand that this is the official open-source version of the Clash core, **only providing support for the open-source version or Premium version**"
27:           required: true
28:         - label: "I am submitting an issue with the Clash core, not Clash.Meta / OpenClash / ClashX / Clash For Windows or any other derivative version"
29:           required: true
30:         - label: "I am using the latest version of the Clash or Clash Premium core **in this repository**"
31:           required: true
32:         - label: "I have searched at the [Issue Tracker](……/) **and have not found any related issues**"
33:           required: true
34:         - label: "I have read the [official Wiki](https://dreamacro.github.io/clash/) **and was unable to solve the issue**"
35:           required: true
36:         - label: "(required for Premium core) I've tried the `dev` branch and the issue still exists"
37:           required: false
38: 
39:   - type: markdown
40:     attributes:
41:       value: "## Environment"
42:   - type: markdown
43:     attributes:
44:       value: |
45:         Please provide the following information to help us locate the issue.  
46:         The issue might be closed if there's not enough information provided.
47: 
48:   - type: input
49:     attributes:
50:       label: Version
51:       description: "Run `clash -v` or look at the bottom-left corner of the Clash Dashboard to find out"
52:     validations:
53:       required: true
54: 
55:   - type: dropdown
56:     id: os
57:     attributes:
58:       label: Operating System
59:       description: "Select all operating systems that apply to this issue"
60:       multiple: true
61:       options:
62:         - Linux
63:         - Windows
64:         - macOS (darwin)
65:         - Android
66:         - OpenBSD / FreeBSD
67: 
68:   - type: dropdown
69:     id: arch
70:     attributes:
71:       label: Architecture
72:       description: "Select all architectures that apply to this issue"
73:       multiple: true
74:       options:
75:         - amd64
76:         - amd64-v3
77:         - arm64
78:         - "386"
79:         - armv5
80:         - armv6
81:         - armv7
82:         - mips-softfloat
83:         - mips-hardfloat
84:         - mipsle-softfloat
85:         - mipsle-hardfloat
86:         - mips64
87:         - mips64le
88:         - riscv64
89: 
90:   - type: markdown
91:     attributes:
92:       value: "## Clash related information"
93:   - type: markdown
94:     attributes:
95:       value: |
96:         Please provide relevant information about your Clash instance here. If you
97:         do not provide enough information, the issue may be closed.
98: 
99:   - type: textarea
100:     attributes:
101:       render: YAML
102:       label: Configuration File
103:       placeholder: "Ensure that there is no sensitive information (such as server addresses, passwords, or ports) in the configuration file, and provide the minimum reproducible configuration. Do not post configurations with thousands of lines."
104:     validations:
105:       required: true
106: 
107:   - type: textarea
108:     attributes:
109:       render: Text
110:       label: Log
111:       placeholder: "Please attach the corresponding core outout (setting `log-level: debug` in the configuration provides debugging information)."
112: 
113:   - type: textarea
114:     attributes:
115:       label: Description
116:       placeholder: "Please describe your issue in detail here to help us understand (supports Markdown syntax)."
117:     validations:
118:       required: true
119: 
120:   - type: textarea
121:     attributes:
122:       label: Reproduction Steps
123:       placeholder: "Please provide the specific steps to reproduce the issue here (supports Markdown syntax)."
124: 


./.github\ISSUE_TEMPLATE\bug_report_zh.yml
1: name: （中文）提交 Clash 核心的问题
2: description: 如果 Clash 核心运作不符合预期，在这里提交问题
3: labels:
4:   - bug
5: title: "[Bug] <问题标题>"
6: body:
7:   - type: markdown
8:     attributes:
9:       value: "## 欢迎来到 Clash 官方开源社区！"
10: 
11:   - type: markdown
12:     attributes:
13:       value: |
14:         感谢你拨冗提交 Clash 内核的问题。在提交之前，请仔细阅读并遵守以下指引，以确保你的问题能够被尽快解决。  
15:         带有星号（*）的选项为必填，其他可选填。**如果你填写的资料不符合规范，维护者可能不予回复，并直接关闭这个 issue。**
16:         如果你可以自行 debug 并且修正，我们随时欢迎你提交 Pull Request，将你的修改合并到上游。
17: 
18:   - type: checkboxes
19:     id: ensure
20:     attributes:
21:       label: 先决条件
22:       description: "若以下任意选项不适用，请勿提交这个 issue，因为我们会把它关闭"
23:       options:
24:         - label: "我了解这里是官方开源版 Clash 核心仓库，**只提供开源版或者 Premium 内核的支持**"
25:           required: true
26:         - label: "我要提交 Clash 核心的问题，并非 Clash.Meta / OpenClash / ClashX / Clash For Windows 或其他任何衍生版本的问题"
27:           required: true
28:         - label: "我使用的是**本仓库**最新版本的 Clash 或 Clash Premium 内核"
29:           required: true
30:         - label: "我已经在 [Issue Tracker](……/) 中找过我要提出的 bug，**并且没有找到相关问题**"
31:           required: true
32:         - label: "我已经仔细阅读 [官方 Wiki](https://dreamacro.github.io/clash/) 并无法自行解决问题"
33:           required: true
34:         - label: "（非 Premium 内核必填）我已经使用 dev 分支版本测试过，问题依旧存在"
35:           required: false
36: 
37:   - type: markdown
38:     attributes:
39:       value: "## 系统环境"
40:   - type: markdown
41:     attributes:
42:       value: |
43:         请附上这个问题适用的环境，以帮助我们迅速定位问题并解决。若你提供的信息不足，我们将关闭
44:         这个 issue 并要求你提供更多信息。
45: 
46:   - type: input
47:     attributes:
48:       label: 版本
49:       description: "运行 `clash -v` 或者查看 Clash Dashboard 的左下角来找到你现在使用的版本"
50:     validations:
51:       required: true
52: 
53:   - type: dropdown
54:     id: os
55:     attributes:
56:       label: 适用的作业系统
57:       description: "勾选所有适用于这个 issue 的系统"
58:       multiple: true
59:       options:
60:         - Linux
61:         - Windows
62:         - macOS (darwin)
63:         - Android
64:         - OpenBSD / FreeBSD
65: 
66:   - type: dropdown
67:     id: arch
68:     attributes:
69:       label: 适用的硬件架构
70:       description: "勾选所有适用于这个 issue 的架构"
71:       multiple: true
72:       options:
73:         - amd64
74:         - amd64-v3
75:         - arm64
76:         - "386"
77:         - armv5
78:         - armv6
79:         - armv7
80:         - mips-softfloat
81:         - mips-hardfloat
82:         - mipsle-softfloat
83:         - mipsle-hardfloat
84:         - mips64
85:         - mips64le
86:         - riscv64
87: 
88:   - type: markdown
89:     attributes:
90:       value: "## Clash 相关信息"
91:   - type: markdown
92:     attributes:
93:       value: |
94:         请附上与这个问题直接相关的相应信息，以帮助我们迅速定位问题并解决。  
95:         若你提供的信息不足，我们将关闭这个 issue 并要求你提供更多信息。
96: 
97:   - type: textarea
98:     attributes:
99:       render: YAML
100:       label: "配置文件"
101:       placeholder: "确保配置文件中没有敏感信息（如：服务器地址、密码、端口），并且提供最小可复现配置，严禁贴上上千行的配置"
102:     validations:
103:       required: true
104: 
105:   - type: textarea
106:     attributes:
107:       render: Text
108:       label: 日志输出
109:       placeholder: "在这里附上问题对应的内核日志（在配置中设置 `log-level: debug` 可获得调试信息）"
110: 
111:   - type: textarea
112:     attributes:
113:       label: 问题描述
114:       placeholder: "在这里详细叙述你的问题，帮助我们理解（支持 Markdown 语法）"
115:     validations:
116:       required: true
117: 
118:   - type: textarea
119:     attributes:
120:       label: 复现步骤
121:       placeholder: "在这里提供问题的具体重现步骤（支持 Markdown 语法）"


./.github\ISSUE_TEMPLATE\config.yml
1: blank_issues_enabled: false
2: 
3: contact_links:
4:   - name: （中文）阅读 Wiki
5:     url: https://dreamacro.github.io/clash/zh_CN/
6:     about: 如果你是新手，或者想要了解 Clash 的更多信息，请阅读我们撰写的官方 Wiki
7:   - name: (English) Read our Wiki page
8:     url: https://dreamacro.github.io/clash/
9:     about: If you are new to Clash, or want to know more about Clash, please read our Wiki page


./.github\ISSUE_TEMPLATE\feature_request_en.yml
1: name: (English) Feature request
2: description: Suggest an idea for this project
3: labels:
4:   - enhancement
5: title: "[Feature] <title>"
6: body:
7:   - type: markdown
8:     attributes:
9:       value: "## Welcome to the official Clash open-source community"
10: 
11:   - type: markdown
12:     attributes:
13:       value: |
14:         Thank you for taking the time to make a suggestion to the Clash core.  
15:         
16:         Prior to submitting this issue, please read and follow the guidelines below to ensure that your issue can be resolved as quickly as possible. Options marked with an asterisk (*) are required, while others are optional. If the information you provide does not comply with the requirements, the maintainers may not respond and may directly close the issue.  
17:         
18:         If you can implement your idea by yourself, we welcome you to submit a pull request to merge your changes upstream.
19: 
20:   - type: checkboxes
21:     id: ensure
22:     attributes:
23:       label: Prerequisites
24:       description: "If any of the following options do not apply, please do not submit this issue as we will close it"
25:       options:
26:         - label: "I understand that this is the official open-source version of the Clash core, **only providing support for the open-source version or Premium version**"
27:           required: true
28:         - label: "I have looked for my idea in [the issue tracker](https://github.com/Dreamacro/clash/issues?q=is%3Aissue+label%3Aenhancement), **and found none of which being related**"
29:           required: true
30:         - label: "I have read the [official Wiki](https://dreamacro.github.io/clash/)"
31:           required: true
32: 
33:   - type: textarea
34:     attributes:
35:       label: Description
36:       placeholder: "Please explain your suggestions in detail and in a clear manner. For instance, how does this issue impact you? What specific functionality are you hoping to achieve? Also, let us know what Clash Core is currently doing in terms of your suggestion, and what you would like it to do instead."
37:     validations:
38:       required: true
39: 
40:   - type: textarea
41:     attributes:
42:       label: Possible Solution
43:       placeholder: "Do you have any ideas on the implementation details?"


./.github\ISSUE_TEMPLATE\feature_request_zh.yml
1: name: （中文）建议一个新功能
2: description: 在这里提供一个的想法或建议
3: labels:
4:   - enhancement
5: title: "[Feature] <标题>"
6: body:
7:   - type: markdown
8:     attributes:
9:       value: "## 欢迎来到 Clash 官方开源社区！"
10: 
11:   - type: markdown
12:     attributes:
13:       value: |
14:         感谢你拨冗为 Clash 内核提供建议。在提交之前，请仔细阅读并遵守以下指引，以确保你的建议能够被顺利采纳。  
15:         带有星号（*）的选项为必填，其他可选填。**如果你填写的资料不符合规范，维护者可能不予回复，并直接关闭这个 issue。**
16:         如果你可以自行添加这个功能，我们随时欢迎你提交 Pull Request，并将你的修改合并到上游。
17: 
18:   - type: checkboxes
19:     id: ensure
20:     attributes:
21:       label: 先决条件
22:       description: "若以下任意选项不适用，请勿提交这个 issue，因为我们会把它关闭"
23:       options:
24:         - label: "我了解这里是 Clash 官方仓库，并非 Clash.Meta / OpenClash / ClashX / Clash For Windows 或其他任何衍生版本"
25:           required: true
26:         - label: "我已经在[这里](https://github.com/Dreamacro/clash/issues?q=is%3Aissue+label%3Aenhancement)找过我要提出的建议，**并且没有找到相关问题**"
27:           required: true
28:         - label: "我已经仔细阅读 [官方 Wiki](https://dreamacro.github.io/clash/) "
29:           required: true
30: 
31:   - type: textarea
32:     attributes:
33:       label: 描述
34:       placeholder: 请详细、清晰地表达你要提出的论述，例如这个问题如何影响到你？你想实现什么功能？目前 Clash Core 的行为是什么？
35:     validations:
36:       required: true
37: 
38:   - type: textarea
39:     attributes:
40:       label: 可能的解决方案
41:       placeholder: 此项非必须，但是如果你有想法的话欢迎提出。


./.github\workflows\codeql-analysis.yml
1: name: CodeQL
2: 
3: on:
4:   push:
5:     branches: [master, dev]
6: 
7: jobs:
8:   analyze:
9:     name: Analyze
10:     runs-on: ubuntu-latest
11: 
12:     strategy:
13:       fail-fast: false
14:       matrix:
15:         language: ['go']
16: 
17:     steps:
18:     - name: Checkout repository
19:       uses: actions/checkout@v3
20: 
21:     - name: Initialize CodeQL
22:       uses: github/codeql-action/init@v2
23:       with:
24:         languages: ${{ matrix.language }}
25: 
26:     - name: Autobuild
27:       uses: github/codeql-action/autobuild@v2
28: 
29:     - name: Perform CodeQL Analysis
30:       uses: github/codeql-action/analyze@v2


./.github\workflows\deploy-docs.yml
1: name: Deploy
2: on:
3:   workflow_dispatch: {}
4:   push:
5:     branches:
6:       - master
7: jobs:
8:   deploy:
9:     runs-on: ubuntu-latest
10:     strategy:
11:       matrix:
12:         node-version: [20]
13:     permissions:
14:       pages: write
15:       id-token: write
16:     environment:
17:       name: github-pages
18:       url: ${{ steps.deployment.outputs.page_url }}
19:     steps:
20:       - uses: actions/checkout@v3
21:         with:
22:           fetch-depth: 0
23:       - uses: pnpm/action-setup@v2
24:         with:
25:           version: latest
26:       - name: Use Node.js ${{ matrix.node-version }}
27:         uses: actions/setup-node@v3
28:         with:
29:           node-version: ${{ matrix.node-version }}
30:       - name: Install dependencies
31:         working-directory: docs
32:         run: pnpm install --frozen-lockfile=false
33:       - name: Build
34:         working-directory: docs
35:         run: pnpm run docs:build
36:       - uses: actions/configure-pages@v2
37:       - uses: actions/upload-pages-artifact@v1
38:         with:
39:           path: docs/.vitepress/dist
40:       - name: Deploy
41:         id: deployment
42:         uses: actions/deploy-pages@v2


./.github\workflows\docker.yml
1: name: Publish Docker Image
2: on:
3:   push:
4:     branches:
5:       - dev
6:     tags:
7:       - '*'
8: jobs:
9: 
10:   build:
11:     name: Build
12:     runs-on: ubuntu-latest
13:     steps:
14: 
15:       - name: Check out code into the Go module directory
16:         uses: actions/checkout@v3
17:         with:
18:           fetch-depth: 0
19: 
20:       - name: Set up QEMU
21:         uses: docker/setup-qemu-action@v2
22:         with:
23:           platforms: all
24: 
25:       - name: Set up docker buildx
26:         id: buildx
27:         uses: docker/setup-buildx-action@v2
28:         with:
29:           version: latest
30: 
31:       - name: Login to DockerHub
32:         uses: docker/login-action@v2
33:         with:
34:           username: ${{ secrets.DOCKER_USERNAME }}
35:           password: ${{ secrets.DOCKER_PASSWORD }}
36:       
37:       - name: Login to Github Package
38:         uses: docker/login-action@v2
39:         with:
40:           registry: ghcr.io
41:           username: Dreamacro
42:           password: ${{ secrets.PACKAGE_TOKEN }}
43: 
44:       - name: Build dev branch and push
45:         if: github.ref == 'refs/heads/dev'
46:         uses: docker/build-push-action@v4
47:         with:
48:           context: .
49:           platforms: linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64
50:           push: true
51:           tags: 'dreamacro/clash:dev,ghcr.io/dreamacro/clash:dev'
52:           cache-from: type=gha
53:           cache-to: type=gha,mode=max
54: 
55:       - name: Get all docker tags
56:         if: startsWith(github.ref, 'refs/tags/')
57:         uses: actions/github-script@v6
58:         id: tags
59:         with:
60:           script: |
61:             const ref = context.payload.ref.replace(/\/?refs\/tags\//, '')
62:             const tags = [
63:               'dreamacro/clash:latest',
64:               `dreamacro/clash:${ref}`,
65:               'ghcr.io/dreamacro/clash:latest',
66:               `ghcr.io/dreamacro/clash:${ref}`
67:             ]
68:             return tags.join(',')
69:           result-encoding: string
70: 
71:       - name: Build release and push
72:         if: startsWith(github.ref, 'refs/tags/')
73:         uses: docker/build-push-action@v4
74:         with:
75:           context: .
76:           platforms: linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64
77:           push: true
78:           tags: ${{steps.tags.outputs.result}}
79:           cache-from: type=gha
80:           cache-to: type=gha,mode=max


./.github\workflows\linter.yml
1: name: Linter
2: on: [push, pull_request]
3: jobs:
4:   lint:
5:     runs-on: ubuntu-latest
6:     steps:
7:       - uses: actions/checkout@v3
8: 
9:       - name: Setup Go
10:         uses: actions/setup-go@v4
11:         with:
12:           check-latest: true
13:           go-version: '1.21'
14: 
15:       - name: golangci-lint
16:         uses: golangci/golangci-lint-action@v3
17:         with:
18:           version: latest


./.github\workflows\release.yml
1: name: Release
2: on: [push]
3: jobs:
4:   build:
5:     runs-on: ubuntu-latest
6:     steps:
7:       - name: Setup Go
8:         uses: actions/setup-go@v4
9:         with:
10:           check-latest: true
11:           go-version: '1.21'
12: 
13:       - name: Check out code into the Go module directory
14:         uses: actions/checkout@v3
15: 
16:       - name: Cache go module
17:         uses: actions/cache@v3
18:         with:
19:           path: |
20:             ~/go/pkg/mod
21:             ~/.cache/go-build
22:           key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
23:           restore-keys: |
24:             ${{ runner.os }}-go-
25: 
26:       - name: Build
27:         if: startsWith(github.ref, 'refs/tags/')
28:         env:
29:           NAME: clash
30:           BINDIR: bin
31:         run: make -j $(go run ./test/main.go) releases
32: 
33:       - name: Upload Release
34:         uses: softprops/action-gh-release@v1
35:         if: startsWith(github.ref, 'refs/tags/')
36:         with:
37:           files: bin/*
38:           draft: true


./.github\workflows\stale.yml
1:   
2: name: Mark stale issues and pull requests
3: 
4: on:
5:   schedule:
6:     - cron: "30 1 * * *"
7: 
8: jobs:
9:   stale:
10: 
11:     runs-on: ubuntu-latest
12: 
13:     steps:
14:       - uses: actions/stale@v7
15:         with:
16:           stale-issue-message: 'This issue is stale because it has been open 60 days with no activity. Remove stale label or comment or this will be closed in 5 days'
17:           days-before-stale: 60
18:           days-before-close: 5


./.github\workflows\test.yaml
1: name: Test
2: 
3: on: [push, pull_request]
4: 
5: jobs:
6:   test:
7:     name: Test
8:     runs-on: ubuntu-latest
9:     steps:
10:       - name: Setup Go
11:         uses: actions/setup-go@v4
12:         with:
13:           check-latest: true
14:           go-version: '1.21'
15: 
16:       - name: Check out code into the Go module directory
17:         uses: actions/checkout@v3
18: 
19:       - name: Cache go module
20:         uses: actions/cache@v3
21:         with:
22:           path: |
23:             ~/go/pkg/mod
24:             ~/.cache/go-build
25:           key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
26:           restore-keys: |
27:             ${{ runner.os }}-go-
28: 
29:       - name: Get dependencies, run test
30:         run: |
31:           go test ./...
32: 
33:   build-test:
34:     name: Build Test
35:     runs-on: ubuntu-latest
36:     steps:
37:       - name: Setup Go
38:         uses: actions/setup-go@v4
39:         with:
40:           check-latest: true
41:           go-version: '1.21'
42: 
43:       - name: Check out code into the Go module directory
44:         uses: actions/checkout@v3
45: 
46:       - name: Cache go module
47:         uses: actions/cache@v3
48:         with:
49:           path: |
50:             ~/go/pkg/mod
51:             ~/.cache/go-build
52:           key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
53:           restore-keys: |
54:             ${{ runner.os }}-go-
55: 
56:       - name: Build
57:         env:
58:           NAME: clash
59:           BINDIR: bin
60:         run: make -j $(go run ./test/main.go) all


./adapter\adapter.go
1: package adapter
2: 
3: import (
4: 	"context"
5: 	"encoding/json"
6: 	"fmt"
7: 	"net"
8: 	"net/http"
9: 	"net/url"
10: 	"strconv"
11: 	"time"
12: 
13: 	"github.com/Dreamacro/clash/common/queue"
14: 	"github.com/Dreamacro/clash/component/dialer"
15: 	C "github.com/Dreamacro/clash/constant"
16: 
17: 	"go.uber.org/atomic"
18: )
19: 
20: type Proxy struct {
21: 	C.ProxyAdapter
22: 	history *queue.Queue
23: 	alive   *atomic.Bool
24: }
25: 
26: // Alive implements C.Proxy
27: func (p *Proxy) Alive() bool {
28: 	return p.alive.Load()
29: }
30: 
31: // Dial implements C.Proxy
32: func (p *Proxy) Dial(metadata *C.Metadata) (C.Conn, error) {
33: 	ctx, cancel := context.WithTimeout(context.Background(), C.DefaultTCPTimeout)
34: 	defer cancel()
35: 	return p.DialContext(ctx, metadata)
36: }
37: 
38: // DialContext implements C.ProxyAdapter
39: func (p *Proxy) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.Conn, error) {
40: 	conn, err := p.ProxyAdapter.DialContext(ctx, metadata, opts...)
41: 	p.alive.Store(err == nil)
42: 	return conn, err
43: }
44: 
45: // DialUDP implements C.ProxyAdapter
46: func (p *Proxy) DialUDP(metadata *C.Metadata) (C.PacketConn, error) {
47: 	ctx, cancel := context.WithTimeout(context.Background(), C.DefaultUDPTimeout)
48: 	defer cancel()
49: 	return p.ListenPacketContext(ctx, metadata)
50: }
51: 
52: // ListenPacketContext implements C.ProxyAdapter
53: func (p *Proxy) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
54: 	pc, err := p.ProxyAdapter.ListenPacketContext(ctx, metadata, opts...)
55: 	p.alive.Store(err == nil)
56: 	return pc, err
57: }
58: 
59: // DelayHistory implements C.Proxy
60: func (p *Proxy) DelayHistory() []C.DelayHistory {
61: 	queue := p.history.Copy()
62: 	histories := []C.DelayHistory{}
63: 	for _, item := range queue {
64: 		histories = append(histories, item.(C.DelayHistory))
65: 	}
66: 	return histories
67: }
68: 
69: // LastDelay return last history record. if proxy is not alive, return the max value of uint16.
70: // implements C.Proxy
71: func (p *Proxy) LastDelay() (delay uint16) {
72: 	var max uint16 = 0xffff
73: 	if !p.alive.Load() {
74: 		return max
75: 	}
76: 
77: 	last := p.history.Last()
78: 	if last == nil {
79: 		return max
80: 	}
81: 	history := last.(C.DelayHistory)
82: 	if history.Delay == 0 {
83: 		return max
84: 	}
85: 	return history.Delay
86: }
87: 
88: // MarshalJSON implements C.ProxyAdapter
89: func (p *Proxy) MarshalJSON() ([]byte, error) {
90: 	inner, err := p.ProxyAdapter.MarshalJSON()
91: 	if err != nil {
92: 		return inner, err
93: 	}
94: 
95: 	mapping := map[string]any{}
96: 	json.Unmarshal(inner, &mapping)
97: 	mapping["history"] = p.DelayHistory()
98: 	mapping["alive"] = p.Alive()
99: 	mapping["name"] = p.Name()
100: 	mapping["udp"] = p.SupportUDP()
101: 	return json.Marshal(mapping)
102: }
103: 
104: // URLTest get the delay for the specified URL
105: // implements C.Proxy
106: func (p *Proxy) URLTest(ctx context.Context, url string) (delay, meanDelay uint16, err error) {
107: 	defer func() {
108: 		p.alive.Store(err == nil)
109: 		record := C.DelayHistory{Time: time.Now()}
110: 		if err == nil {
111: 			record.Delay = delay
112: 			record.MeanDelay = meanDelay
113: 		}
114: 		p.history.Put(record)
115: 		if p.history.Len() > 10 {
116: 			p.history.Pop()
117: 		}
118: 	}()
119: 
120: 	addr, err := urlToMetadata(url)
121: 	if err != nil {
122: 		return
123: 	}
124: 
125: 	start := time.Now()
126: 	instance, err := p.DialContext(ctx, &addr)
127: 	if err != nil {
128: 		return
129: 	}
130: 	defer instance.Close()
131: 
132: 	req, err := http.NewRequest(http.MethodHead, url, nil)
133: 	if err != nil {
134: 		return
135: 	}
136: 	req = req.WithContext(ctx)
137: 
138: 	transport := &http.Transport{
139: 		Dial: func(string, string) (net.Conn, error) {
140: 			return instance, nil
141: 		},
142: 		// from http.DefaultTransport
143: 		MaxIdleConns:          100,
144: 		IdleConnTimeout:       90 * time.Second,
145: 		TLSHandshakeTimeout:   10 * time.Second,
146: 		ExpectContinueTimeout: 1 * time.Second,
147: 	}
148: 
149: 	client := http.Client{
150: 		Transport: transport,
151: 		CheckRedirect: func(req *http.Request, via []*http.Request) error {
152: 			return http.ErrUseLastResponse
153: 		},
154: 	}
155: 	defer client.CloseIdleConnections()
156: 
157: 	resp, err := client.Do(req)
158: 	if err != nil {
159: 		return
160: 	}
161: 	resp.Body.Close()
162: 	delay = uint16(time.Since(start) / time.Millisecond)
163: 
164: 	resp, err = client.Do(req)
165: 	if err != nil {
166: 		// ignore error because some server will hijack the connection and close immediately
167: 		return delay, 0, nil
168: 	}
169: 	resp.Body.Close()
170: 	meanDelay = uint16(time.Since(start) / time.Millisecond / 2)
171: 
172: 	return
173: }
174: 
175: func NewProxy(adapter C.ProxyAdapter) *Proxy {
176: 	return &Proxy{adapter, queue.New(10), atomic.NewBool(true)}
177: }
178: 
179: func urlToMetadata(rawURL string) (addr C.Metadata, err error) {
180: 	u, err := url.Parse(rawURL)
181: 	if err != nil {
182: 		return
183: 	}
184: 
185: 	port := u.Port()
186: 	if port == "" {
187: 		switch u.Scheme {
188: 		case "https":
189: 			port = "443"
190: 		case "http":
191: 			port = "80"
192: 		default:
193: 			err = fmt.Errorf("%s scheme not Support", rawURL)
194: 			return
195: 		}
196: 	}
197: 
198: 	p, _ := strconv.ParseUint(port, 10, 16)
199: 
200: 	addr = C.Metadata{
201: 		Host:    u.Hostname(),
202: 		DstIP:   nil,
203: 		DstPort: C.Port(p),
204: 	}
205: 	return
206: }


./adapter\parser.go
1: package adapter
2: 
3: import (
4: 	"fmt"
5: 
6: 	"github.com/Dreamacro/clash/adapter/outbound"
7: 	"github.com/Dreamacro/clash/common/structure"
8: 	C "github.com/Dreamacro/clash/constant"
9: )
10: 
11: func ParseProxy(mapping map[string]any) (C.Proxy, error) {
12: 	decoder := structure.NewDecoder(structure.Option{TagName: "proxy", WeaklyTypedInput: true})
13: 	proxyType, existType := mapping["type"].(string)
14: 	if !existType {
15: 		return nil, fmt.Errorf("missing type")
16: 	}
17: 
18: 	var (
19: 		proxy C.ProxyAdapter
20: 		err   error
21: 	)
22: 	switch proxyType {
23: 	case "ss":
24: 		ssOption := &outbound.ShadowSocksOption{}
25: 		err = decoder.Decode(mapping, ssOption)
26: 		if err != nil {
27: 			break
28: 		}
29: 		proxy, err = outbound.NewShadowSocks(*ssOption)
30: 	case "ssr":
31: 		ssrOption := &outbound.ShadowSocksROption{}
32: 		err = decoder.Decode(mapping, ssrOption)
33: 		if err != nil {
34: 			break
35: 		}
36: 		proxy, err = outbound.NewShadowSocksR(*ssrOption)
37: 	case "socks5":
38: 		socksOption := &outbound.Socks5Option{}
39: 		err = decoder.Decode(mapping, socksOption)
40: 		if err != nil {
41: 			break
42: 		}
43: 		proxy = outbound.NewSocks5(*socksOption)
44: 	case "http":
45: 		httpOption := &outbound.HttpOption{}
46: 		err = decoder.Decode(mapping, httpOption)
47: 		if err != nil {
48: 			break
49: 		}
50: 		proxy = outbound.NewHttp(*httpOption)
51: 	case "vless":
52: 		fallthrough
53: 	case "vmess":
54: 		vmessOption := &outbound.VmessOption{
55: 			HTTPOpts: outbound.HTTPOptions{
56: 				Method: "GET",
57: 				Path:   []string{"/"},
58: 			},
59: 		}
60: 		err = decoder.Decode(mapping, vmessOption)
61: 		if err != nil {
62: 			break
63: 		}
64: 		if proxyType == "vless" {
65: 			proxy, err = outbound.NewVless(*vmessOption)
66: 		} else {
67: 			proxy, err = outbound.NewVmess(*vmessOption)
68: 		}
69: 	case "snell":
70: 		snellOption := &outbound.SnellOption{}
71: 		err = decoder.Decode(mapping, snellOption)
72: 		if err != nil {
73: 			break
74: 		}
75: 		proxy, err = outbound.NewSnell(*snellOption)
76: 	case "trojan":
77: 		trojanOption := &outbound.TrojanOption{}
78: 		err = decoder.Decode(mapping, trojanOption)
79: 		if err != nil {
80: 			break
81: 		}
82: 		proxy, err = outbound.NewTrojan(*trojanOption)
83: 	default:
84: 		return nil, fmt.Errorf("unsupport proxy type: %s", proxyType)
85: 	}
86: 
87: 	if err != nil {
88: 		return nil, err
89: 	}
90: 
91: 	return NewProxy(proxy), nil
92: }


./adapter\inbound\http.go
1: package inbound
2: 
3: import (
4: 	"net"
5: 	"net/netip"
6: 
7: 	C "github.com/Dreamacro/clash/constant"
8: 	"github.com/Dreamacro/clash/context"
9: 	"github.com/Dreamacro/clash/transport/socks5"
10: )
11: 
12: // NewHTTP receive normal http request and return HTTPContext
13: func NewHTTP(target socks5.Addr, source net.Addr, originTarget net.Addr, conn net.Conn) *context.ConnContext {
14: 	metadata := parseSocksAddr(target)
15: 	metadata.NetWork = C.TCP
16: 	metadata.Type = C.HTTP
17: 	if ip, port, err := parseAddr(source); err == nil {
18: 		metadata.SrcIP = ip
19: 		metadata.SrcPort = C.Port(port)
20: 	}
21: 	if originTarget != nil {
22: 		if addrPort, err := netip.ParseAddrPort(originTarget.String()); err == nil {
23: 			metadata.OriginDst = addrPort
24: 		}
25: 	}
26: 	return context.NewConnContext(conn, metadata)
27: }


./adapter\inbound\https.go
1: package inbound
2: 
3: import (
4: 	"net"
5: 	"net/http"
6: 	"net/netip"
7: 
8: 	C "github.com/Dreamacro/clash/constant"
9: 	"github.com/Dreamacro/clash/context"
10: )
11: 
12: // NewHTTPS receive CONNECT request and return ConnContext
13: func NewHTTPS(request *http.Request, conn net.Conn) *context.ConnContext {
14: 	metadata := parseHTTPAddr(request)
15: 	metadata.Type = C.HTTPCONNECT
16: 	if ip, port, err := parseAddr(conn.RemoteAddr()); err == nil {
17: 		metadata.SrcIP = ip
18: 		metadata.SrcPort = C.Port(port)
19: 	}
20: 	if addrPort, err := netip.ParseAddrPort(conn.LocalAddr().String()); err == nil {
21: 		metadata.OriginDst = addrPort
22: 	}
23: 	return context.NewConnContext(conn, metadata)
24: }


./adapter\inbound\packet.go
1: package inbound
2: 
3: import (
4: 	"net"
5: 	"net/netip"
6: 
7: 	C "github.com/Dreamacro/clash/constant"
8: 	"github.com/Dreamacro/clash/transport/socks5"
9: )
10: 
11: // PacketAdapter is a UDP Packet adapter for socks/redir/tun
12: type PacketAdapter struct {
13: 	C.UDPPacket
14: 	metadata *C.Metadata
15: }
16: 
17: // Metadata returns destination metadata
18: func (s *PacketAdapter) Metadata() *C.Metadata {
19: 	return s.metadata
20: }
21: 
22: // NewPacket is PacketAdapter generator
23: func NewPacket(target socks5.Addr, originTarget net.Addr, packet C.UDPPacket, source C.Type) *PacketAdapter {
24: 	metadata := parseSocksAddr(target)
25: 	metadata.NetWork = C.UDP
26: 	metadata.Type = source
27: 	if ip, port, err := parseAddr(packet.LocalAddr()); err == nil {
28: 		metadata.SrcIP = ip
29: 		metadata.SrcPort = C.Port(port)
30: 	}
31: 	if originTarget != nil {
32: 		if addrPort, err := netip.ParseAddrPort(originTarget.String()); err == nil {
33: 			metadata.OriginDst = addrPort
34: 		}
35: 	}
36: 	return &PacketAdapter{
37: 		UDPPacket: packet,
38: 		metadata:  metadata,
39: 	}
40: }


./adapter\inbound\socket.go
1: package inbound
2: 
3: import (
4: 	"net"
5: 	"net/netip"
6: 
7: 	C "github.com/Dreamacro/clash/constant"
8: 	"github.com/Dreamacro/clash/context"
9: 	"github.com/Dreamacro/clash/transport/socks5"
10: )
11: 
12: // NewSocket receive TCP inbound and return ConnContext
13: func NewSocket(target socks5.Addr, conn net.Conn, source C.Type) *context.ConnContext {
14: 	metadata := parseSocksAddr(target)
15: 	metadata.NetWork = C.TCP
16: 	metadata.Type = source
17: 	if ip, port, err := parseAddr(conn.RemoteAddr()); err == nil {
18: 		metadata.SrcIP = ip
19: 		metadata.SrcPort = C.Port(port)
20: 	}
21: 	if addrPort, err := netip.ParseAddrPort(conn.LocalAddr().String()); err == nil {
22: 		metadata.OriginDst = addrPort
23: 	}
24: 	return context.NewConnContext(conn, metadata)
25: }


./adapter\inbound\util.go
1: package inbound
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 	"net/http"
7: 	"strconv"
8: 	"strings"
9: 
10: 	"github.com/Dreamacro/clash/common/util"
11: 	C "github.com/Dreamacro/clash/constant"
12: 	"github.com/Dreamacro/clash/transport/socks5"
13: )
14: 
15: func parseSocksAddr(target socks5.Addr) *C.Metadata {
16: 	metadata := &C.Metadata{}
17: 
18: 	switch target[0] {
19: 	case socks5.AtypDomainName:
20: 		// trim for FQDN
21: 		metadata.Host = strings.TrimRight(string(target[2:2+target[1]]), ".")
22: 		metadata.DstPort = C.Port((int(target[2+target[1]]) << 8) | int(target[2+target[1]+1]))
23: 	case socks5.AtypIPv4:
24: 		ip := net.IP(target[1 : 1+net.IPv4len])
25: 		metadata.DstIP = ip
26: 		metadata.DstPort = C.Port((int(target[1+net.IPv4len]) << 8) | int(target[1+net.IPv4len+1]))
27: 	case socks5.AtypIPv6:
28: 		ip := net.IP(target[1 : 1+net.IPv6len])
29: 		metadata.DstIP = ip
30: 		metadata.DstPort = C.Port((int(target[1+net.IPv6len]) << 8) | int(target[1+net.IPv6len+1]))
31: 	}
32: 
33: 	return metadata
34: }
35: 
36: func parseHTTPAddr(request *http.Request) *C.Metadata {
37: 	host := request.URL.Hostname()
38: 	port, _ := strconv.ParseUint(util.EmptyOr(request.URL.Port(), "80"), 10, 16)
39: 
40: 	// trim FQDN (#737)
41: 	host = strings.TrimRight(host, ".")
42: 
43: 	metadata := &C.Metadata{
44: 		NetWork: C.TCP,
45: 		Host:    host,
46: 		DstIP:   nil,
47: 		DstPort: C.Port(port),
48: 	}
49: 
50: 	if ip := net.ParseIP(host); ip != nil {
51: 		metadata.DstIP = ip
52: 	}
53: 
54: 	return metadata
55: }
56: 
57: func parseAddr(addr net.Addr) (net.IP, int, error) {
58: 	switch a := addr.(type) {
59: 	case *net.TCPAddr:
60: 		return a.IP, a.Port, nil
61: 	case *net.UDPAddr:
62: 		return a.IP, a.Port, nil
63: 	default:
64: 		return nil, 0, fmt.Errorf("unknown address type %s", addr.String())
65: 	}
66: }


./adapter\outbound\base.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"encoding/json"
6: 	"errors"
7: 	"net"
8: 
9: 	"github.com/Dreamacro/clash/component/dialer"
10: 	C "github.com/Dreamacro/clash/constant"
11: )
12: 
13: type Base struct {
14: 	name  string
15: 	addr  string
16: 	iface string
17: 	tp    C.AdapterType
18: 	udp   bool
19: 	rmark int
20: }
21: 
22: // Name implements C.ProxyAdapter
23: func (b *Base) Name() string {
24: 	return b.name
25: }
26: 
27: // Type implements C.ProxyAdapter
28: func (b *Base) Type() C.AdapterType {
29: 	return b.tp
30: }
31: 
32: // StreamConn implements C.ProxyAdapter
33: func (b *Base) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
34: 	return c, errors.New("no support")
35: }
36: 
37: // ListenPacketContext implements C.ProxyAdapter
38: func (b *Base) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
39: 	return nil, errors.New("no support")
40: }
41: 
42: // SupportUDP implements C.ProxyAdapter
43: func (b *Base) SupportUDP() bool {
44: 	return b.udp
45: }
46: 
47: // MarshalJSON implements C.ProxyAdapter
48: func (b *Base) MarshalJSON() ([]byte, error) {
49: 	return json.Marshal(map[string]string{
50: 		"type": b.Type().String(),
51: 	})
52: }
53: 
54: // Addr implements C.ProxyAdapter
55: func (b *Base) Addr() string {
56: 	return b.addr
57: }
58: 
59: // Unwrap implements C.ProxyAdapter
60: func (b *Base) Unwrap(metadata *C.Metadata) C.Proxy {
61: 	return nil
62: }
63: 
64: // DialOptions return []dialer.Option from struct
65: func (b *Base) DialOptions(opts ...dialer.Option) []dialer.Option {
66: 	if b.iface != "" {
67: 		opts = append(opts, dialer.WithInterface(b.iface))
68: 	}
69: 
70: 	if b.rmark != 0 {
71: 		opts = append(opts, dialer.WithRoutingMark(b.rmark))
72: 	}
73: 
74: 	return opts
75: }
76: 
77: type BasicOption struct {
78: 	Interface   string `proxy:"interface-name,omitempty" group:"interface-name,omitempty"`
79: 	RoutingMark int    `proxy:"routing-mark,omitempty" group:"routing-mark,omitempty"`
80: }
81: 
82: type BaseOption struct {
83: 	Name        string
84: 	Addr        string
85: 	Type        C.AdapterType
86: 	UDP         bool
87: 	Interface   string
88: 	RoutingMark int
89: }
90: 
91: func NewBase(opt BaseOption) *Base {
92: 	return &Base{
93: 		name:  opt.Name,
94: 		addr:  opt.Addr,
95: 		tp:    opt.Type,
96: 		udp:   opt.UDP,
97: 		iface: opt.Interface,
98: 		rmark: opt.RoutingMark,
99: 	}
100: }
101: 
102: type conn struct {
103: 	net.Conn
104: 	chain C.Chain
105: }
106: 
107: // Chains implements C.Connection
108: func (c *conn) Chains() C.Chain {
109: 	return c.chain
110: }
111: 
112: // AppendToChains implements C.Connection
113: func (c *conn) AppendToChains(a C.ProxyAdapter) {
114: 	c.chain = append(c.chain, a.Name())
115: }
116: 
117: func NewConn(c net.Conn, a C.ProxyAdapter) C.Conn {
118: 	return &conn{c, []string{a.Name()}}
119: }
120: 
121: type packetConn struct {
122: 	net.PacketConn
123: 	chain C.Chain
124: }
125: 
126: // Chains implements C.Connection
127: func (c *packetConn) Chains() C.Chain {
128: 	return c.chain
129: }
130: 
131: // AppendToChains implements C.Connection
132: func (c *packetConn) AppendToChains(a C.ProxyAdapter) {
133: 	c.chain = append(c.chain, a.Name())
134: }
135: 
136: func newPacketConn(pc net.PacketConn, a C.ProxyAdapter) C.PacketConn {
137: 	return &packetConn{pc, []string{a.Name()}}
138: }


./adapter\outbound\direct.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"net"
6: 
7: 	"github.com/Dreamacro/clash/component/dialer"
8: 	C "github.com/Dreamacro/clash/constant"
9: )
10: 
11: type Direct struct {
12: 	*Base
13: }
14: 
15: // DialContext implements C.ProxyAdapter
16: func (d *Direct) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.Conn, error) {
17: 	c, err := dialer.DialContext(ctx, "tcp", metadata.RemoteAddress(), d.Base.DialOptions(opts...)...)
18: 	if err != nil {
19: 		return nil, err
20: 	}
21: 	tcpKeepAlive(c)
22: 	return NewConn(c, d), nil
23: }
24: 
25: // ListenPacketContext implements C.ProxyAdapter
26: func (d *Direct) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
27: 	pc, err := dialer.ListenPacket(ctx, "udp", "", d.Base.DialOptions(opts...)...)
28: 	if err != nil {
29: 		return nil, err
30: 	}
31: 	return newPacketConn(&directPacketConn{pc}, d), nil
32: }
33: 
34: type directPacketConn struct {
35: 	net.PacketConn
36: }
37: 
38: func NewDirect() *Direct {
39: 	return &Direct{
40: 		Base: &Base{
41: 			name: "DIRECT",
42: 			tp:   C.Direct,
43: 			udp:  true,
44: 		},
45: 	}
46: }


./adapter\outbound\http.go
1: package outbound
2: 
3: import (
4: 	"bufio"
5: 	"context"
6: 	"crypto/tls"
7: 	"encoding/base64"
8: 	"errors"
9: 	"fmt"
10: 	"io"
11: 	"net"
12: 	"net/http"
13: 	"net/url"
14: 	"strconv"
15: 
16: 	"github.com/Dreamacro/clash/component/dialer"
17: 	C "github.com/Dreamacro/clash/constant"
18: )
19: 
20: type Http struct {
21: 	*Base
22: 	user      string
23: 	pass      string
24: 	tlsConfig *tls.Config
25: 	Headers   http.Header
26: }
27: 
28: type HttpOption struct {
29: 	BasicOption
30: 	Name           string            `proxy:"name"`
31: 	Server         string            `proxy:"server"`
32: 	Port           int               `proxy:"port"`
33: 	UserName       string            `proxy:"username,omitempty"`
34: 	Password       string            `proxy:"password,omitempty"`
35: 	TLS            bool              `proxy:"tls,omitempty"`
36: 	SNI            string            `proxy:"sni,omitempty"`
37: 	SkipCertVerify bool              `proxy:"skip-cert-verify,omitempty"`
38: 	Headers        map[string]string `proxy:"headers,omitempty"`
39: }
40: 
41: // StreamConn implements C.ProxyAdapter
42: func (h *Http) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
43: 	if h.tlsConfig != nil {
44: 		cc := tls.Client(c, h.tlsConfig)
45: 		ctx, cancel := context.WithTimeout(context.Background(), C.DefaultTLSTimeout)
46: 		defer cancel()
47: 		err := cc.HandshakeContext(ctx)
48: 		c = cc
49: 		if err != nil {
50: 			return nil, fmt.Errorf("%s connect error: %w", h.addr, err)
51: 		}
52: 	}
53: 
54: 	if err := h.shakeHand(metadata, c); err != nil {
55: 		return nil, err
56: 	}
57: 	return c, nil
58: }
59: 
60: // DialContext implements C.ProxyAdapter
61: func (h *Http) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.Conn, err error) {
62: 	c, err := dialer.DialContext(ctx, "tcp", h.addr, h.Base.DialOptions(opts...)...)
63: 	if err != nil {
64: 		return nil, fmt.Errorf("%s connect error: %w", h.addr, err)
65: 	}
66: 	tcpKeepAlive(c)
67: 
68: 	defer func(c net.Conn) {
69: 		safeConnClose(c, err)
70: 	}(c)
71: 
72: 	c, err = h.StreamConn(c, metadata)
73: 	if err != nil {
74: 		return nil, err
75: 	}
76: 
77: 	return NewConn(c, h), nil
78: }
79: 
80: func (h *Http) shakeHand(metadata *C.Metadata, rw io.ReadWriter) error {
81: 	addr := metadata.RemoteAddress()
82: 	req := &http.Request{
83: 		Method: http.MethodConnect,
84: 		URL: &url.URL{
85: 			Host: addr,
86: 		},
87: 		Host:   addr,
88: 		Header: h.Headers.Clone(),
89: 	}
90: 
91: 	req.Header.Add("Proxy-Connection", "Keep-Alive")
92: 
93: 	if h.user != "" && h.pass != "" {
94: 		auth := h.user + ":" + h.pass
95: 		req.Header.Add("Proxy-Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(auth)))
96: 	}
97: 
98: 	if err := req.Write(rw); err != nil {
99: 		return err
100: 	}
101: 
102: 	resp, err := http.ReadResponse(bufio.NewReader(rw), req)
103: 	if err != nil {
104: 		return err
105: 	}
106: 
107: 	if resp.StatusCode == http.StatusOK {
108: 		return nil
109: 	}
110: 
111: 	if resp.StatusCode == http.StatusProxyAuthRequired {
112: 		return errors.New("HTTP need auth")
113: 	}
114: 
115: 	if resp.StatusCode == http.StatusMethodNotAllowed {
116: 		return errors.New("CONNECT method not allowed by proxy")
117: 	}
118: 
119: 	if resp.StatusCode >= http.StatusInternalServerError {
120: 		return errors.New(resp.Status)
121: 	}
122: 
123: 	return fmt.Errorf("can not connect remote err code: %d", resp.StatusCode)
124: }
125: 
126: func NewHttp(option HttpOption) *Http {
127: 	var tlsConfig *tls.Config
128: 	if option.TLS {
129: 		sni := option.Server
130: 		if option.SNI != "" {
131: 			sni = option.SNI
132: 		}
133: 		tlsConfig = &tls.Config{
134: 			InsecureSkipVerify: option.SkipCertVerify,
135: 			ServerName:         sni,
136: 		}
137: 	}
138: 
139: 	headers := http.Header{}
140: 	for name, value := range option.Headers {
141: 		headers.Add(name, value)
142: 	}
143: 
144: 	return &Http{
145: 		Base: &Base{
146: 			name:  option.Name,
147: 			addr:  net.JoinHostPort(option.Server, strconv.Itoa(option.Port)),
148: 			tp:    C.Http,
149: 			iface: option.Interface,
150: 			rmark: option.RoutingMark,
151: 		},
152: 		user:      option.UserName,
153: 		pass:      option.Password,
154: 		tlsConfig: tlsConfig,
155: 		Headers:   headers,
156: 	}
157: }


./adapter\outbound\reject.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"io"
6: 	"net"
7: 	"time"
8: 
9: 	"github.com/Dreamacro/clash/component/dialer"
10: 	C "github.com/Dreamacro/clash/constant"
11: )
12: 
13: type Reject struct {
14: 	*Base
15: }
16: 
17: // DialContext implements C.ProxyAdapter
18: func (r *Reject) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.Conn, error) {
19: 	return NewConn(&nopConn{}, r), nil
20: }
21: 
22: // ListenPacketContext implements C.ProxyAdapter
23: func (r *Reject) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
24: 	return newPacketConn(&nopPacketConn{}, r), nil
25: }
26: 
27: func NewReject() *Reject {
28: 	return &Reject{
29: 		Base: &Base{
30: 			name: "REJECT",
31: 			tp:   C.Reject,
32: 			udp:  true,
33: 		},
34: 	}
35: }
36: 
37: type nopConn struct{}
38: 
39: func (rw *nopConn) Read(b []byte) (int, error) {
40: 	return 0, io.EOF
41: }
42: 
43: func (rw *nopConn) Write(b []byte) (int, error) {
44: 	return 0, io.EOF
45: }
46: 
47: func (rw *nopConn) Close() error                     { return nil }
48: func (rw *nopConn) LocalAddr() net.Addr              { return nil }
49: func (rw *nopConn) RemoteAddr() net.Addr             { return nil }
50: func (rw *nopConn) SetDeadline(time.Time) error      { return nil }
51: func (rw *nopConn) SetReadDeadline(time.Time) error  { return nil }
52: func (rw *nopConn) SetWriteDeadline(time.Time) error { return nil }
53: 
54: type nopPacketConn struct{}
55: 
56: func (npc *nopPacketConn) WriteTo(b []byte, addr net.Addr) (n int, err error) { return len(b), nil }
57: func (npc *nopPacketConn) ReadFrom(b []byte) (int, net.Addr, error)           { return 0, nil, io.EOF }
58: func (npc *nopPacketConn) Close() error                                       { return nil }
59: func (npc *nopPacketConn) LocalAddr() net.Addr                                { return &net.UDPAddr{IP: net.IPv4zero, Port: 0} }
60: func (npc *nopPacketConn) SetDeadline(time.Time) error                        { return nil }
61: func (npc *nopPacketConn) SetReadDeadline(time.Time) error                    { return nil }
62: func (npc *nopPacketConn) SetWriteDeadline(time.Time) error                   { return nil }


./adapter\outbound\shadowsocks.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"errors"
6: 	"fmt"
7: 	"net"
8: 	"strconv"
9: 
10: 	"github.com/Dreamacro/clash/common/structure"
11: 	"github.com/Dreamacro/clash/component/dialer"
12: 	C "github.com/Dreamacro/clash/constant"
13: 	"github.com/Dreamacro/clash/transport/shadowsocks/core"
14: 	obfs "github.com/Dreamacro/clash/transport/simple-obfs"
15: 	"github.com/Dreamacro/clash/transport/socks5"
16: 	v2rayObfs "github.com/Dreamacro/clash/transport/v2ray-plugin"
17: )
18: 
19: type ShadowSocks struct {
20: 	*Base
21: 	cipher core.Cipher
22: 
23: 	// obfs
24: 	obfsMode    string
25: 	obfsOption  *simpleObfsOption
26: 	v2rayOption *v2rayObfs.Option
27: }
28: 
29: type ShadowSocksOption struct {
30: 	BasicOption
31: 	Name       string         `proxy:"name"`
32: 	Server     string         `proxy:"server"`
33: 	Port       int            `proxy:"port"`
34: 	Password   string         `proxy:"password"`
35: 	Cipher     string         `proxy:"cipher"`
36: 	UDP        bool           `proxy:"udp,omitempty"`
37: 	Plugin     string         `proxy:"plugin,omitempty"`
38: 	PluginOpts map[string]any `proxy:"plugin-opts,omitempty"`
39: }
40: 
41: type simpleObfsOption struct {
42: 	Mode string `obfs:"mode,omitempty"`
43: 	Host string `obfs:"host,omitempty"`
44: }
45: 
46: type v2rayObfsOption struct {
47: 	Mode           string            `obfs:"mode"`
48: 	Host           string            `obfs:"host,omitempty"`
49: 	Path           string            `obfs:"path,omitempty"`
50: 	TLS            bool              `obfs:"tls,omitempty"`
51: 	Headers        map[string]string `obfs:"headers,omitempty"`
52: 	SkipCertVerify bool              `obfs:"skip-cert-verify,omitempty"`
53: 	Mux            bool              `obfs:"mux,omitempty"`
54: }
55: 
56: // StreamConn implements C.ProxyAdapter
57: func (ss *ShadowSocks) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
58: 	switch ss.obfsMode {
59: 	case "tls":
60: 		c = obfs.NewTLSObfs(c, ss.obfsOption.Host)
61: 	case "http":
62: 		_, port, _ := net.SplitHostPort(ss.addr)
63: 		c = obfs.NewHTTPObfs(c, ss.obfsOption.Host, port)
64: 	case "websocket":
65: 		var err error
66: 		c, err = v2rayObfs.NewV2rayObfs(c, ss.v2rayOption)
67: 		if err != nil {
68: 			return nil, fmt.Errorf("%s connect error: %w", ss.addr, err)
69: 		}
70: 	}
71: 	c = ss.cipher.StreamConn(c)
72: 	_, err := c.Write(serializesSocksAddr(metadata))
73: 	return c, err
74: }
75: 
76: // DialContext implements C.ProxyAdapter
77: func (ss *ShadowSocks) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.Conn, err error) {
78: 	c, err := dialer.DialContext(ctx, "tcp", ss.addr, ss.Base.DialOptions(opts...)...)
79: 	if err != nil {
80: 		return nil, fmt.Errorf("%s connect error: %w", ss.addr, err)
81: 	}
82: 	tcpKeepAlive(c)
83: 
84: 	defer func(c net.Conn) {
85: 		safeConnClose(c, err)
86: 	}(c)
87: 
88: 	c, err = ss.StreamConn(c, metadata)
89: 	return NewConn(c, ss), err
90: }
91: 
92: // ListenPacketContext implements C.ProxyAdapter
93: func (ss *ShadowSocks) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
94: 	pc, err := dialer.ListenPacket(ctx, "udp", "", ss.Base.DialOptions(opts...)...)
95: 	if err != nil {
96: 		return nil, err
97: 	}
98: 
99: 	addr, err := resolveUDPAddr("udp", ss.addr)
100: 	if err != nil {
101: 		pc.Close()
102: 		return nil, err
103: 	}
104: 
105: 	pc = ss.cipher.PacketConn(pc)
106: 	return newPacketConn(&ssPacketConn{PacketConn: pc, rAddr: addr}, ss), nil
107: }
108: 
109: func NewShadowSocks(option ShadowSocksOption) (*ShadowSocks, error) {
110: 	addr := net.JoinHostPort(option.Server, strconv.Itoa(option.Port))
111: 	cipher := option.Cipher
112: 	password := option.Password
113: 	ciph, err := core.PickCipher(cipher, nil, password)
114: 	if err != nil {
115: 		return nil, fmt.Errorf("ss %s initialize error: %w", addr, err)
116: 	}
117: 
118: 	var v2rayOption *v2rayObfs.Option
119: 	var obfsOption *simpleObfsOption
120: 	obfsMode := ""
121: 
122: 	decoder := structure.NewDecoder(structure.Option{TagName: "obfs", WeaklyTypedInput: true})
123: 	if option.Plugin == "obfs" {
124: 		opts := simpleObfsOption{Host: "bing.com"}
125: 		if err := decoder.Decode(option.PluginOpts, &opts); err != nil {
126: 			return nil, fmt.Errorf("ss %s initialize obfs error: %w", addr, err)
127: 		}
128: 
129: 		if opts.Mode != "tls" && opts.Mode != "http" {
130: 			return nil, fmt.Errorf("ss %s obfs mode error: %s", addr, opts.Mode)
131: 		}
132: 		obfsMode = opts.Mode
133: 		obfsOption = &opts
134: 	} else if option.Plugin == "v2ray-plugin" {
135: 		opts := v2rayObfsOption{Host: "bing.com", Mux: true}
136: 		if err := decoder.Decode(option.PluginOpts, &opts); err != nil {
137: 			return nil, fmt.Errorf("ss %s initialize v2ray-plugin error: %w", addr, err)
138: 		}
139: 
140: 		if opts.Mode != "websocket" {
141: 			return nil, fmt.Errorf("ss %s obfs mode error: %s", addr, opts.Mode)
142: 		}
143: 		obfsMode = opts.Mode
144: 		v2rayOption = &v2rayObfs.Option{
145: 			Host:    opts.Host,
146: 			Path:    opts.Path,
147: 			Headers: opts.Headers,
148: 			Mux:     opts.Mux,
149: 		}
150: 
151: 		if opts.TLS {
152: 			v2rayOption.TLS = true
153: 			v2rayOption.SkipCertVerify = opts.SkipCertVerify
154: 		}
155: 	}
156: 
157: 	return &ShadowSocks{
158: 		Base: &Base{
159: 			name:  option.Name,
160: 			addr:  addr,
161: 			tp:    C.Shadowsocks,
162: 			udp:   option.UDP,
163: 			iface: option.Interface,
164: 			rmark: option.RoutingMark,
165: 		},
166: 		cipher: ciph,
167: 
168: 		obfsMode:    obfsMode,
169: 		v2rayOption: v2rayOption,
170: 		obfsOption:  obfsOption,
171: 	}, nil
172: }
173: 
174: type ssPacketConn struct {
175: 	net.PacketConn
176: 	rAddr net.Addr
177: }
178: 
179: func (spc *ssPacketConn) WriteTo(b []byte, addr net.Addr) (n int, err error) {
180: 	packet, err := socks5.EncodeUDPPacket(socks5.ParseAddrToSocksAddr(addr), b)
181: 	if err != nil {
182: 		return
183: 	}
184: 	return spc.PacketConn.WriteTo(packet[3:], spc.rAddr)
185: }
186: 
187: func (spc *ssPacketConn) ReadFrom(b []byte) (int, net.Addr, error) {
188: 	n, _, e := spc.PacketConn.ReadFrom(b)
189: 	if e != nil {
190: 		return 0, nil, e
191: 	}
192: 
193: 	addr := socks5.SplitAddr(b[:n])
194: 	if addr == nil {
195: 		return 0, nil, errors.New("parse addr error")
196: 	}
197: 
198: 	udpAddr := addr.UDPAddr()
199: 	if udpAddr == nil {
200: 		return 0, nil, errors.New("parse addr error")
201: 	}
202: 
203: 	copy(b, b[len(addr):])
204: 	return n - len(addr), udpAddr, e
205: }


./adapter\outbound\shadowsocksr.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"fmt"
6: 	"net"
7: 	"strconv"
8: 
9: 	"github.com/Dreamacro/clash/component/dialer"
10: 	C "github.com/Dreamacro/clash/constant"
11: 	"github.com/Dreamacro/clash/transport/shadowsocks/core"
12: 	"github.com/Dreamacro/clash/transport/shadowsocks/shadowaead"
13: 	"github.com/Dreamacro/clash/transport/shadowsocks/shadowstream"
14: 	"github.com/Dreamacro/clash/transport/ssr/obfs"
15: 	"github.com/Dreamacro/clash/transport/ssr/protocol"
16: )
17: 
18: type ShadowSocksR struct {
19: 	*Base
20: 	cipher   core.Cipher
21: 	obfs     obfs.Obfs
22: 	protocol protocol.Protocol
23: }
24: 
25: type ShadowSocksROption struct {
26: 	BasicOption
27: 	Name          string `proxy:"name"`
28: 	Server        string `proxy:"server"`
29: 	Port          int    `proxy:"port"`
30: 	Password      string `proxy:"password"`
31: 	Cipher        string `proxy:"cipher"`
32: 	Obfs          string `proxy:"obfs"`
33: 	ObfsParam     string `proxy:"obfs-param,omitempty"`
34: 	Protocol      string `proxy:"protocol"`
35: 	ProtocolParam string `proxy:"protocol-param,omitempty"`
36: 	UDP           bool   `proxy:"udp,omitempty"`
37: }
38: 
39: // StreamConn implements C.ProxyAdapter
40: func (ssr *ShadowSocksR) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
41: 	c = ssr.obfs.StreamConn(c)
42: 	c = ssr.cipher.StreamConn(c)
43: 	var (
44: 		iv  []byte
45: 		err error
46: 	)
47: 	switch conn := c.(type) {
48: 	case *shadowstream.Conn:
49: 		iv, err = conn.ObtainWriteIV()
50: 		if err != nil {
51: 			return nil, err
52: 		}
53: 	case *shadowaead.Conn:
54: 		return nil, fmt.Errorf("invalid connection type")
55: 	}
56: 	c = ssr.protocol.StreamConn(c, iv)
57: 	_, err = c.Write(serializesSocksAddr(metadata))
58: 	return c, err
59: }
60: 
61: // DialContext implements C.ProxyAdapter
62: func (ssr *ShadowSocksR) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.Conn, err error) {
63: 	c, err := dialer.DialContext(ctx, "tcp", ssr.addr, ssr.Base.DialOptions(opts...)...)
64: 	if err != nil {
65: 		return nil, fmt.Errorf("%s connect error: %w", ssr.addr, err)
66: 	}
67: 	tcpKeepAlive(c)
68: 
69: 	defer func(c net.Conn) {
70: 		safeConnClose(c, err)
71: 	}(c)
72: 
73: 	c, err = ssr.StreamConn(c, metadata)
74: 	return NewConn(c, ssr), err
75: }
76: 
77: // ListenPacketContext implements C.ProxyAdapter
78: func (ssr *ShadowSocksR) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
79: 	pc, err := dialer.ListenPacket(ctx, "udp", "", ssr.Base.DialOptions(opts...)...)
80: 	if err != nil {
81: 		return nil, err
82: 	}
83: 
84: 	addr, err := resolveUDPAddr("udp", ssr.addr)
85: 	if err != nil {
86: 		pc.Close()
87: 		return nil, err
88: 	}
89: 
90: 	pc = ssr.cipher.PacketConn(pc)
91: 	pc = ssr.protocol.PacketConn(pc)
92: 	return newPacketConn(&ssPacketConn{PacketConn: pc, rAddr: addr}, ssr), nil
93: }
94: 
95: func NewShadowSocksR(option ShadowSocksROption) (*ShadowSocksR, error) {
96: 	// SSR protocol compatibility
97: 	// https://github.com/Dreamacro/clash/pull/2056
98: 	if option.Cipher == "none" {
99: 		option.Cipher = "dummy"
100: 	}
101: 
102: 	addr := net.JoinHostPort(option.Server, strconv.Itoa(option.Port))
103: 	cipher := option.Cipher
104: 	password := option.Password
105: 	coreCiph, err := core.PickCipher(cipher, nil, password)
106: 	if err != nil {
107: 		return nil, fmt.Errorf("ssr %s initialize error: %w", addr, err)
108: 	}
109: 	var (
110: 		ivSize int
111: 		key    []byte
112: 	)
113: 
114: 	if option.Cipher == "dummy" {
115: 		ivSize = 0
116: 		key = core.Kdf(option.Password, 16)
117: 	} else {
118: 		ciph, ok := coreCiph.(*core.StreamCipher)
119: 		if !ok {
120: 			return nil, fmt.Errorf("%s is not none or a supported stream cipher in ssr", cipher)
121: 		}
122: 		ivSize = ciph.IVSize()
123: 		key = ciph.Key
124: 	}
125: 
126: 	obfs, obfsOverhead, err := obfs.PickObfs(option.Obfs, &obfs.Base{
127: 		Host:   option.Server,
128: 		Port:   option.Port,
129: 		Key:    key,
130: 		IVSize: ivSize,
131: 		Param:  option.ObfsParam,
132: 	})
133: 	if err != nil {
134: 		return nil, fmt.Errorf("ssr %s initialize obfs error: %w", addr, err)
135: 	}
136: 
137: 	protocol, err := protocol.PickProtocol(option.Protocol, &protocol.Base{
138: 		Key:      key,
139: 		Overhead: obfsOverhead,
140: 		Param:    option.ProtocolParam,
141: 	})
142: 	if err != nil {
143: 		return nil, fmt.Errorf("ssr %s initialize protocol error: %w", addr, err)
144: 	}
145: 
146: 	return &ShadowSocksR{
147: 		Base: &Base{
148: 			name:  option.Name,
149: 			addr:  addr,
150: 			tp:    C.ShadowsocksR,
151: 			udp:   option.UDP,
152: 			iface: option.Interface,
153: 			rmark: option.RoutingMark,
154: 		},
155: 		cipher:   coreCiph,
156: 		obfs:     obfs,
157: 		protocol: protocol,
158: 	}, nil
159: }


./adapter\outbound\snell.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"fmt"
6: 	"net"
7: 	"strconv"
8: 
9: 	"github.com/Dreamacro/clash/common/structure"
10: 	"github.com/Dreamacro/clash/component/dialer"
11: 	C "github.com/Dreamacro/clash/constant"
12: 	obfs "github.com/Dreamacro/clash/transport/simple-obfs"
13: 	"github.com/Dreamacro/clash/transport/snell"
14: )
15: 
16: type Snell struct {
17: 	*Base
18: 	psk        []byte
19: 	pool       *snell.Pool
20: 	obfsOption *simpleObfsOption
21: 	version    int
22: }
23: 
24: type SnellOption struct {
25: 	BasicOption
26: 	Name     string         `proxy:"name"`
27: 	Server   string         `proxy:"server"`
28: 	Port     int            `proxy:"port"`
29: 	Psk      string         `proxy:"psk"`
30: 	UDP      bool           `proxy:"udp,omitempty"`
31: 	Version  int            `proxy:"version,omitempty"`
32: 	ObfsOpts map[string]any `proxy:"obfs-opts,omitempty"`
33: }
34: 
35: type streamOption struct {
36: 	psk        []byte
37: 	version    int
38: 	addr       string
39: 	obfsOption *simpleObfsOption
40: }
41: 
42: func streamConn(c net.Conn, option streamOption) *snell.Snell {
43: 	switch option.obfsOption.Mode {
44: 	case "tls":
45: 		c = obfs.NewTLSObfs(c, option.obfsOption.Host)
46: 	case "http":
47: 		_, port, _ := net.SplitHostPort(option.addr)
48: 		c = obfs.NewHTTPObfs(c, option.obfsOption.Host, port)
49: 	}
50: 	return snell.StreamConn(c, option.psk, option.version)
51: }
52: 
53: // StreamConn implements C.ProxyAdapter
54: func (s *Snell) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
55: 	c = streamConn(c, streamOption{s.psk, s.version, s.addr, s.obfsOption})
56: 	err := snell.WriteHeader(c, metadata.String(), uint(metadata.DstPort), s.version)
57: 	return c, err
58: }
59: 
60: // DialContext implements C.ProxyAdapter
61: func (s *Snell) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.Conn, err error) {
62: 	if s.version == snell.Version2 && len(opts) == 0 {
63: 		c, err := s.pool.Get()
64: 		if err != nil {
65: 			return nil, err
66: 		}
67: 
68: 		if err = snell.WriteHeader(c, metadata.String(), uint(metadata.DstPort), s.version); err != nil {
69: 			c.Close()
70: 			return nil, err
71: 		}
72: 		return NewConn(c, s), err
73: 	}
74: 
75: 	c, err := dialer.DialContext(ctx, "tcp", s.addr, s.Base.DialOptions(opts...)...)
76: 	if err != nil {
77: 		return nil, fmt.Errorf("%s connect error: %w", s.addr, err)
78: 	}
79: 	tcpKeepAlive(c)
80: 
81: 	defer func(c net.Conn) {
82: 		safeConnClose(c, err)
83: 	}(c)
84: 
85: 	c, err = s.StreamConn(c, metadata)
86: 	return NewConn(c, s), err
87: }
88: 
89: // ListenPacketContext implements C.ProxyAdapter
90: func (s *Snell) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
91: 	c, err := dialer.DialContext(ctx, "tcp", s.addr, s.Base.DialOptions(opts...)...)
92: 	if err != nil {
93: 		return nil, err
94: 	}
95: 	tcpKeepAlive(c)
96: 	c = streamConn(c, streamOption{s.psk, s.version, s.addr, s.obfsOption})
97: 
98: 	err = snell.WriteUDPHeader(c, s.version)
99: 	if err != nil {
100: 		return nil, err
101: 	}
102: 
103: 	pc := snell.PacketConn(c)
104: 	return newPacketConn(pc, s), nil
105: }
106: 
107: func NewSnell(option SnellOption) (*Snell, error) {
108: 	addr := net.JoinHostPort(option.Server, strconv.Itoa(option.Port))
109: 	psk := []byte(option.Psk)
110: 
111: 	decoder := structure.NewDecoder(structure.Option{TagName: "obfs", WeaklyTypedInput: true})
112: 	obfsOption := &simpleObfsOption{Host: "bing.com"}
113: 	if err := decoder.Decode(option.ObfsOpts, obfsOption); err != nil {
114: 		return nil, fmt.Errorf("snell %s initialize obfs error: %w", addr, err)
115: 	}
116: 
117: 	switch obfsOption.Mode {
118: 	case "tls", "http", "":
119: 		break
120: 	default:
121: 		return nil, fmt.Errorf("snell %s obfs mode error: %s", addr, obfsOption.Mode)
122: 	}
123: 
124: 	// backward compatible
125: 	if option.Version == 0 {
126: 		option.Version = snell.DefaultSnellVersion
127: 	}
128: 	switch option.Version {
129: 	case snell.Version1, snell.Version2:
130: 		if option.UDP {
131: 			return nil, fmt.Errorf("snell version %d not support UDP", option.Version)
132: 		}
133: 	case snell.Version3:
134: 	default:
135: 		return nil, fmt.Errorf("snell version error: %d", option.Version)
136: 	}
137: 
138: 	s := &Snell{
139: 		Base: &Base{
140: 			name:  option.Name,
141: 			addr:  addr,
142: 			tp:    C.Snell,
143: 			udp:   option.UDP,
144: 			iface: option.Interface,
145: 			rmark: option.RoutingMark,
146: 		},
147: 		psk:        psk,
148: 		obfsOption: obfsOption,
149: 		version:    option.Version,
150: 	}
151: 
152: 	if option.Version == snell.Version2 {
153: 		s.pool = snell.NewPool(func(ctx context.Context) (*snell.Snell, error) {
154: 			c, err := dialer.DialContext(ctx, "tcp", addr, s.Base.DialOptions()...)
155: 			if err != nil {
156: 				return nil, err
157: 			}
158: 
159: 			tcpKeepAlive(c)
160: 			return streamConn(c, streamOption{psk, option.Version, addr, obfsOption}), nil
161: 		})
162: 	}
163: 	return s, nil
164: }


./adapter\outbound\socks5.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"crypto/tls"
6: 	"errors"
7: 	"fmt"
8: 	"io"
9: 	"net"
10: 	"net/netip"
11: 	"strconv"
12: 
13: 	"github.com/Dreamacro/clash/component/dialer"
14: 	C "github.com/Dreamacro/clash/constant"
15: 	"github.com/Dreamacro/clash/transport/socks5"
16: )
17: 
18: type Socks5 struct {
19: 	*Base
20: 	user           string
21: 	pass           string
22: 	tls            bool
23: 	skipCertVerify bool
24: 	tlsConfig      *tls.Config
25: }
26: 
27: type Socks5Option struct {
28: 	BasicOption
29: 	Name           string `proxy:"name"`
30: 	Server         string `proxy:"server"`
31: 	Port           int    `proxy:"port"`
32: 	UserName       string `proxy:"username,omitempty"`
33: 	Password       string `proxy:"password,omitempty"`
34: 	TLS            bool   `proxy:"tls,omitempty"`
35: 	UDP            bool   `proxy:"udp,omitempty"`
36: 	SkipCertVerify bool   `proxy:"skip-cert-verify,omitempty"`
37: }
38: 
39: // StreamConn implements C.ProxyAdapter
40: func (ss *Socks5) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
41: 	if ss.tls {
42: 		cc := tls.Client(c, ss.tlsConfig)
43: 		ctx, cancel := context.WithTimeout(context.Background(), C.DefaultTLSTimeout)
44: 		defer cancel()
45: 		err := cc.HandshakeContext(ctx)
46: 		c = cc
47: 		if err != nil {
48: 			return nil, fmt.Errorf("%s connect error: %w", ss.addr, err)
49: 		}
50: 	}
51: 
52: 	var user *socks5.User
53: 	if ss.user != "" {
54: 		user = &socks5.User{
55: 			Username: ss.user,
56: 			Password: ss.pass,
57: 		}
58: 	}
59: 	if _, err := socks5.ClientHandshake(c, serializesSocksAddr(metadata), socks5.CmdConnect, user); err != nil {
60: 		return nil, err
61: 	}
62: 	return c, nil
63: }
64: 
65: // DialContext implements C.ProxyAdapter
66: func (ss *Socks5) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.Conn, err error) {
67: 	c, err := dialer.DialContext(ctx, "tcp", ss.addr, ss.Base.DialOptions(opts...)...)
68: 	if err != nil {
69: 		return nil, fmt.Errorf("%s connect error: %w", ss.addr, err)
70: 	}
71: 	tcpKeepAlive(c)
72: 
73: 	defer func(c net.Conn) {
74: 		safeConnClose(c, err)
75: 	}(c)
76: 
77: 	c, err = ss.StreamConn(c, metadata)
78: 	if err != nil {
79: 		return nil, err
80: 	}
81: 
82: 	return NewConn(c, ss), nil
83: }
84: 
85: // ListenPacketContext implements C.ProxyAdapter
86: func (ss *Socks5) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.PacketConn, err error) {
87: 	c, err := dialer.DialContext(ctx, "tcp", ss.addr, ss.Base.DialOptions(opts...)...)
88: 	if err != nil {
89: 		err = fmt.Errorf("%s connect error: %w", ss.addr, err)
90: 		return
91: 	}
92: 
93: 	if ss.tls {
94: 		cc := tls.Client(c, ss.tlsConfig)
95: 		ctx, cancel := context.WithTimeout(context.Background(), C.DefaultTLSTimeout)
96: 		defer cancel()
97: 		err = cc.HandshakeContext(ctx)
98: 		c = cc
99: 	}
100: 
101: 	defer func(c net.Conn) {
102: 		safeConnClose(c, err)
103: 	}(c)
104: 
105: 	tcpKeepAlive(c)
106: 	var user *socks5.User
107: 	if ss.user != "" {
108: 		user = &socks5.User{
109: 			Username: ss.user,
110: 			Password: ss.pass,
111: 		}
112: 	}
113: 
114: 	udpAssocateAddr := socks5.AddrFromStdAddrPort(netip.AddrPortFrom(netip.IPv4Unspecified(), 0))
115: 	bindAddr, err := socks5.ClientHandshake(c, udpAssocateAddr, socks5.CmdUDPAssociate, user)
116: 	if err != nil {
117: 		err = fmt.Errorf("client hanshake error: %w", err)
118: 		return
119: 	}
120: 
121: 	pc, err := dialer.ListenPacket(ctx, "udp", "", ss.Base.DialOptions(opts...)...)
122: 	if err != nil {
123: 		return
124: 	}
125: 
126: 	go func() {
127: 		io.Copy(io.Discard, c)
128: 		c.Close()
129: 		// A UDP association terminates when the TCP connection that the UDP
130: 		// ASSOCIATE request arrived on terminates. RFC1928
131: 		pc.Close()
132: 	}()
133: 
134: 	// Support unspecified UDP bind address.
135: 	bindUDPAddr := bindAddr.UDPAddr()
136: 	if bindUDPAddr == nil {
137: 		err = errors.New("invalid UDP bind address")
138: 		return
139: 	} else if bindUDPAddr.IP.IsUnspecified() {
140: 		serverAddr, err := resolveUDPAddr("udp", ss.Addr())
141: 		if err != nil {
142: 			return nil, err
143: 		}
144: 
145: 		bindUDPAddr.IP = serverAddr.IP
146: 	}
147: 
148: 	return newPacketConn(&socksPacketConn{PacketConn: pc, rAddr: bindUDPAddr, tcpConn: c}, ss), nil
149: }
150: 
151: func NewSocks5(option Socks5Option) *Socks5 {
152: 	var tlsConfig *tls.Config
153: 	if option.TLS {
154: 		tlsConfig = &tls.Config{
155: 			InsecureSkipVerify: option.SkipCertVerify,
156: 			ServerName:         option.Server,
157: 		}
158: 	}
159: 
160: 	return &Socks5{
161: 		Base: &Base{
162: 			name:  option.Name,
163: 			addr:  net.JoinHostPort(option.Server, strconv.Itoa(option.Port)),
164: 			tp:    C.Socks5,
165: 			udp:   option.UDP,
166: 			iface: option.Interface,
167: 			rmark: option.RoutingMark,
168: 		},
169: 		user:           option.UserName,
170: 		pass:           option.Password,
171: 		tls:            option.TLS,
172: 		skipCertVerify: option.SkipCertVerify,
173: 		tlsConfig:      tlsConfig,
174: 	}
175: }
176: 
177: type socksPacketConn struct {
178: 	net.PacketConn
179: 	rAddr   net.Addr
180: 	tcpConn net.Conn
181: }
182: 
183: func (uc *socksPacketConn) WriteTo(b []byte, addr net.Addr) (n int, err error) {
184: 	packet, err := socks5.EncodeUDPPacket(socks5.ParseAddrToSocksAddr(addr), b)
185: 	if err != nil {
186: 		return
187: 	}
188: 	return uc.PacketConn.WriteTo(packet, uc.rAddr)
189: }
190: 
191: func (uc *socksPacketConn) ReadFrom(b []byte) (int, net.Addr, error) {
192: 	n, _, e := uc.PacketConn.ReadFrom(b)
193: 	if e != nil {
194: 		return 0, nil, e
195: 	}
196: 	addr, payload, err := socks5.DecodeUDPPacket(b)
197: 	if err != nil {
198: 		return 0, nil, err
199: 	}
200: 
201: 	udpAddr := addr.UDPAddr()
202: 	if udpAddr == nil {
203: 		return 0, nil, errors.New("parse udp addr error")
204: 	}
205: 
206: 	// due to DecodeUDPPacket is mutable, record addr length
207: 	copy(b, payload)
208: 	return n - len(addr) - 3, udpAddr, nil
209: }
210: 
211: func (uc *socksPacketConn) Close() error {
212: 	uc.tcpConn.Close()
213: 	return uc.PacketConn.Close()
214: }


./adapter\outbound\trojan.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"crypto/tls"
6: 	"fmt"
7: 	"net"
8: 	"net/http"
9: 	"strconv"
10: 
11: 	"github.com/Dreamacro/clash/component/dialer"
12: 	C "github.com/Dreamacro/clash/constant"
13: 	"github.com/Dreamacro/clash/transport/gun"
14: 	"github.com/Dreamacro/clash/transport/trojan"
15: 
16: 	"golang.org/x/net/http2"
17: )
18: 
19: type Trojan struct {
20: 	*Base
21: 	instance *trojan.Trojan
22: 	option   *TrojanOption
23: 
24: 	// for gun mux
25: 	gunTLSConfig *tls.Config
26: 	gunConfig    *gun.Config
27: 	transport    *http2.Transport
28: }
29: 
30: type TrojanOption struct {
31: 	BasicOption
32: 	Name           string      `proxy:"name"`
33: 	Server         string      `proxy:"server"`
34: 	Port           int         `proxy:"port"`
35: 	Password       string      `proxy:"password"`
36: 	ALPN           []string    `proxy:"alpn,omitempty"`
37: 	SNI            string      `proxy:"sni,omitempty"`
38: 	SkipCertVerify bool        `proxy:"skip-cert-verify,omitempty"`
39: 	UDP            bool        `proxy:"udp,omitempty"`
40: 	Network        string      `proxy:"network,omitempty"`
41: 	GrpcOpts       GrpcOptions `proxy:"grpc-opts,omitempty"`
42: 	WSOpts         WSOptions   `proxy:"ws-opts,omitempty"`
43: }
44: 
45: func (t *Trojan) plainStream(c net.Conn) (net.Conn, error) {
46: 	if t.option.Network == "ws" {
47: 		host, port, _ := net.SplitHostPort(t.addr)
48: 		wsOpts := &trojan.WebsocketOption{
49: 			Host: host,
50: 			Port: port,
51: 			Path: t.option.WSOpts.Path,
52: 		}
53: 
54: 		if t.option.SNI != "" {
55: 			wsOpts.Host = t.option.SNI
56: 		}
57: 
58: 		if len(t.option.WSOpts.Headers) != 0 {
59: 			header := http.Header{}
60: 			for key, value := range t.option.WSOpts.Headers {
61: 				header.Add(key, value)
62: 			}
63: 			wsOpts.Headers = header
64: 		}
65: 
66: 		return t.instance.StreamWebsocketConn(c, wsOpts)
67: 	}
68: 
69: 	return t.instance.StreamConn(c)
70: }
71: 
72: // StreamConn implements C.ProxyAdapter
73: func (t *Trojan) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
74: 	var err error
75: 	if t.transport != nil {
76: 		c, err = gun.StreamGunWithConn(c, t.gunTLSConfig, t.gunConfig)
77: 	} else {
78: 		c, err = t.plainStream(c)
79: 	}
80: 
81: 	if err != nil {
82: 		return nil, fmt.Errorf("%s connect error: %w", t.addr, err)
83: 	}
84: 
85: 	err = t.instance.WriteHeader(c, trojan.CommandTCP, serializesSocksAddr(metadata))
86: 	return c, err
87: }
88: 
89: // DialContext implements C.ProxyAdapter
90: func (t *Trojan) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.Conn, err error) {
91: 	// gun transport
92: 	if t.transport != nil && len(opts) == 0 {
93: 		c, err := gun.StreamGunWithTransport(t.transport, t.gunConfig)
94: 		if err != nil {
95: 			return nil, err
96: 		}
97: 
98: 		if err = t.instance.WriteHeader(c, trojan.CommandTCP, serializesSocksAddr(metadata)); err != nil {
99: 			c.Close()
100: 			return nil, err
101: 		}
102: 
103: 		return NewConn(c, t), nil
104: 	}
105: 
106: 	c, err := dialer.DialContext(ctx, "tcp", t.addr, t.Base.DialOptions(opts...)...)
107: 	if err != nil {
108: 		return nil, fmt.Errorf("%s connect error: %w", t.addr, err)
109: 	}
110: 	tcpKeepAlive(c)
111: 
112: 	defer func(c net.Conn) {
113: 		safeConnClose(c, err)
114: 	}(c)
115: 
116: 	c, err = t.StreamConn(c, metadata)
117: 	if err != nil {
118: 		return nil, err
119: 	}
120: 
121: 	return NewConn(c, t), err
122: }
123: 
124: // ListenPacketContext implements C.ProxyAdapter
125: func (t *Trojan) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.PacketConn, err error) {
126: 	var c net.Conn
127: 
128: 	// grpc transport
129: 	if t.transport != nil && len(opts) == 0 {
130: 		c, err = gun.StreamGunWithTransport(t.transport, t.gunConfig)
131: 		if err != nil {
132: 			return nil, fmt.Errorf("%s connect error: %w", t.addr, err)
133: 		}
134: 		defer func(c net.Conn) {
135: 			safeConnClose(c, err)
136: 		}(c)
137: 	} else {
138: 		c, err = dialer.DialContext(ctx, "tcp", t.addr, t.Base.DialOptions(opts...)...)
139: 		if err != nil {
140: 			return nil, fmt.Errorf("%s connect error: %w", t.addr, err)
141: 		}
142: 		defer func(c net.Conn) {
143: 			safeConnClose(c, err)
144: 		}(c)
145: 		tcpKeepAlive(c)
146: 		c, err = t.plainStream(c)
147: 		if err != nil {
148: 			return nil, fmt.Errorf("%s connect error: %w", t.addr, err)
149: 		}
150: 	}
151: 
152: 	err = t.instance.WriteHeader(c, trojan.CommandUDP, serializesSocksAddr(metadata))
153: 	if err != nil {
154: 		return nil, err
155: 	}
156: 
157: 	pc := t.instance.PacketConn(c)
158: 	return newPacketConn(pc, t), err
159: }
160: 
161: func NewTrojan(option TrojanOption) (*Trojan, error) {
162: 	addr := net.JoinHostPort(option.Server, strconv.Itoa(option.Port))
163: 
164: 	tOption := &trojan.Option{
165: 		Password:       option.Password,
166: 		ALPN:           option.ALPN,
167: 		ServerName:     option.Server,
168: 		SkipCertVerify: option.SkipCertVerify,
169: 	}
170: 
171: 	if option.SNI != "" {
172: 		tOption.ServerName = option.SNI
173: 	}
174: 
175: 	t := &Trojan{
176: 		Base: &Base{
177: 			name:  option.Name,
178: 			addr:  addr,
179: 			tp:    C.Trojan,
180: 			udp:   option.UDP,
181: 			iface: option.Interface,
182: 			rmark: option.RoutingMark,
183: 		},
184: 		instance: trojan.New(tOption),
185: 		option:   &option,
186: 	}
187: 
188: 	if option.Network == "grpc" {
189: 		dialFn := func(network, addr string) (net.Conn, error) {
190: 			c, err := dialer.DialContext(context.Background(), "tcp", t.addr, t.Base.DialOptions()...)
191: 			if err != nil {
192: 				return nil, fmt.Errorf("%s connect error: %s", t.addr, err.Error())
193: 			}
194: 			tcpKeepAlive(c)
195: 			return c, nil
196: 		}
197: 
198: 		tlsConfig := &tls.Config{
199: 			NextProtos:         option.ALPN,
200: 			MinVersion:         tls.VersionTLS12,
201: 			InsecureSkipVerify: tOption.SkipCertVerify,
202: 			ServerName:         tOption.ServerName,
203: 		}
204: 
205: 		t.transport = gun.NewHTTP2Client(dialFn, tlsConfig)
206: 		t.gunTLSConfig = tlsConfig
207: 		t.gunConfig = &gun.Config{
208: 			ServiceName: option.GrpcOpts.GrpcServiceName,
209: 			Host:        tOption.ServerName,
210: 		}
211: 	}
212: 
213: 	return t, nil
214: }


./adapter\outbound\util.go
1: package outbound
2: 
3: import (
4: 	"net"
5: 	"time"
6: 
7: 	"github.com/Dreamacro/clash/component/resolver"
8: 	C "github.com/Dreamacro/clash/constant"
9: 	"github.com/Dreamacro/clash/transport/socks5"
10: 
11: 	"github.com/Dreamacro/protobytes"
12: )
13: 
14: func tcpKeepAlive(c net.Conn) {
15: 	if tcp, ok := c.(*net.TCPConn); ok {
16: 		tcp.SetKeepAlive(true)
17: 		tcp.SetKeepAlivePeriod(30 * time.Second)
18: 	}
19: }
20: 
21: func serializesSocksAddr(metadata *C.Metadata) []byte {
22: 	buf := protobytes.BytesWriter{}
23: 
24: 	addrType := metadata.AddrType()
25: 	buf.PutUint8(uint8(addrType))
26: 
27: 	switch addrType {
28: 	case socks5.AtypDomainName:
29: 		buf.PutUint8(uint8(len(metadata.Host)))
30: 		buf.PutString(metadata.Host)
31: 	case socks5.AtypIPv4:
32: 		buf.PutSlice(metadata.DstIP.To4())
33: 	case socks5.AtypIPv6:
34: 		buf.PutSlice(metadata.DstIP.To16())
35: 	}
36: 
37: 	buf.PutUint16be(uint16(metadata.DstPort))
38: 	return buf.Bytes()
39: }
40: 
41: func resolveUDPAddr(network, address string) (*net.UDPAddr, error) {
42: 	host, port, err := net.SplitHostPort(address)
43: 	if err != nil {
44: 		return nil, err
45: 	}
46: 
47: 	ip, err := resolver.ResolveIP(host)
48: 	if err != nil {
49: 		return nil, err
50: 	}
51: 	return net.ResolveUDPAddr(network, net.JoinHostPort(ip.String(), port))
52: }
53: 
54: func safeConnClose(c net.Conn, err error) {
55: 	if err != nil {
56: 		c.Close()
57: 	}
58: }


./adapter\outbound\vless.go
1: package outbound
2: 
3: type (
4: 	Vless       = Vmess
5: 	VlessOption = VmessOption
6: )
7: 
8: func NewVless(option VlessOption) (*Vless, error) {
9: 	return newVmess(option, true)
10: }


./adapter\outbound\vmess.go
1: package outbound
2: 
3: import (
4: 	"context"
5: 	"crypto/tls"
6: 	"errors"
7: 	"fmt"
8: 	"net"
9: 	"net/http"
10: 	"strconv"
11: 	"strings"
12: 
13: 	"github.com/Dreamacro/clash/component/dialer"
14: 	"github.com/Dreamacro/clash/component/resolver"
15: 	C "github.com/Dreamacro/clash/constant"
16: 	"github.com/Dreamacro/clash/transport/gun"
17: 	"github.com/Dreamacro/clash/transport/socks5"
18: 	"github.com/Dreamacro/clash/transport/vmess"
19: 
20: 	"golang.org/x/net/http2"
21: )
22: 
23: var ErrUDPRemoteAddrMismatch = errors.New("udp packet dropped due to mismatched remote address")
24: 
25: type Vmess struct {
26: 	*Base
27: 	client *vmess.Client
28: 	option *VmessOption
29: 
30: 	// for gun mux
31: 	gunTLSConfig *tls.Config
32: 	gunConfig    *gun.Config
33: 	transport    *http2.Transport
34: }
35: 
36: type VmessOption struct {
37: 	BasicOption
38: 	Name           string       `proxy:"name"`
39: 	Server         string       `proxy:"server"`
40: 	Port           int          `proxy:"port"`
41: 	UUID           string       `proxy:"uuid"`
42: 	AlterID        int          `proxy:"alterId,omitempty"`
43: 	Cipher         string       `proxy:"cipher,omitempty"`
44: 	UDP            bool         `proxy:"udp,omitempty"`
45: 	Network        string       `proxy:"network,omitempty"`
46: 	TLS            bool         `proxy:"tls,omitempty"`
47: 	SkipCertVerify bool         `proxy:"skip-cert-verify,omitempty"`
48: 	ServerName     string       `proxy:"servername,omitempty"`
49: 	HTTPOpts       HTTPOptions  `proxy:"http-opts,omitempty"`
50: 	HTTP2Opts      HTTP2Options `proxy:"h2-opts,omitempty"`
51: 	GrpcOpts       GrpcOptions  `proxy:"grpc-opts,omitempty"`
52: 	WSOpts         WSOptions    `proxy:"ws-opts,omitempty"`
53: }
54: 
55: type HTTPOptions struct {
56: 	Method  string              `proxy:"method,omitempty"`
57: 	Path    []string            `proxy:"path,omitempty"`
58: 	Headers map[string][]string `proxy:"headers,omitempty"`
59: }
60: 
61: type HTTP2Options struct {
62: 	Host []string `proxy:"host,omitempty"`
63: 	Path string   `proxy:"path,omitempty"`
64: }
65: 
66: type GrpcOptions struct {
67: 	GrpcServiceName string `proxy:"grpc-service-name,omitempty"`
68: }
69: 
70: type WSOptions struct {
71: 	Path                string            `proxy:"path,omitempty"`
72: 	Headers             map[string]string `proxy:"headers,omitempty"`
73: 	MaxEarlyData        int               `proxy:"max-early-data,omitempty"`
74: 	EarlyDataHeaderName string            `proxy:"early-data-header-name,omitempty"`
75: }
76: 
77: // StreamConn implements C.ProxyAdapter
78: func (v *Vmess) StreamConn(c net.Conn, metadata *C.Metadata) (net.Conn, error) {
79: 	var err error
80: 	switch v.option.Network {
81: 	case "ws":
82: 		host, port, _ := net.SplitHostPort(v.addr)
83: 		wsOpts := &vmess.WebsocketConfig{
84: 			Host:                host,
85: 			Port:                port,
86: 			Path:                v.option.WSOpts.Path,
87: 			MaxEarlyData:        v.option.WSOpts.MaxEarlyData,
88: 			EarlyDataHeaderName: v.option.WSOpts.EarlyDataHeaderName,
89: 		}
90: 
91: 		if len(v.option.WSOpts.Headers) != 0 {
92: 			header := http.Header{}
93: 			for key, value := range v.option.WSOpts.Headers {
94: 				header.Add(key, value)
95: 			}
96: 			wsOpts.Headers = header
97: 		}
98: 
99: 		if v.option.TLS {
100: 			wsOpts.TLS = true
101: 			wsOpts.TLSConfig = &tls.Config{
102: 				ServerName:         host,
103: 				InsecureSkipVerify: v.option.SkipCertVerify,
104: 				NextProtos:         []string{"http/1.1"},
105: 			}
106: 			if v.option.ServerName != "" {
107: 				wsOpts.TLSConfig.ServerName = v.option.ServerName
108: 			} else if host := wsOpts.Headers.Get("Host"); host != "" {
109: 				wsOpts.TLSConfig.ServerName = host
110: 			}
111: 		}
112: 		c, err = vmess.StreamWebsocketConn(c, wsOpts)
113: 	case "http":
114: 		// readability first, so just copy default TLS logic
115: 		if v.option.TLS {
116: 			host, _, _ := net.SplitHostPort(v.addr)
117: 			tlsOpts := &vmess.TLSConfig{
118: 				Host:           host,
119: 				SkipCertVerify: v.option.SkipCertVerify,
120: 			}
121: 
122: 			if v.option.ServerName != "" {
123: 				tlsOpts.Host = v.option.ServerName
124: 			}
125: 
126: 			c, err = vmess.StreamTLSConn(c, tlsOpts)
127: 			if err != nil {
128: 				return nil, err
129: 			}
130: 		}
131: 
132: 		host, _, _ := net.SplitHostPort(v.addr)
133: 		httpOpts := &vmess.HTTPConfig{
134: 			Host:    host,
135: 			Method:  v.option.HTTPOpts.Method,
136: 			Path:    v.option.HTTPOpts.Path,
137: 			Headers: v.option.HTTPOpts.Headers,
138: 		}
139: 
140: 		c = vmess.StreamHTTPConn(c, httpOpts)
141: 	case "h2":
142: 		host, _, _ := net.SplitHostPort(v.addr)
143: 		tlsOpts := vmess.TLSConfig{
144: 			Host:           host,
145: 			SkipCertVerify: v.option.SkipCertVerify,
146: 			NextProtos:     []string{"h2"},
147: 		}
148: 
149: 		if v.option.ServerName != "" {
150: 			tlsOpts.Host = v.option.ServerName
151: 		}
152: 
153: 		c, err = vmess.StreamTLSConn(c, &tlsOpts)
154: 		if err != nil {
155: 			return nil, err
156: 		}
157: 
158: 		h2Opts := &vmess.H2Config{
159: 			Hosts: v.option.HTTP2Opts.Host,
160: 			Path:  v.option.HTTP2Opts.Path,
161: 		}
162: 
163: 		c, err = vmess.StreamH2Conn(c, h2Opts)
164: 	case "grpc":
165: 		c, err = gun.StreamGunWithConn(c, v.gunTLSConfig, v.gunConfig)
166: 	default:
167: 		// handle TLS
168: 		if v.option.TLS {
169: 			host, _, _ := net.SplitHostPort(v.addr)
170: 			tlsOpts := &vmess.TLSConfig{
171: 				Host:           host,
172: 				SkipCertVerify: v.option.SkipCertVerify,
173: 			}
174: 
175: 			if v.option.ServerName != "" {
176: 				tlsOpts.Host = v.option.ServerName
177: 			}
178: 
179: 			c, err = vmess.StreamTLSConn(c, tlsOpts)
180: 		}
181: 	}
182: 
183: 	if err != nil {
184: 		return nil, err
185: 	}
186: 
187: 	return v.client.StreamConn(c, parseVmessAddr(metadata))
188: }
189: 
190: // DialContext implements C.ProxyAdapter
191: func (v *Vmess) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.Conn, err error) {
192: 	// gun transport
193: 	if v.transport != nil && len(opts) == 0 {
194: 		c, err := gun.StreamGunWithTransport(v.transport, v.gunConfig)
195: 		if err != nil {
196: 			return nil, err
197: 		}
198: 		defer func(c net.Conn) {
199: 			safeConnClose(c, err)
200: 		}(c)
201: 
202: 		c, err = v.client.StreamConn(c, parseVmessAddr(metadata))
203: 		if err != nil {
204: 			return nil, err
205: 		}
206: 
207: 		return NewConn(c, v), nil
208: 	}
209: 
210: 	c, err := dialer.DialContext(ctx, "tcp", v.addr, v.Base.DialOptions(opts...)...)
211: 	if err != nil {
212: 		return nil, fmt.Errorf("%s connect error: %s", v.addr, err.Error())
213: 	}
214: 	tcpKeepAlive(c)
215: 	defer func(c net.Conn) {
216: 		safeConnClose(c, err)
217: 	}(c)
218: 
219: 	c, err = v.StreamConn(c, metadata)
220: 	return NewConn(c, v), err
221: }
222: 
223: // ListenPacketContext implements C.ProxyAdapter
224: func (v *Vmess) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (_ C.PacketConn, err error) {
225: 	// vmess use stream-oriented udp with a special address, so we needs a net.UDPAddr
226: 	if !metadata.Resolved() {
227: 		ip, err := resolver.ResolveIP(metadata.Host)
228: 		if err != nil {
229: 			return nil, errors.New("can't resolve ip")
230: 		}
231: 		metadata.DstIP = ip
232: 	}
233: 
234: 	var c net.Conn
235: 	// gun transport
236: 	if v.transport != nil && len(opts) == 0 {
237: 		c, err = gun.StreamGunWithTransport(v.transport, v.gunConfig)
238: 		if err != nil {
239: 			return nil, err
240: 		}
241: 		defer func(c net.Conn) {
242: 			safeConnClose(c, err)
243: 		}(c)
244: 
245: 		c, err = v.client.StreamConn(c, parseVmessAddr(metadata))
246: 	} else {
247: 		c, err = dialer.DialContext(ctx, "tcp", v.addr, v.Base.DialOptions(opts...)...)
248: 		if err != nil {
249: 			return nil, fmt.Errorf("%s connect error: %s", v.addr, err.Error())
250: 		}
251: 		tcpKeepAlive(c)
252: 		defer func(c net.Conn) {
253: 			safeConnClose(c, err)
254: 		}(c)
255: 
256: 		c, err = v.StreamConn(c, metadata)
257: 	}
258: 
259: 	if err != nil {
260: 		return nil, fmt.Errorf("new vmess client error: %v", err)
261: 	}
262: 
263: 	return newPacketConn(&vmessPacketConn{Conn: c, rAddr: metadata.UDPAddr()}, v), nil
264: }
265: 
266: func NewVmess(option VmessOption) (*Vmess, error) {
267: 	return newVmess(option, false)
268: }
269: 
270: func newVmess(option VmessOption, isVless bool) (*Vmess, error) {
271: 	security := strings.ToLower(option.Cipher)
272: 	if security == "" {
273: 		security = "auto"
274: 	}
275: 	client, err := vmess.NewClient(vmess.Config{
276: 		UUID:     option.UUID,
277: 		AlterID:  uint16(option.AlterID),
278: 		Security: security,
279: 		HostName: option.Server,
280: 		Port:     strconv.Itoa(option.Port),
281: 		IsAead:   option.AlterID == 0,
282: 		IsVless:  isVless,
283: 	})
284: 	if err != nil {
285: 		return nil, err
286: 	}
287: 
288: 	switch option.Network {
289: 	case "h2", "grpc":
290: 		if !option.TLS {
291: 			return nil, fmt.Errorf("TLS must be true with h2/grpc network")
292: 		}
293: 	}
294: 
295: 	tp := C.Vmess
296: 	if isVless {
297: 		tp = C.Vless
298: 	}
299: 
300: 	v := &Vmess{
301: 		Base: &Base{
302: 			name:  option.Name,
303: 			addr:  net.JoinHostPort(option.Server, strconv.Itoa(option.Port)),
304: 			tp:    tp,
305: 			udp:   option.UDP,
306: 			iface: option.Interface,
307: 			rmark: option.RoutingMark,
308: 		},
309: 		client: client,
310: 		option: &option,
311: 	}
312: 
313: 	switch option.Network {
314: 	case "h2":
315: 		if len(option.HTTP2Opts.Host) == 0 {
316: 			option.HTTP2Opts.Host = append(option.HTTP2Opts.Host, "www.example.com")
317: 		}
318: 	case "grpc":
319: 		dialFn := func(network, addr string) (net.Conn, error) {
320: 			c, err := dialer.DialContext(context.Background(), "tcp", v.addr, v.Base.DialOptions()...)
321: 			if err != nil {
322: 				return nil, fmt.Errorf("%s connect error: %s", v.addr, err.Error())
323: 			}
324: 			tcpKeepAlive(c)
325: 			return c, nil
326: 		}
327: 
328: 		gunConfig := &gun.Config{
329: 			ServiceName: v.option.GrpcOpts.GrpcServiceName,
330: 			Host:        v.option.ServerName,
331: 		}
332: 		tlsConfig := &tls.Config{
333: 			InsecureSkipVerify: v.option.SkipCertVerify,
334: 			ServerName:         v.option.ServerName,
335: 		}
336: 
337: 		if v.option.ServerName == "" {
338: 			host, _, _ := net.SplitHostPort(v.addr)
339: 			tlsConfig.ServerName = host
340: 			gunConfig.Host = host
341: 		}
342: 
343: 		v.gunTLSConfig = tlsConfig
344: 		v.gunConfig = gunConfig
345: 		v.transport = gun.NewHTTP2Client(dialFn, tlsConfig)
346: 	}
347: 
348: 	return v, nil
349: }
350: 
351: func parseVmessAddr(metadata *C.Metadata) *vmess.DstAddr {
352: 	var addrType byte
353: 	var addr []byte
354: 	switch metadata.AddrType() {
355: 	case socks5.AtypIPv4:
356: 		addrType = vmess.AtypIPv4
357: 		addr = make([]byte, net.IPv4len)
358: 		copy(addr[:], metadata.DstIP.To4())
359: 	case socks5.AtypIPv6:
360: 		addrType = vmess.AtypIPv6
361: 		addr = make([]byte, net.IPv6len)
362: 		copy(addr[:], metadata.DstIP.To16())
363: 	case socks5.AtypDomainName:
364: 		addrType = vmess.AtypDomainName
365: 		addr = make([]byte, len(metadata.Host)+1)
366: 		addr[0] = byte(len(metadata.Host))
367: 		copy(addr[1:], []byte(metadata.Host))
368: 	}
369: 
370: 	return &vmess.DstAddr{
371: 		UDP:      metadata.NetWork == C.UDP,
372: 		AddrType: addrType,
373: 		Addr:     addr,
374: 		Port:     uint(metadata.DstPort),
375: 	}
376: }
377: 
378: type vmessPacketConn struct {
379: 	net.Conn
380: 	rAddr net.Addr
381: }
382: 
383: // WriteTo implments C.PacketConn.WriteTo
384: // Since VMess doesn't support full cone NAT by design, we verify if addr matches uc.rAddr, and drop the packet if not.
385: func (uc *vmessPacketConn) WriteTo(b []byte, addr net.Addr) (int, error) {
386: 	allowedAddr := uc.rAddr.(*net.UDPAddr)
387: 	destAddr := addr.(*net.UDPAddr)
388: 	if !(allowedAddr.IP.Equal(destAddr.IP) && allowedAddr.Port == destAddr.Port) {
389: 		return 0, ErrUDPRemoteAddrMismatch
390: 	}
391: 	return uc.Conn.Write(b)
392: }
393: 
394: func (uc *vmessPacketConn) ReadFrom(b []byte) (int, net.Addr, error) {
395: 	n, err := uc.Conn.Read(b)
396: 	return n, uc.rAddr, err
397: }


./adapter\outboundgroup\common.go
1: package outboundgroup
2: 
3: import (
4: 	"time"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: 	"github.com/Dreamacro/clash/constant/provider"
8: )
9: 
10: const (
11: 	defaultGetProxiesDuration = time.Second * 5
12: )
13: 
14: func touchProviders(providers []provider.ProxyProvider) {
15: 	for _, provider := range providers {
16: 		provider.Touch()
17: 	}
18: }
19: 
20: func getProvidersProxies(providers []provider.ProxyProvider, touch bool) []C.Proxy {
21: 	proxies := []C.Proxy{}
22: 	for _, provider := range providers {
23: 		if touch {
24: 			provider.Touch()
25: 		}
26: 		proxies = append(proxies, provider.Proxies()...)
27: 	}
28: 	return proxies
29: }


./adapter\outboundgroup\fallback.go
1: package outboundgroup
2: 
3: import (
4: 	"context"
5: 	"encoding/json"
6: 
7: 	"github.com/Dreamacro/clash/adapter/outbound"
8: 	"github.com/Dreamacro/clash/common/singledo"
9: 	"github.com/Dreamacro/clash/component/dialer"
10: 	C "github.com/Dreamacro/clash/constant"
11: 	"github.com/Dreamacro/clash/constant/provider"
12: )
13: 
14: type Fallback struct {
15: 	*outbound.Base
16: 	disableUDP bool
17: 	single     *singledo.Single
18: 	providers  []provider.ProxyProvider
19: }
20: 
21: func (f *Fallback) Now() string {
22: 	proxy := f.findAliveProxy(false)
23: 	return proxy.Name()
24: }
25: 
26: // DialContext implements C.ProxyAdapter
27: func (f *Fallback) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.Conn, error) {
28: 	proxy := f.findAliveProxy(true)
29: 	c, err := proxy.DialContext(ctx, metadata, f.Base.DialOptions(opts...)...)
30: 	if err == nil {
31: 		c.AppendToChains(f)
32: 	}
33: 	return c, err
34: }
35: 
36: // ListenPacketContext implements C.ProxyAdapter
37: func (f *Fallback) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
38: 	proxy := f.findAliveProxy(true)
39: 	pc, err := proxy.ListenPacketContext(ctx, metadata, f.Base.DialOptions(opts...)...)
40: 	if err == nil {
41: 		pc.AppendToChains(f)
42: 	}
43: 	return pc, err
44: }
45: 
46: // SupportUDP implements C.ProxyAdapter
47: func (f *Fallback) SupportUDP() bool {
48: 	if f.disableUDP {
49: 		return false
50: 	}
51: 
52: 	proxy := f.findAliveProxy(false)
53: 	return proxy.SupportUDP()
54: }
55: 
56: // MarshalJSON implements C.ProxyAdapter
57: func (f *Fallback) MarshalJSON() ([]byte, error) {
58: 	var all []string
59: 	for _, proxy := range f.proxies(false) {
60: 		all = append(all, proxy.Name())
61: 	}
62: 	return json.Marshal(map[string]any{
63: 		"type": f.Type().String(),
64: 		"now":  f.Now(),
65: 		"all":  all,
66: 	})
67: }
68: 
69: // Unwrap implements C.ProxyAdapter
70: func (f *Fallback) Unwrap(metadata *C.Metadata) C.Proxy {
71: 	proxy := f.findAliveProxy(true)
72: 	return proxy
73: }
74: 
75: func (f *Fallback) proxies(touch bool) []C.Proxy {
76: 	elm, _, _ := f.single.Do(func() (any, error) {
77: 		return getProvidersProxies(f.providers, touch), nil
78: 	})
79: 
80: 	return elm.([]C.Proxy)
81: }
82: 
83: func (f *Fallback) findAliveProxy(touch bool) C.Proxy {
84: 	proxies := f.proxies(touch)
85: 	for _, proxy := range proxies {
86: 		if proxy.Alive() {
87: 			return proxy
88: 		}
89: 	}
90: 
91: 	return proxies[0]
92: }
93: 
94: func NewFallback(option *GroupCommonOption, providers []provider.ProxyProvider) *Fallback {
95: 	return &Fallback{
96: 		Base: outbound.NewBase(outbound.BaseOption{
97: 			Name:        option.Name,
98: 			Type:        C.Fallback,
99: 			Interface:   option.Interface,
100: 			RoutingMark: option.RoutingMark,
101: 		}),
102: 		single:     singledo.NewSingle(defaultGetProxiesDuration),
103: 		providers:  providers,
104: 		disableUDP: option.DisableUDP,
105: 	}
106: }


./adapter\outboundgroup\loadbalance.go
1: package outboundgroup
2: 
3: import (
4: 	"context"
5: 	"encoding/json"
6: 	"errors"
7: 	"fmt"
8: 	"net"
9: 
10: 	"github.com/Dreamacro/clash/adapter/outbound"
11: 	"github.com/Dreamacro/clash/common/murmur3"
12: 	"github.com/Dreamacro/clash/common/singledo"
13: 	"github.com/Dreamacro/clash/component/dialer"
14: 	C "github.com/Dreamacro/clash/constant"
15: 	"github.com/Dreamacro/clash/constant/provider"
16: 
17: 	"golang.org/x/net/publicsuffix"
18: )
19: 
20: type strategyFn = func(proxies []C.Proxy, metadata *C.Metadata) C.Proxy
21: 
22: type LoadBalance struct {
23: 	*outbound.Base
24: 	disableUDP bool
25: 	single     *singledo.Single
26: 	providers  []provider.ProxyProvider
27: 	strategyFn strategyFn
28: }
29: 
30: var errStrategy = errors.New("unsupported strategy")
31: 
32: func parseStrategy(config map[string]any) string {
33: 	if strategy, ok := config["strategy"].(string); ok {
34: 		return strategy
35: 	}
36: 	return "consistent-hashing"
37: }
38: 
39: func getKey(metadata *C.Metadata) string {
40: 	if metadata.Host != "" {
41: 		// ip host
42: 		if ip := net.ParseIP(metadata.Host); ip != nil {
43: 			return metadata.Host
44: 		}
45: 
46: 		if etld, err := publicsuffix.EffectiveTLDPlusOne(metadata.Host); err == nil {
47: 			return etld
48: 		}
49: 	}
50: 
51: 	if metadata.DstIP == nil {
52: 		return ""
53: 	}
54: 
55: 	return metadata.DstIP.String()
56: }
57: 
58: func jumpHash(key uint64, buckets int32) int32 {
59: 	var b, j int64
60: 
61: 	for j < int64(buckets) {
62: 		b = j
63: 		key = key*2862933555777941757 + 1
64: 		j = int64(float64(b+1) * (float64(int64(1)<<31) / float64((key>>33)+1)))
65: 	}
66: 
67: 	return int32(b)
68: }
69: 
70: // DialContext implements C.ProxyAdapter
71: func (lb *LoadBalance) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (c C.Conn, err error) {
72: 	defer func() {
73: 		if err == nil {
74: 			c.AppendToChains(lb)
75: 		}
76: 	}()
77: 
78: 	proxy := lb.Unwrap(metadata)
79: 
80: 	c, err = proxy.DialContext(ctx, metadata, lb.Base.DialOptions(opts...)...)
81: 	return
82: }
83: 
84: // ListenPacketContext implements C.ProxyAdapter
85: func (lb *LoadBalance) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (pc C.PacketConn, err error) {
86: 	defer func() {
87: 		if err == nil {
88: 			pc.AppendToChains(lb)
89: 		}
90: 	}()
91: 
92: 	proxy := lb.Unwrap(metadata)
93: 	return proxy.ListenPacketContext(ctx, metadata, lb.Base.DialOptions(opts...)...)
94: }
95: 
96: // SupportUDP implements C.ProxyAdapter
97: func (lb *LoadBalance) SupportUDP() bool {
98: 	return !lb.disableUDP
99: }
100: 
101: func strategyRoundRobin() strategyFn {
102: 	idx := 0
103: 	return func(proxies []C.Proxy, metadata *C.Metadata) C.Proxy {
104: 		length := len(proxies)
105: 		for i := 0; i < length; i++ {
106: 			idx = (idx + 1) % length
107: 			proxy := proxies[idx]
108: 			if proxy.Alive() {
109: 				return proxy
110: 			}
111: 		}
112: 
113: 		return proxies[0]
114: 	}
115: }
116: 
117: func strategyConsistentHashing() strategyFn {
118: 	maxRetry := 5
119: 	return func(proxies []C.Proxy, metadata *C.Metadata) C.Proxy {
120: 		key := uint64(murmur3.Sum32([]byte(getKey(metadata))))
121: 		buckets := int32(len(proxies))
122: 		for i := 0; i < maxRetry; i, key = i+1, key+1 {
123: 			idx := jumpHash(key, buckets)
124: 			proxy := proxies[idx]
125: 			if proxy.Alive() {
126: 				return proxy
127: 			}
128: 		}
129: 
130: 		// when availability is poor, traverse the entire list to get the available nodes
131: 		for _, proxy := range proxies {
132: 			if proxy.Alive() {
133: 				return proxy
134: 			}
135: 		}
136: 
137: 		return proxies[0]
138: 	}
139: }
140: 
141: // Unwrap implements C.ProxyAdapter
142: func (lb *LoadBalance) Unwrap(metadata *C.Metadata) C.Proxy {
143: 	proxies := lb.proxies(true)
144: 	return lb.strategyFn(proxies, metadata)
145: }
146: 
147: func (lb *LoadBalance) proxies(touch bool) []C.Proxy {
148: 	elm, _, _ := lb.single.Do(func() (any, error) {
149: 		return getProvidersProxies(lb.providers, touch), nil
150: 	})
151: 
152: 	return elm.([]C.Proxy)
153: }
154: 
155: // MarshalJSON implements C.ProxyAdapter
156: func (lb *LoadBalance) MarshalJSON() ([]byte, error) {
157: 	var all []string
158: 	for _, proxy := range lb.proxies(false) {
159: 		all = append(all, proxy.Name())
160: 	}
161: 	return json.Marshal(map[string]any{
162: 		"type": lb.Type().String(),
163: 		"all":  all,
164: 	})
165: }
166: 
167: func NewLoadBalance(option *GroupCommonOption, providers []provider.ProxyProvider, strategy string) (lb *LoadBalance, err error) {
168: 	var strategyFn strategyFn
169: 	switch strategy {
170: 	case "consistent-hashing":
171: 		strategyFn = strategyConsistentHashing()
172: 	case "round-robin":
173: 		strategyFn = strategyRoundRobin()
174: 	default:
175: 		return nil, fmt.Errorf("%w: %s", errStrategy, strategy)
176: 	}
177: 	return &LoadBalance{
178: 		Base: outbound.NewBase(outbound.BaseOption{
179: 			Name:        option.Name,
180: 			Type:        C.LoadBalance,
181: 			Interface:   option.Interface,
182: 			RoutingMark: option.RoutingMark,
183: 		}),
184: 		single:     singledo.NewSingle(defaultGetProxiesDuration),
185: 		providers:  providers,
186: 		strategyFn: strategyFn,
187: 		disableUDP: option.DisableUDP,
188: 	}, nil
189: }


./adapter\outboundgroup\parser.go
1: package outboundgroup
2: 
3: import (
4: 	"errors"
5: 	"fmt"
6: 
7: 	"github.com/Dreamacro/clash/adapter/outbound"
8: 	"github.com/Dreamacro/clash/adapter/provider"
9: 	"github.com/Dreamacro/clash/common/structure"
10: 	C "github.com/Dreamacro/clash/constant"
11: 	types "github.com/Dreamacro/clash/constant/provider"
12: 
13: 	regexp "github.com/dlclark/regexp2"
14: )
15: 
16: var (
17: 	errFormat            = errors.New("format error")
18: 	errType              = errors.New("unsupport type")
19: 	errMissProxy         = errors.New("`use` or `proxies` missing")
20: 	errMissHealthCheck   = errors.New("`url` or `interval` missing")
21: 	errDuplicateProvider = errors.New("duplicate provider name")
22: )
23: 
24: type GroupCommonOption struct {
25: 	outbound.BasicOption
26: 	Name       string   `group:"name"`
27: 	Type       string   `group:"type"`
28: 	Proxies    []string `group:"proxies,omitempty"`
29: 	Use        []string `group:"use,omitempty"`
30: 	URL        string   `group:"url,omitempty"`
31: 	Interval   int      `group:"interval,omitempty"`
32: 	Lazy       bool     `group:"lazy,omitempty"`
33: 	DisableUDP bool     `group:"disable-udp,omitempty"`
34: 	Filter     string   `group:"filter,omitempty"`
35: }
36: 
37: func ParseProxyGroup(config map[string]any, proxyMap map[string]C.Proxy, providersMap map[string]types.ProxyProvider) (C.ProxyAdapter, error) {
38: 	decoder := structure.NewDecoder(structure.Option{TagName: "group", WeaklyTypedInput: true})
39: 
40: 	groupOption := &GroupCommonOption{
41: 		Lazy: true,
42: 	}
43: 	if err := decoder.Decode(config, groupOption); err != nil {
44: 		return nil, errFormat
45: 	}
46: 
47: 	if groupOption.Type == "" || groupOption.Name == "" {
48: 		return nil, errFormat
49: 	}
50: 
51: 	var (
52: 		groupName = groupOption.Name
53: 		filterReg *regexp.Regexp
54: 	)
55: 
56: 	if groupOption.Filter != "" {
57: 		f, err := regexp.Compile(groupOption.Filter, regexp.None)
58: 		if err != nil {
59: 			return nil, fmt.Errorf("%s: invalid filter regex: %w", groupName, err)
60: 		}
61: 		filterReg = f
62: 	}
63: 
64: 	if len(groupOption.Proxies) == 0 && len(groupOption.Use) == 0 {
65: 		return nil, fmt.Errorf("%s: %w", groupName, errMissProxy)
66: 	}
67: 
68: 	providers := []types.ProxyProvider{}
69: 
70: 	if len(groupOption.Proxies) != 0 {
71: 		ps, err := getProxies(proxyMap, groupOption.Proxies)
72: 		if err != nil {
73: 			return nil, fmt.Errorf("%s: %w", groupName, err)
74: 		}
75: 
76: 		if _, ok := providersMap[groupName]; ok {
77: 			return nil, fmt.Errorf("%s: %w", groupName, errDuplicateProvider)
78: 		}
79: 
80: 		// select don't need health check
81: 		if groupOption.Type == "select" || groupOption.Type == "relay" {
82: 			hc := provider.NewHealthCheck(ps, "", 0, true)
83: 			pd, err := provider.NewCompatibleProvider(groupName, ps, hc)
84: 			if err != nil {
85: 				return nil, fmt.Errorf("%s: %w", groupName, err)
86: 			}
87: 
88: 			providers = append(providers, pd)
89: 			providersMap[groupName] = pd
90: 		} else {
91: 			if groupOption.URL == "" || groupOption.Interval == 0 {
92: 				return nil, fmt.Errorf("%s: %w", groupName, errMissHealthCheck)
93: 			}
94: 
95: 			hc := provider.NewHealthCheck(ps, groupOption.URL, uint(groupOption.Interval), groupOption.Lazy)
96: 			pd, err := provider.NewCompatibleProvider(groupName, ps, hc)
97: 			if err != nil {
98: 				return nil, fmt.Errorf("%s: %w", groupName, err)
99: 			}
100: 
101: 			providers = append(providers, pd)
102: 			providersMap[groupName] = pd
103: 		}
104: 	}
105: 
106: 	if len(groupOption.Use) != 0 {
107: 		list, err := getProviders(providersMap, groupOption.Use)
108: 		if err != nil {
109: 			return nil, fmt.Errorf("%s: %w", groupName, err)
110: 		}
111: 		if filterReg != nil {
112: 			pd := provider.NewFilterableProvider(groupName, list, filterReg)
113: 			providers = append(providers, pd)
114: 		} else {
115: 			providers = append(providers, list...)
116: 		}
117: 	}
118: 
119: 	var group C.ProxyAdapter
120: 	switch groupOption.Type {
121: 	case "url-test":
122: 		opts := parseURLTestOption(config)
123: 		group = NewURLTest(groupOption, providers, opts...)
124: 	case "select":
125: 		group = NewSelector(groupOption, providers)
126: 	case "fallback":
127: 		group = NewFallback(groupOption, providers)
128: 	case "load-balance":
129: 		strategy := parseStrategy(config)
130: 		return NewLoadBalance(groupOption, providers, strategy)
131: 	case "relay":
132: 		group = NewRelay(groupOption, providers)
133: 	default:
134: 		return nil, fmt.Errorf("%s %w: %s", groupName, errType, groupOption.Type)
135: 	}
136: 
137: 	return group, nil
138: }
139: 
140: func getProxies(mapping map[string]C.Proxy, list []string) ([]C.Proxy, error) {
141: 	var ps []C.Proxy
142: 	for _, name := range list {
143: 		p, ok := mapping[name]
144: 		if !ok {
145: 			return nil, fmt.Errorf("'%s' not found", name)
146: 		}
147: 		ps = append(ps, p)
148: 	}
149: 	return ps, nil
150: }
151: 
152: func getProviders(mapping map[string]types.ProxyProvider, list []string) ([]types.ProxyProvider, error) {
153: 	var ps []types.ProxyProvider
154: 	for _, name := range list {
155: 		p, ok := mapping[name]
156: 		if !ok {
157: 			return nil, fmt.Errorf("'%s' not found", name)
158: 		}
159: 
160: 		if p.VehicleType() == types.Compatible {
161: 			return nil, fmt.Errorf("proxy group %s can't contains in `use`", name)
162: 		}
163: 		ps = append(ps, p)
164: 	}
165: 	return ps, nil
166: }


./adapter\outboundgroup\relay.go
1: package outboundgroup
2: 
3: import (
4: 	"context"
5: 	"encoding/json"
6: 	"fmt"
7: 
8: 	"github.com/Dreamacro/clash/adapter/outbound"
9: 	"github.com/Dreamacro/clash/common/singledo"
10: 	"github.com/Dreamacro/clash/component/dialer"
11: 	C "github.com/Dreamacro/clash/constant"
12: 	"github.com/Dreamacro/clash/constant/provider"
13: )
14: 
15: type Relay struct {
16: 	*outbound.Base
17: 	single    *singledo.Single
18: 	providers []provider.ProxyProvider
19: }
20: 
21: // DialContext implements C.ProxyAdapter
22: func (r *Relay) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.Conn, error) {
23: 	var proxies []C.Proxy
24: 	for _, proxy := range r.proxies(metadata, true) {
25: 		if proxy.Type() != C.Direct {
26: 			proxies = append(proxies, proxy)
27: 		}
28: 	}
29: 
30: 	switch len(proxies) {
31: 	case 0:
32: 		return outbound.NewDirect().DialContext(ctx, metadata, r.Base.DialOptions(opts...)...)
33: 	case 1:
34: 		return proxies[0].DialContext(ctx, metadata, r.Base.DialOptions(opts...)...)
35: 	}
36: 
37: 	first := proxies[0]
38: 	last := proxies[len(proxies)-1]
39: 
40: 	c, err := dialer.DialContext(ctx, "tcp", first.Addr(), r.Base.DialOptions(opts...)...)
41: 	if err != nil {
42: 		return nil, fmt.Errorf("%s connect error: %w", first.Addr(), err)
43: 	}
44: 	tcpKeepAlive(c)
45: 
46: 	var currentMeta *C.Metadata
47: 	for _, proxy := range proxies[1:] {
48: 		currentMeta, err = addrToMetadata(proxy.Addr())
49: 		if err != nil {
50: 			return nil, err
51: 		}
52: 
53: 		c, err = first.StreamConn(c, currentMeta)
54: 		if err != nil {
55: 			return nil, fmt.Errorf("%s connect error: %w", first.Addr(), err)
56: 		}
57: 
58: 		first = proxy
59: 	}
60: 
61: 	c, err = last.StreamConn(c, metadata)
62: 	if err != nil {
63: 		return nil, fmt.Errorf("%s connect error: %w", last.Addr(), err)
64: 	}
65: 
66: 	return outbound.NewConn(c, r), nil
67: }
68: 
69: // MarshalJSON implements C.ProxyAdapter
70: func (r *Relay) MarshalJSON() ([]byte, error) {
71: 	var all []string
72: 	for _, proxy := range r.rawProxies(false) {
73: 		all = append(all, proxy.Name())
74: 	}
75: 	return json.Marshal(map[string]any{
76: 		"type": r.Type().String(),
77: 		"all":  all,
78: 	})
79: }
80: 
81: func (r *Relay) rawProxies(touch bool) []C.Proxy {
82: 	elm, _, _ := r.single.Do(func() (any, error) {
83: 		return getProvidersProxies(r.providers, touch), nil
84: 	})
85: 
86: 	return elm.([]C.Proxy)
87: }
88: 
89: func (r *Relay) proxies(metadata *C.Metadata, touch bool) []C.Proxy {
90: 	proxies := r.rawProxies(touch)
91: 
92: 	for n, proxy := range proxies {
93: 		subproxy := proxy.Unwrap(metadata)
94: 		for subproxy != nil {
95: 			proxies[n] = subproxy
96: 			subproxy = subproxy.Unwrap(metadata)
97: 		}
98: 	}
99: 
100: 	return proxies
101: }
102: 
103: func NewRelay(option *GroupCommonOption, providers []provider.ProxyProvider) *Relay {
104: 	return &Relay{
105: 		Base: outbound.NewBase(outbound.BaseOption{
106: 			Name:        option.Name,
107: 			Type:        C.Relay,
108: 			Interface:   option.Interface,
109: 			RoutingMark: option.RoutingMark,
110: 		}),
111: 		single:    singledo.NewSingle(defaultGetProxiesDuration),
112: 		providers: providers,
113: 	}
114: }


./adapter\outboundgroup\selector.go
1: package outboundgroup
2: 
3: import (
4: 	"context"
5: 	"encoding/json"
6: 	"errors"
7: 
8: 	"github.com/Dreamacro/clash/adapter/outbound"
9: 	"github.com/Dreamacro/clash/common/singledo"
10: 	"github.com/Dreamacro/clash/component/dialer"
11: 	C "github.com/Dreamacro/clash/constant"
12: 	"github.com/Dreamacro/clash/constant/provider"
13: )
14: 
15: type Selector struct {
16: 	*outbound.Base
17: 	disableUDP bool
18: 	single     *singledo.Single
19: 	selected   string
20: 	providers  []provider.ProxyProvider
21: }
22: 
23: // DialContext implements C.ProxyAdapter
24: func (s *Selector) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.Conn, error) {
25: 	c, err := s.selectedProxy(true).DialContext(ctx, metadata, s.Base.DialOptions(opts...)...)
26: 	if err == nil {
27: 		c.AppendToChains(s)
28: 	}
29: 	return c, err
30: }
31: 
32: // ListenPacketContext implements C.ProxyAdapter
33: func (s *Selector) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
34: 	pc, err := s.selectedProxy(true).ListenPacketContext(ctx, metadata, s.Base.DialOptions(opts...)...)
35: 	if err == nil {
36: 		pc.AppendToChains(s)
37: 	}
38: 	return pc, err
39: }
40: 
41: // SupportUDP implements C.ProxyAdapter
42: func (s *Selector) SupportUDP() bool {
43: 	if s.disableUDP {
44: 		return false
45: 	}
46: 
47: 	return s.selectedProxy(false).SupportUDP()
48: }
49: 
50: // MarshalJSON implements C.ProxyAdapter
51: func (s *Selector) MarshalJSON() ([]byte, error) {
52: 	var all []string
53: 	for _, proxy := range getProvidersProxies(s.providers, false) {
54: 		all = append(all, proxy.Name())
55: 	}
56: 
57: 	return json.Marshal(map[string]any{
58: 		"type": s.Type().String(),
59: 		"now":  s.Now(),
60: 		"all":  all,
61: 	})
62: }
63: 
64: func (s *Selector) Now() string {
65: 	return s.selectedProxy(false).Name()
66: }
67: 
68: func (s *Selector) Set(name string) error {
69: 	for _, proxy := range getProvidersProxies(s.providers, false) {
70: 		if proxy.Name() == name {
71: 			s.selected = name
72: 			s.single.Reset()
73: 			return nil
74: 		}
75: 	}
76: 
77: 	return errors.New("proxy not exist")
78: }
79: 
80: // Unwrap implements C.ProxyAdapter
81: func (s *Selector) Unwrap(metadata *C.Metadata) C.Proxy {
82: 	return s.selectedProxy(true)
83: }
84: 
85: func (s *Selector) selectedProxy(touch bool) C.Proxy {
86: 	elm, _, _ := s.single.Do(func() (any, error) {
87: 		proxies := getProvidersProxies(s.providers, touch)
88: 		for _, proxy := range proxies {
89: 			if proxy.Name() == s.selected {
90: 				return proxy, nil
91: 			}
92: 		}
93: 
94: 		return proxies[0], nil
95: 	})
96: 
97: 	return elm.(C.Proxy)
98: }
99: 
100: func NewSelector(option *GroupCommonOption, providers []provider.ProxyProvider) *Selector {
101: 	selected := providers[0].Proxies()[0].Name()
102: 	return &Selector{
103: 		Base: outbound.NewBase(outbound.BaseOption{
104: 			Name:        option.Name,
105: 			Type:        C.Selector,
106: 			Interface:   option.Interface,
107: 			RoutingMark: option.RoutingMark,
108: 		}),
109: 		single:     singledo.NewSingle(defaultGetProxiesDuration),
110: 		providers:  providers,
111: 		selected:   selected,
112: 		disableUDP: option.DisableUDP,
113: 	}
114: }


./adapter\outboundgroup\urltest.go
1: package outboundgroup
2: 
3: import (
4: 	"context"
5: 	"encoding/json"
6: 	"time"
7: 
8: 	"github.com/Dreamacro/clash/adapter/outbound"
9: 	"github.com/Dreamacro/clash/common/singledo"
10: 	"github.com/Dreamacro/clash/component/dialer"
11: 	C "github.com/Dreamacro/clash/constant"
12: 	"github.com/Dreamacro/clash/constant/provider"
13: )
14: 
15: type urlTestOption func(*URLTest)
16: 
17: func urlTestWithTolerance(tolerance uint16) urlTestOption {
18: 	return func(u *URLTest) {
19: 		u.tolerance = tolerance
20: 	}
21: }
22: 
23: type URLTest struct {
24: 	*outbound.Base
25: 	tolerance  uint16
26: 	disableUDP bool
27: 	fastNode   C.Proxy
28: 	single     *singledo.Single
29: 	fastSingle *singledo.Single
30: 	providers  []provider.ProxyProvider
31: }
32: 
33: func (u *URLTest) Now() string {
34: 	return u.fast(false).Name()
35: }
36: 
37: // DialContext implements C.ProxyAdapter
38: func (u *URLTest) DialContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (c C.Conn, err error) {
39: 	c, err = u.fast(true).DialContext(ctx, metadata, u.Base.DialOptions(opts...)...)
40: 	if err == nil {
41: 		c.AppendToChains(u)
42: 	}
43: 	return c, err
44: }
45: 
46: // ListenPacketContext implements C.ProxyAdapter
47: func (u *URLTest) ListenPacketContext(ctx context.Context, metadata *C.Metadata, opts ...dialer.Option) (C.PacketConn, error) {
48: 	pc, err := u.fast(true).ListenPacketContext(ctx, metadata, u.Base.DialOptions(opts...)...)
49: 	if err == nil {
50: 		pc.AppendToChains(u)
51: 	}
52: 	return pc, err
53: }
54: 
55: // Unwrap implements C.ProxyAdapter
56: func (u *URLTest) Unwrap(metadata *C.Metadata) C.Proxy {
57: 	return u.fast(true)
58: }
59: 
60: func (u *URLTest) proxies(touch bool) []C.Proxy {
61: 	elm, _, _ := u.single.Do(func() (any, error) {
62: 		return getProvidersProxies(u.providers, touch), nil
63: 	})
64: 
65: 	return elm.([]C.Proxy)
66: }
67: 
68: func (u *URLTest) fast(touch bool) C.Proxy {
69: 	elm, _, shared := u.fastSingle.Do(func() (any, error) {
70: 		proxies := u.proxies(touch)
71: 		fast := proxies[0]
72: 		min := fast.LastDelay()
73: 		fastNotExist := true
74: 
75: 		for _, proxy := range proxies[1:] {
76: 			if u.fastNode != nil && proxy.Name() == u.fastNode.Name() {
77: 				fastNotExist = false
78: 			}
79: 
80: 			if !proxy.Alive() {
81: 				continue
82: 			}
83: 
84: 			delay := proxy.LastDelay()
85: 			if delay < min {
86: 				fast = proxy
87: 				min = delay
88: 			}
89: 		}
90: 
91: 		// tolerance
92: 		if u.fastNode == nil || fastNotExist || !u.fastNode.Alive() || u.fastNode.LastDelay() > fast.LastDelay()+u.tolerance {
93: 			u.fastNode = fast
94: 		}
95: 
96: 		return u.fastNode, nil
97: 	})
98: 	if shared && touch { // a shared fastSingle.Do() may cause providers untouched, so we touch them again
99: 		touchProviders(u.providers)
100: 	}
101: 
102: 	return elm.(C.Proxy)
103: }
104: 
105: // SupportUDP implements C.ProxyAdapter
106: func (u *URLTest) SupportUDP() bool {
107: 	if u.disableUDP {
108: 		return false
109: 	}
110: 
111: 	return u.fast(false).SupportUDP()
112: }
113: 
114: // MarshalJSON implements C.ProxyAdapter
115: func (u *URLTest) MarshalJSON() ([]byte, error) {
116: 	var all []string
117: 	for _, proxy := range u.proxies(false) {
118: 		all = append(all, proxy.Name())
119: 	}
120: 	return json.Marshal(map[string]any{
121: 		"type": u.Type().String(),
122: 		"now":  u.Now(),
123: 		"all":  all,
124: 	})
125: }
126: 
127: func parseURLTestOption(config map[string]any) []urlTestOption {
128: 	opts := []urlTestOption{}
129: 
130: 	// tolerance
131: 	if tolerance, ok := config["tolerance"].(int); ok {
132: 		opts = append(opts, urlTestWithTolerance(uint16(tolerance)))
133: 	}
134: 
135: 	return opts
136: }
137: 
138: func NewURLTest(option *GroupCommonOption, providers []provider.ProxyProvider, options ...urlTestOption) *URLTest {
139: 	urlTest := &URLTest{
140: 		Base: outbound.NewBase(outbound.BaseOption{
141: 			Name:        option.Name,
142: 			Type:        C.URLTest,
143: 			Interface:   option.Interface,
144: 			RoutingMark: option.RoutingMark,
145: 		}),
146: 		single:     singledo.NewSingle(defaultGetProxiesDuration),
147: 		fastSingle: singledo.NewSingle(time.Second * 10),
148: 		providers:  providers,
149: 		disableUDP: option.DisableUDP,
150: 	}
151: 
152: 	for _, option := range options {
153: 		option(urlTest)
154: 	}
155: 
156: 	return urlTest
157: }


./adapter\outboundgroup\util.go
1: package outboundgroup
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 	"strconv"
7: 	"time"
8: 
9: 	C "github.com/Dreamacro/clash/constant"
10: )
11: 
12: func addrToMetadata(rawAddress string) (addr *C.Metadata, err error) {
13: 	host, port, err := net.SplitHostPort(rawAddress)
14: 	if err != nil {
15: 		err = fmt.Errorf("addrToMetadata failed: %w", err)
16: 		return
17: 	}
18: 
19: 	ip := net.ParseIP(host)
20: 	p, _ := strconv.ParseUint(port, 10, 16)
21: 	if ip == nil {
22: 		addr = &C.Metadata{
23: 			Host:    host,
24: 			DstIP:   nil,
25: 			DstPort: C.Port(p),
26: 		}
27: 		return
28: 	} else if ip4 := ip.To4(); ip4 != nil {
29: 		addr = &C.Metadata{
30: 			Host:    "",
31: 			DstIP:   ip4,
32: 			DstPort: C.Port(p),
33: 		}
34: 		return
35: 	}
36: 
37: 	addr = &C.Metadata{
38: 		Host:    "",
39: 		DstIP:   ip,
40: 		DstPort: C.Port(p),
41: 	}
42: 	return
43: }
44: 
45: func tcpKeepAlive(c net.Conn) {
46: 	if tcp, ok := c.(*net.TCPConn); ok {
47: 		tcp.SetKeepAlive(true)
48: 		tcp.SetKeepAlivePeriod(30 * time.Second)
49: 	}
50: }


./adapter\provider\fetcher.go
1: package provider
2: 
3: import (
4: 	"bytes"
5: 	"crypto/md5"
6: 	"os"
7: 	"path/filepath"
8: 	"time"
9: 
10: 	types "github.com/Dreamacro/clash/constant/provider"
11: 	"github.com/Dreamacro/clash/log"
12: )
13: 
14: var (
15: 	fileMode os.FileMode = 0o666
16: 	dirMode  os.FileMode = 0o755
17: )
18: 
19: type parser = func([]byte) (any, error)
20: 
21: type fetcher struct {
22: 	name      string
23: 	vehicle   types.Vehicle
24: 	interval  time.Duration
25: 	updatedAt *time.Time
26: 	ticker    *time.Ticker
27: 	done      chan struct{}
28: 	hash      [16]byte
29: 	parser    parser
30: 	onUpdate  func(any)
31: }
32: 
33: func (f *fetcher) Name() string {
34: 	return f.name
35: }
36: 
37: func (f *fetcher) VehicleType() types.VehicleType {
38: 	return f.vehicle.Type()
39: }
40: 
41: func (f *fetcher) Initial() (any, error) {
42: 	var (
43: 		buf               []byte
44: 		err               error
45: 		isLocal           bool
46: 		immediatelyUpdate bool
47: 	)
48: 	if stat, fErr := os.Stat(f.vehicle.Path()); fErr == nil {
49: 		buf, err = os.ReadFile(f.vehicle.Path())
50: 		modTime := stat.ModTime()
51: 		f.updatedAt = &modTime
52: 		isLocal = true
53: 		immediatelyUpdate = time.Since(modTime) > f.interval
54: 	} else {
55: 		buf, err = f.vehicle.Read()
56: 	}
57: 
58: 	if err != nil {
59: 		return nil, err
60: 	}
61: 
62: 	proxies, err := f.parser(buf)
63: 	if err != nil {
64: 		if !isLocal {
65: 			return nil, err
66: 		}
67: 
68: 		// parse local file error, fallback to remote
69: 		buf, err = f.vehicle.Read()
70: 		if err != nil {
71: 			return nil, err
72: 		}
73: 
74: 		proxies, err = f.parser(buf)
75: 		if err != nil {
76: 			return nil, err
77: 		}
78: 
79: 		isLocal = false
80: 	}
81: 
82: 	if f.vehicle.Type() != types.File && !isLocal {
83: 		if err := safeWrite(f.vehicle.Path(), buf); err != nil {
84: 			return nil, err
85: 		}
86: 	}
87: 
88: 	f.hash = md5.Sum(buf)
89: 
90: 	// pull proxies automatically
91: 	if f.ticker != nil {
92: 		go f.pullLoop(immediatelyUpdate)
93: 	}
94: 
95: 	return proxies, nil
96: }
97: 
98: func (f *fetcher) Update() (any, bool, error) {
99: 	buf, err := f.vehicle.Read()
100: 	if err != nil {
101: 		return nil, false, err
102: 	}
103: 
104: 	now := time.Now()
105: 	hash := md5.Sum(buf)
106: 	if bytes.Equal(f.hash[:], hash[:]) {
107: 		f.updatedAt = &now
108: 		os.Chtimes(f.vehicle.Path(), now, now)
109: 		return nil, true, nil
110: 	}
111: 
112: 	proxies, err := f.parser(buf)
113: 	if err != nil {
114: 		return nil, false, err
115: 	}
116: 
117: 	if f.vehicle.Type() != types.File {
118: 		if err := safeWrite(f.vehicle.Path(), buf); err != nil {
119: 			return nil, false, err
120: 		}
121: 	}
122: 
123: 	f.updatedAt = &now
124: 	f.hash = hash
125: 
126: 	return proxies, false, nil
127: }
128: 
129: func (f *fetcher) Destroy() error {
130: 	if f.ticker != nil {
131: 		f.done <- struct{}{}
132: 	}
133: 	return nil
134: }
135: 
136: func (f *fetcher) pullLoop(immediately bool) {
137: 	update := func() {
138: 		elm, same, err := f.Update()
139: 		if err != nil {
140: 			log.Warnln("[Provider] %s pull error: %s", f.Name(), err.Error())
141: 			return
142: 		}
143: 
144: 		if same {
145: 			log.Debugln("[Provider] %s's proxies doesn't change", f.Name())
146: 			return
147: 		}
148: 
149: 		log.Infoln("[Provider] %s's proxies update", f.Name())
150: 		if f.onUpdate != nil {
151: 			f.onUpdate(elm)
152: 		}
153: 	}
154: 
155: 	if immediately {
156: 		update()
157: 	}
158: 
159: 	for {
160: 		select {
161: 		case <-f.ticker.C:
162: 			update()
163: 		case <-f.done:
164: 			f.ticker.Stop()
165: 			return
166: 		}
167: 	}
168: }
169: 
170: func safeWrite(path string, buf []byte) error {
171: 	dir := filepath.Dir(path)
172: 
173: 	if _, err := os.Stat(dir); os.IsNotExist(err) {
174: 		if err := os.MkdirAll(dir, dirMode); err != nil {
175: 			return err
176: 		}
177: 	}
178: 
179: 	return os.WriteFile(path, buf, fileMode)
180: }
181: 
182: func newFetcher(name string, interval time.Duration, vehicle types.Vehicle, parser parser, onUpdate func(any)) *fetcher {
183: 	var ticker *time.Ticker
184: 	if interval != 0 {
185: 		ticker = time.NewTicker(interval)
186: 	}
187: 
188: 	return &fetcher{
189: 		name:     name,
190: 		ticker:   ticker,
191: 		vehicle:  vehicle,
192: 		interval: interval,
193: 		parser:   parser,
194: 		done:     make(chan struct{}, 1),
195: 		onUpdate: onUpdate,
196: 	}
197: }


./adapter\provider\healthcheck.go
1: package provider
2: 
3: import (
4: 	"context"
5: 	"time"
6: 
7: 	"github.com/Dreamacro/clash/common/batch"
8: 	C "github.com/Dreamacro/clash/constant"
9: 
10: 	"github.com/samber/lo"
11: 	"go.uber.org/atomic"
12: )
13: 
14: const (
15: 	defaultURLTestTimeout = time.Second * 5
16: )
17: 
18: type HealthCheckOption struct {
19: 	URL      string
20: 	Interval uint
21: }
22: 
23: type HealthCheck struct {
24: 	url       string
25: 	proxies   []C.Proxy
26: 	interval  uint
27: 	lazy      bool
28: 	lastTouch *atomic.Int64
29: 	done      chan struct{}
30: }
31: 
32: func (hc *HealthCheck) process() {
33: 	ticker := time.NewTicker(time.Duration(hc.interval) * time.Second)
34: 
35: 	go hc.checkAll()
36: 	for {
37: 		select {
38: 		case <-ticker.C:
39: 			now := time.Now().Unix()
40: 			if !hc.lazy || now-hc.lastTouch.Load() < int64(hc.interval) {
41: 				hc.checkAll()
42: 			} else { // lazy but still need to check not alive proxies
43: 				notAliveProxies := lo.Filter(hc.proxies, func(proxy C.Proxy, _ int) bool {
44: 					return !proxy.Alive()
45: 				})
46: 				if len(notAliveProxies) != 0 {
47: 					hc.check(notAliveProxies)
48: 				}
49: 			}
50: 		case <-hc.done:
51: 			ticker.Stop()
52: 			return
53: 		}
54: 	}
55: }
56: 
57: func (hc *HealthCheck) setProxy(proxies []C.Proxy) {
58: 	hc.proxies = proxies
59: }
60: 
61: func (hc *HealthCheck) auto() bool {
62: 	return hc.interval != 0
63: }
64: 
65: func (hc *HealthCheck) touch() {
66: 	hc.lastTouch.Store(time.Now().Unix())
67: }
68: 
69: func (hc *HealthCheck) checkAll() {
70: 	hc.check(hc.proxies)
71: }
72: 
73: func (hc *HealthCheck) check(proxies []C.Proxy) {
74: 	b, _ := batch.New(context.Background(), batch.WithConcurrencyNum(10))
75: 	for _, proxy := range proxies {
76: 		p := proxy
77: 		b.Go(p.Name(), func() (any, error) {
78: 			ctx, cancel := context.WithTimeout(context.Background(), defaultURLTestTimeout)
79: 			defer cancel()
80: 			p.URLTest(ctx, hc.url)
81: 			return nil, nil
82: 		})
83: 	}
84: 	b.Wait()
85: }
86: 
87: func (hc *HealthCheck) close() {
88: 	hc.done <- struct{}{}
89: }
90: 
91: func NewHealthCheck(proxies []C.Proxy, url string, interval uint, lazy bool) *HealthCheck {
92: 	return &HealthCheck{
93: 		proxies:   proxies,
94: 		url:       url,
95: 		interval:  interval,
96: 		lazy:      lazy,
97: 		lastTouch: atomic.NewInt64(0),
98: 		done:      make(chan struct{}, 1),
99: 	}
100: }


./adapter\provider\parser.go
1: package provider
2: 
3: import (
4: 	"errors"
5: 	"fmt"
6: 	"time"
7: 
8: 	"github.com/Dreamacro/clash/common/structure"
9: 	C "github.com/Dreamacro/clash/constant"
10: 	types "github.com/Dreamacro/clash/constant/provider"
11: )
12: 
13: var (
14: 	errVehicleType = errors.New("unsupport vehicle type")
15: 	errSubPath     = errors.New("path is not subpath of home directory")
16: )
17: 
18: type healthCheckSchema struct {
19: 	Enable   bool   `provider:"enable"`
20: 	URL      string `provider:"url"`
21: 	Interval int    `provider:"interval"`
22: 	Lazy     bool   `provider:"lazy,omitempty"`
23: }
24: 
25: type proxyProviderSchema struct {
26: 	Type        string            `provider:"type"`
27: 	Path        string            `provider:"path"`
28: 	URL         string            `provider:"url,omitempty"`
29: 	Interval    int               `provider:"interval,omitempty"`
30: 	Filter      string            `provider:"filter,omitempty"`
31: 	HealthCheck healthCheckSchema `provider:"health-check,omitempty"`
32: }
33: 
34: func ParseProxyProvider(name string, mapping map[string]any) (types.ProxyProvider, error) {
35: 	decoder := structure.NewDecoder(structure.Option{TagName: "provider", WeaklyTypedInput: true})
36: 
37: 	schema := &proxyProviderSchema{
38: 		HealthCheck: healthCheckSchema{
39: 			Lazy: true,
40: 		},
41: 	}
42: 	if err := decoder.Decode(mapping, schema); err != nil {
43: 		return nil, err
44: 	}
45: 
46: 	var hcInterval uint
47: 	if schema.HealthCheck.Enable {
48: 		hcInterval = uint(schema.HealthCheck.Interval)
49: 	}
50: 	hc := NewHealthCheck([]C.Proxy{}, schema.HealthCheck.URL, hcInterval, schema.HealthCheck.Lazy)
51: 
52: 	path := C.Path.Resolve(schema.Path)
53: 
54: 	var vehicle types.Vehicle
55: 	switch schema.Type {
56: 	case "file":
57: 		vehicle = NewFileVehicle(path)
58: 	case "http":
59: 		if !C.Path.IsSubPath(path) {
60: 			return nil, fmt.Errorf("%w: %s", errSubPath, path)
61: 		}
62: 		vehicle = NewHTTPVehicle(schema.URL, path)
63: 	default:
64: 		return nil, fmt.Errorf("%w: %s", errVehicleType, schema.Type)
65: 	}
66: 
67: 	interval := time.Duration(uint(schema.Interval)) * time.Second
68: 	filter := schema.Filter
69: 	return NewProxySetProvider(name, interval, filter, vehicle, hc)
70: }


./adapter\provider\provider.go
1: package provider
2: 
3: import (
4: 	"encoding/json"
5: 	"errors"
6: 	"fmt"
7: 	"runtime"
8: 	"time"
9: 
10: 	"github.com/Dreamacro/clash/adapter"
11: 	"github.com/Dreamacro/clash/adapter/outbound"
12: 	"github.com/Dreamacro/clash/common/singledo"
13: 	C "github.com/Dreamacro/clash/constant"
14: 	types "github.com/Dreamacro/clash/constant/provider"
15: 
16: 	regexp "github.com/dlclark/regexp2"
17: 	"github.com/samber/lo"
18: 	"gopkg.in/yaml.v3"
19: )
20: 
21: var reject = adapter.NewProxy(outbound.NewReject())
22: 
23: const (
24: 	ReservedName = "default"
25: )
26: 
27: type ProxySchema struct {
28: 	Proxies []map[string]any `yaml:"proxies"`
29: }
30: 
31: // for auto gc
32: type ProxySetProvider struct {
33: 	*proxySetProvider
34: }
35: 
36: type proxySetProvider struct {
37: 	*fetcher
38: 	proxies     []C.Proxy
39: 	healthCheck *HealthCheck
40: }
41: 
42: func (pp *proxySetProvider) MarshalJSON() ([]byte, error) {
43: 	return json.Marshal(map[string]any{
44: 		"name":        pp.Name(),
45: 		"type":        pp.Type().String(),
46: 		"vehicleType": pp.VehicleType().String(),
47: 		"proxies":     pp.Proxies(),
48: 		"updatedAt":   pp.updatedAt,
49: 	})
50: }
51: 
52: func (pp *proxySetProvider) Name() string {
53: 	return pp.name
54: }
55: 
56: func (pp *proxySetProvider) HealthCheck() {
57: 	pp.healthCheck.checkAll()
58: }
59: 
60: func (pp *proxySetProvider) Update() error {
61: 	elm, same, err := pp.fetcher.Update()
62: 	if err == nil && !same {
63: 		pp.onUpdate(elm)
64: 	}
65: 	return err
66: }
67: 
68: func (pp *proxySetProvider) Initial() error {
69: 	elm, err := pp.fetcher.Initial()
70: 	if err != nil {
71: 		return err
72: 	}
73: 
74: 	pp.onUpdate(elm)
75: 	return nil
76: }
77: 
78: func (pp *proxySetProvider) Type() types.ProviderType {
79: 	return types.Proxy
80: }
81: 
82: func (pp *proxySetProvider) Proxies() []C.Proxy {
83: 	return pp.proxies
84: }
85: 
86: func (pp *proxySetProvider) Touch() {
87: 	pp.healthCheck.touch()
88: }
89: 
90: func (pp *proxySetProvider) setProxies(proxies []C.Proxy) {
91: 	pp.proxies = proxies
92: 	pp.healthCheck.setProxy(proxies)
93: 	if pp.healthCheck.auto() {
94: 		go pp.healthCheck.checkAll()
95: 	}
96: }
97: 
98: func stopProxyProvider(pd *ProxySetProvider) {
99: 	pd.healthCheck.close()
100: 	pd.fetcher.Destroy()
101: }
102: 
103: func NewProxySetProvider(name string, interval time.Duration, filter string, vehicle types.Vehicle, hc *HealthCheck) (*ProxySetProvider, error) {
104: 	filterReg, err := regexp.Compile(filter, regexp.None)
105: 	if err != nil {
106: 		return nil, fmt.Errorf("invalid filter regex: %w", err)
107: 	}
108: 
109: 	if hc.auto() {
110: 		go hc.process()
111: 	}
112: 
113: 	pd := &proxySetProvider{
114: 		proxies:     []C.Proxy{},
115: 		healthCheck: hc,
116: 	}
117: 
118: 	onUpdate := func(elm any) {
119: 		ret := elm.([]C.Proxy)
120: 		pd.setProxies(ret)
121: 	}
122: 
123: 	proxiesParseAndFilter := func(buf []byte) (any, error) {
124: 		schema := &ProxySchema{}
125: 
126: 		if err := yaml.Unmarshal(buf, schema); err != nil {
127: 			return nil, err
128: 		}
129: 
130: 		if schema.Proxies == nil {
131: 			return nil, errors.New("file must have a `proxies` field")
132: 		}
133: 
134: 		proxies := []C.Proxy{}
135: 		for idx, mapping := range schema.Proxies {
136: 			if name, ok := mapping["name"].(string); ok && len(filter) > 0 {
137: 				matched, err := filterReg.MatchString(name)
138: 				if err != nil {
139: 					return nil, fmt.Errorf("regex filter failed: %w", err)
140: 				}
141: 				if !matched {
142: 					continue
143: 				}
144: 			}
145: 			proxy, err := adapter.ParseProxy(mapping)
146: 			if err != nil {
147: 				return nil, fmt.Errorf("proxy %d error: %w", idx, err)
148: 			}
149: 			proxies = append(proxies, proxy)
150: 		}
151: 
152: 		if len(proxies) == 0 {
153: 			if len(filter) > 0 {
154: 				return nil, errors.New("doesn't match any proxy, please check your filter")
155: 			}
156: 			return nil, errors.New("file doesn't have any proxy")
157: 		}
158: 
159: 		return proxies, nil
160: 	}
161: 
162: 	fetcher := newFetcher(name, interval, vehicle, proxiesParseAndFilter, onUpdate)
163: 	pd.fetcher = fetcher
164: 
165: 	wrapper := &ProxySetProvider{pd}
166: 	runtime.SetFinalizer(wrapper, stopProxyProvider)
167: 	return wrapper, nil
168: }
169: 
170: // for auto gc
171: type CompatibleProvider struct {
172: 	*compatibleProvider
173: }
174: 
175: type compatibleProvider struct {
176: 	name        string
177: 	healthCheck *HealthCheck
178: 	proxies     []C.Proxy
179: }
180: 
181: func (cp *compatibleProvider) MarshalJSON() ([]byte, error) {
182: 	return json.Marshal(map[string]any{
183: 		"name":        cp.Name(),
184: 		"type":        cp.Type().String(),
185: 		"vehicleType": cp.VehicleType().String(),
186: 		"proxies":     cp.Proxies(),
187: 	})
188: }
189: 
190: func (cp *compatibleProvider) Name() string {
191: 	return cp.name
192: }
193: 
194: func (cp *compatibleProvider) HealthCheck() {
195: 	cp.healthCheck.checkAll()
196: }
197: 
198: func (cp *compatibleProvider) Update() error {
199: 	return nil
200: }
201: 
202: func (cp *compatibleProvider) Initial() error {
203: 	return nil
204: }
205: 
206: func (cp *compatibleProvider) VehicleType() types.VehicleType {
207: 	return types.Compatible
208: }
209: 
210: func (cp *compatibleProvider) Type() types.ProviderType {
211: 	return types.Proxy
212: }
213: 
214: func (cp *compatibleProvider) Proxies() []C.Proxy {
215: 	return cp.proxies
216: }
217: 
218: func (cp *compatibleProvider) Touch() {
219: 	cp.healthCheck.touch()
220: }
221: 
222: func stopCompatibleProvider(pd *CompatibleProvider) {
223: 	pd.healthCheck.close()
224: }
225: 
226: func NewCompatibleProvider(name string, proxies []C.Proxy, hc *HealthCheck) (*CompatibleProvider, error) {
227: 	if len(proxies) == 0 {
228: 		return nil, errors.New("provider need one proxy at least")
229: 	}
230: 
231: 	if hc.auto() {
232: 		go hc.process()
233: 	}
234: 
235: 	pd := &compatibleProvider{
236: 		name:        name,
237: 		proxies:     proxies,
238: 		healthCheck: hc,
239: 	}
240: 
241: 	wrapper := &CompatibleProvider{pd}
242: 	runtime.SetFinalizer(wrapper, stopCompatibleProvider)
243: 	return wrapper, nil
244: }
245: 
246: var _ types.ProxyProvider = (*FilterableProvider)(nil)
247: 
248: type FilterableProvider struct {
249: 	name      string
250: 	providers []types.ProxyProvider
251: 	filterReg *regexp.Regexp
252: 	single    *singledo.Single
253: }
254: 
255: func (fp *FilterableProvider) MarshalJSON() ([]byte, error) {
256: 	return json.Marshal(map[string]any{
257: 		"name":        fp.Name(),
258: 		"type":        fp.Type().String(),
259: 		"vehicleType": fp.VehicleType().String(),
260: 		"proxies":     fp.Proxies(),
261: 	})
262: }
263: 
264: func (fp *FilterableProvider) Name() string {
265: 	return fp.name
266: }
267: 
268: func (fp *FilterableProvider) HealthCheck() {
269: }
270: 
271: func (fp *FilterableProvider) Update() error {
272: 	return nil
273: }
274: 
275: func (fp *FilterableProvider) Initial() error {
276: 	return nil
277: }
278: 
279: func (fp *FilterableProvider) VehicleType() types.VehicleType {
280: 	return types.Compatible
281: }
282: 
283: func (fp *FilterableProvider) Type() types.ProviderType {
284: 	return types.Proxy
285: }
286: 
287: func (fp *FilterableProvider) Proxies() []C.Proxy {
288: 	elm, _, _ := fp.single.Do(func() (any, error) {
289: 		proxies := lo.FlatMap(
290: 			fp.providers,
291: 			func(item types.ProxyProvider, _ int) []C.Proxy {
292: 				return lo.Filter(
293: 					item.Proxies(),
294: 					func(item C.Proxy, _ int) bool {
295: 						matched, _ := fp.filterReg.MatchString(item.Name())
296: 						return matched
297: 					})
298: 			})
299: 
300: 		if len(proxies) == 0 {
301: 			proxies = append(proxies, reject)
302: 		}
303: 		return proxies, nil
304: 	})
305: 
306: 	return elm.([]C.Proxy)
307: }
308: 
309: func (fp *FilterableProvider) Touch() {
310: 	for _, provider := range fp.providers {
311: 		provider.Touch()
312: 	}
313: }
314: 
315: func NewFilterableProvider(name string, providers []types.ProxyProvider, filterReg *regexp.Regexp) *FilterableProvider {
316: 	return &FilterableProvider{
317: 		name:      name,
318: 		providers: providers,
319: 		filterReg: filterReg,
320: 		single:    singledo.NewSingle(time.Second * 10),
321: 	}
322: }


./adapter\provider\vehicle.go
1: package provider
2: 
3: import (
4: 	"context"
5: 	"io"
6: 	"net"
7: 	"net/http"
8: 	"net/url"
9: 	"os"
10: 	"time"
11: 
12: 	"github.com/Dreamacro/clash/component/dialer"
13: 	types "github.com/Dreamacro/clash/constant/provider"
14: )
15: 
16: type FileVehicle struct {
17: 	path string
18: }
19: 
20: func (f *FileVehicle) Type() types.VehicleType {
21: 	return types.File
22: }
23: 
24: func (f *FileVehicle) Path() string {
25: 	return f.path
26: }
27: 
28: func (f *FileVehicle) Read() ([]byte, error) {
29: 	return os.ReadFile(f.path)
30: }
31: 
32: func NewFileVehicle(path string) *FileVehicle {
33: 	return &FileVehicle{path: path}
34: }
35: 
36: type HTTPVehicle struct {
37: 	url  string
38: 	path string
39: }
40: 
41: func (h *HTTPVehicle) Type() types.VehicleType {
42: 	return types.HTTP
43: }
44: 
45: func (h *HTTPVehicle) Path() string {
46: 	return h.path
47: }
48: 
49: func (h *HTTPVehicle) Read() ([]byte, error) {
50: 	ctx, cancel := context.WithTimeout(context.Background(), time.Second*20)
51: 	defer cancel()
52: 
53: 	uri, err := url.Parse(h.url)
54: 	if err != nil {
55: 		return nil, err
56: 	}
57: 
58: 	req, err := http.NewRequest(http.MethodGet, uri.String(), nil)
59: 	if err != nil {
60: 		return nil, err
61: 	}
62: 
63: 	if user := uri.User; user != nil {
64: 		password, _ := user.Password()
65: 		req.SetBasicAuth(user.Username(), password)
66: 	}
67: 
68: 	req = req.WithContext(ctx)
69: 
70: 	transport := &http.Transport{
71: 		// from http.DefaultTransport
72: 		MaxIdleConns:          100,
73: 		IdleConnTimeout:       90 * time.Second,
74: 		TLSHandshakeTimeout:   10 * time.Second,
75: 		ExpectContinueTimeout: 1 * time.Second,
76: 		DialContext: func(ctx context.Context, network, address string) (net.Conn, error) {
77: 			return dialer.DialContext(ctx, network, address)
78: 		},
79: 	}
80: 
81: 	client := http.Client{Transport: transport}
82: 	resp, err := client.Do(req)
83: 	if err != nil {
84: 		return nil, err
85: 	}
86: 	defer resp.Body.Close()
87: 
88: 	buf, err := io.ReadAll(resp.Body)
89: 	if err != nil {
90: 		return nil, err
91: 	}
92: 
93: 	return buf, nil
94: }
95: 
96: func NewHTTPVehicle(url string, path string) *HTTPVehicle {
97: 	return &HTTPVehicle{url, path}
98: }


./common\batch\batch.go
1: package batch
2: 
3: import (
4: 	"context"
5: 	"sync"
6: )
7: 
8: type Option = func(b *Batch)
9: 
10: type Result struct {
11: 	Value any
12: 	Err   error
13: }
14: 
15: type Error struct {
16: 	Key string
17: 	Err error
18: }
19: 
20: func WithConcurrencyNum(n int) Option {
21: 	return func(b *Batch) {
22: 		q := make(chan struct{}, n)
23: 		for i := 0; i < n; i++ {
24: 			q <- struct{}{}
25: 		}
26: 		b.queue = q
27: 	}
28: }
29: 
30: // Batch similar to errgroup, but can control the maximum number of concurrent
31: type Batch struct {
32: 	result map[string]Result
33: 	queue  chan struct{}
34: 	wg     sync.WaitGroup
35: 	mux    sync.Mutex
36: 	err    *Error
37: 	once   sync.Once
38: 	cancel func()
39: }
40: 
41: func (b *Batch) Go(key string, fn func() (any, error)) {
42: 	b.wg.Add(1)
43: 	go func() {
44: 		defer b.wg.Done()
45: 		if b.queue != nil {
46: 			<-b.queue
47: 			defer func() {
48: 				b.queue <- struct{}{}
49: 			}()
50: 		}
51: 
52: 		value, err := fn()
53: 		if err != nil {
54: 			b.once.Do(func() {
55: 				b.err = &Error{key, err}
56: 				if b.cancel != nil {
57: 					b.cancel()
58: 				}
59: 			})
60: 		}
61: 
62: 		ret := Result{value, err}
63: 		b.mux.Lock()
64: 		defer b.mux.Unlock()
65: 		b.result[key] = ret
66: 	}()
67: }
68: 
69: func (b *Batch) Wait() *Error {
70: 	b.wg.Wait()
71: 	if b.cancel != nil {
72: 		b.cancel()
73: 	}
74: 	return b.err
75: }
76: 
77: func (b *Batch) WaitAndGetResult() (map[string]Result, *Error) {
78: 	err := b.Wait()
79: 	return b.Result(), err
80: }
81: 
82: func (b *Batch) Result() map[string]Result {
83: 	b.mux.Lock()
84: 	defer b.mux.Unlock()
85: 	copy := map[string]Result{}
86: 	for k, v := range b.result {
87: 		copy[k] = v
88: 	}
89: 	return copy
90: }
91: 
92: func New(ctx context.Context, opts ...Option) (*Batch, context.Context) {
93: 	ctx, cancel := context.WithCancel(ctx)
94: 
95: 	b := &Batch{
96: 		result: map[string]Result{},
97: 	}
98: 
99: 	for _, o := range opts {
100: 		o(b)
101: 	}
102: 
103: 	b.cancel = cancel
104: 	return b, ctx
105: }


./common\batch\batch_test.go
1: package batch
2: 
3: import (
4: 	"context"
5: 	"errors"
6: 	"strconv"
7: 	"testing"
8: 	"time"
9: 
10: 	"github.com/stretchr/testify/assert"
11: )
12: 
13: func TestBatch(t *testing.T) {
14: 	b, _ := New(context.Background())
15: 
16: 	now := time.Now()
17: 	b.Go("foo", func() (any, error) {
18: 		time.Sleep(time.Millisecond * 100)
19: 		return "foo", nil
20: 	})
21: 	b.Go("bar", func() (any, error) {
22: 		time.Sleep(time.Millisecond * 150)
23: 		return "bar", nil
24: 	})
25: 	result, err := b.WaitAndGetResult()
26: 
27: 	assert.Nil(t, err)
28: 
29: 	duration := time.Since(now)
30: 	assert.Less(t, duration, time.Millisecond*200)
31: 	assert.Equal(t, 2, len(result))
32: 
33: 	for k, v := range result {
34: 		assert.NoError(t, v.Err)
35: 		assert.Equal(t, k, v.Value.(string))
36: 	}
37: }
38: 
39: func TestBatchWithConcurrencyNum(t *testing.T) {
40: 	b, _ := New(
41: 		context.Background(),
42: 		WithConcurrencyNum(3),
43: 	)
44: 
45: 	now := time.Now()
46: 	for i := 0; i < 7; i++ {
47: 		idx := i
48: 		b.Go(strconv.Itoa(idx), func() (any, error) {
49: 			time.Sleep(time.Millisecond * 100)
50: 			return strconv.Itoa(idx), nil
51: 		})
52: 	}
53: 	result, _ := b.WaitAndGetResult()
54: 	duration := time.Since(now)
55: 	assert.Greater(t, duration, time.Millisecond*260)
56: 	assert.Equal(t, 7, len(result))
57: 
58: 	for k, v := range result {
59: 		assert.NoError(t, v.Err)
60: 		assert.Equal(t, k, v.Value.(string))
61: 	}
62: }
63: 
64: func TestBatchContext(t *testing.T) {
65: 	b, ctx := New(context.Background())
66: 
67: 	b.Go("error", func() (any, error) {
68: 		time.Sleep(time.Millisecond * 100)
69: 		return nil, errors.New("test error")
70: 	})
71: 
72: 	b.Go("ctx", func() (any, error) {
73: 		<-ctx.Done()
74: 		return nil, ctx.Err()
75: 	})
76: 
77: 	result, err := b.WaitAndGetResult()
78: 
79: 	assert.NotNil(t, err)
80: 	assert.Equal(t, "error", err.Key)
81: 
82: 	assert.Equal(t, ctx.Err(), result["ctx"].Err)
83: }


./common\cache\lrucache.go
1: package cache
2: 
3: // Modified by https://github.com/die-net/lrucache
4: 
5: import (
6: 	"container/list"
7: 	"sync"
8: 	"time"
9: )
10: 
11: // Option is part of Functional Options Pattern
12: type Option func(*LruCache)
13: 
14: // EvictCallback is used to get a callback when a cache entry is evicted
15: type EvictCallback = func(key any, value any)
16: 
17: // WithEvict set the evict callback
18: func WithEvict(cb EvictCallback) Option {
19: 	return func(l *LruCache) {
20: 		l.onEvict = cb
21: 	}
22: }
23: 
24: // WithUpdateAgeOnGet update expires when Get element
25: func WithUpdateAgeOnGet() Option {
26: 	return func(l *LruCache) {
27: 		l.updateAgeOnGet = true
28: 	}
29: }
30: 
31: // WithAge defined element max age (second)
32: func WithAge(maxAge int64) Option {
33: 	return func(l *LruCache) {
34: 		l.maxAge = maxAge
35: 	}
36: }
37: 
38: // WithSize defined max length of LruCache
39: func WithSize(maxSize int) Option {
40: 	return func(l *LruCache) {
41: 		l.maxSize = maxSize
42: 	}
43: }
44: 
45: // WithStale decide whether Stale return is enabled.
46: // If this feature is enabled, element will not get Evicted according to `WithAge`.
47: func WithStale(stale bool) Option {
48: 	return func(l *LruCache) {
49: 		l.staleReturn = stale
50: 	}
51: }
52: 
53: // LruCache is a thread-safe, in-memory lru-cache that evicts the
54: // least recently used entries from memory when (if set) the entries are
55: // older than maxAge (in seconds).  Use the New constructor to create one.
56: type LruCache struct {
57: 	maxAge         int64
58: 	maxSize        int
59: 	mu             sync.Mutex
60: 	cache          map[any]*list.Element
61: 	lru            *list.List // Front is least-recent
62: 	updateAgeOnGet bool
63: 	staleReturn    bool
64: 	onEvict        EvictCallback
65: }
66: 
67: // New creates an LruCache
68: func New(options ...Option) *LruCache {
69: 	lc := &LruCache{
70: 		lru:   list.New(),
71: 		cache: make(map[any]*list.Element),
72: 	}
73: 
74: 	for _, option := range options {
75: 		option(lc)
76: 	}
77: 
78: 	return lc
79: }
80: 
81: // Get returns the any representation of a cached response and a bool
82: // set to true if the key was found.
83: func (c *LruCache) Get(key any) (any, bool) {
84: 	entry := c.get(key)
85: 	if entry == nil {
86: 		return nil, false
87: 	}
88: 	value := entry.value
89: 
90: 	return value, true
91: }
92: 
93: // GetWithExpire returns the any representation of a cached response,
94: // a time.Time Give expected expires,
95: // and a bool set to true if the key was found.
96: // This method will NOT check the maxAge of element and will NOT update the expires.
97: func (c *LruCache) GetWithExpire(key any) (any, time.Time, bool) {
98: 	entry := c.get(key)
99: 	if entry == nil {
100: 		return nil, time.Time{}, false
101: 	}
102: 
103: 	return entry.value, time.Unix(entry.expires, 0), true
104: }
105: 
106: // Exist returns if key exist in cache but not put item to the head of linked list
107: func (c *LruCache) Exist(key any) bool {
108: 	c.mu.Lock()
109: 	defer c.mu.Unlock()
110: 
111: 	_, ok := c.cache[key]
112: 	return ok
113: }
114: 
115: // Set stores the any representation of a response for a given key.
116: func (c *LruCache) Set(key any, value any) {
117: 	expires := int64(0)
118: 	if c.maxAge > 0 {
119: 		expires = time.Now().Unix() + c.maxAge
120: 	}
121: 	c.SetWithExpire(key, value, time.Unix(expires, 0))
122: }
123: 
124: // SetWithExpire stores the any representation of a response for a given key and given expires.
125: // The expires time will round to second.
126: func (c *LruCache) SetWithExpire(key any, value any, expires time.Time) {
127: 	c.mu.Lock()
128: 	defer c.mu.Unlock()
129: 
130: 	if le, ok := c.cache[key]; ok {
131: 		c.lru.MoveToBack(le)
132: 		e := le.Value.(*entry)
133: 		e.value = value
134: 		e.expires = expires.Unix()
135: 	} else {
136: 		e := &entry{key: key, value: value, expires: expires.Unix()}
137: 		c.cache[key] = c.lru.PushBack(e)
138: 
139: 		if c.maxSize > 0 {
140: 			if len := c.lru.Len(); len > c.maxSize {
141: 				c.deleteElement(c.lru.Front())
142: 			}
143: 		}
144: 	}
145: 
146: 	c.maybeDeleteOldest()
147: }
148: 
149: // CloneTo clone and overwrite elements to another LruCache
150: func (c *LruCache) CloneTo(n *LruCache) {
151: 	c.mu.Lock()
152: 	defer c.mu.Unlock()
153: 
154: 	n.mu.Lock()
155: 	defer n.mu.Unlock()
156: 
157: 	n.lru = list.New()
158: 	n.cache = make(map[any]*list.Element)
159: 
160: 	for e := c.lru.Front(); e != nil; e = e.Next() {
161: 		elm := e.Value.(*entry)
162: 		n.cache[elm.key] = n.lru.PushBack(elm)
163: 	}
164: }
165: 
166: func (c *LruCache) get(key any) *entry {
167: 	c.mu.Lock()
168: 	defer c.mu.Unlock()
169: 
170: 	le, ok := c.cache[key]
171: 	if !ok {
172: 		return nil
173: 	}
174: 
175: 	if !c.staleReturn && c.maxAge > 0 && le.Value.(*entry).expires <= time.Now().Unix() {
176: 		c.deleteElement(le)
177: 		c.maybeDeleteOldest()
178: 
179: 		return nil
180: 	}
181: 
182: 	c.lru.MoveToBack(le)
183: 	entry := le.Value.(*entry)
184: 	if c.maxAge > 0 && c.updateAgeOnGet {
185: 		entry.expires = time.Now().Unix() + c.maxAge
186: 	}
187: 	return entry
188: }
189: 
190: // Delete removes the value associated with a key.
191: func (c *LruCache) Delete(key any) {
192: 	c.mu.Lock()
193: 
194: 	if le, ok := c.cache[key]; ok {
195: 		c.deleteElement(le)
196: 	}
197: 
198: 	c.mu.Unlock()
199: }
200: 
201: func (c *LruCache) maybeDeleteOldest() {
202: 	if !c.staleReturn && c.maxAge > 0 {
203: 		now := time.Now().Unix()
204: 		for le := c.lru.Front(); le != nil && le.Value.(*entry).expires <= now; le = c.lru.Front() {
205: 			c.deleteElement(le)
206: 		}
207: 	}
208: }
209: 
210: func (c *LruCache) deleteElement(le *list.Element) {
211: 	c.lru.Remove(le)
212: 	e := le.Value.(*entry)
213: 	delete(c.cache, e.key)
214: 	if c.onEvict != nil {
215: 		c.onEvict(e.key, e.value)
216: 	}
217: }
218: 
219: type entry struct {
220: 	key     any
221: 	value   any
222: 	expires int64
223: }


./common\cache\lrucache_test.go
1: package cache
2: 
3: import (
4: 	"testing"
5: 	"time"
6: 
7: 	"github.com/stretchr/testify/assert"
8: )
9: 
10: var entries = []struct {
11: 	key   string
12: 	value string
13: }{
14: 	{"1", "one"},
15: 	{"2", "two"},
16: 	{"3", "three"},
17: 	{"4", "four"},
18: 	{"5", "five"},
19: }
20: 
21: func TestLRUCache(t *testing.T) {
22: 	c := New()
23: 
24: 	for _, e := range entries {
25: 		c.Set(e.key, e.value)
26: 	}
27: 
28: 	c.Delete("missing")
29: 	_, ok := c.Get("missing")
30: 	assert.False(t, ok)
31: 
32: 	for _, e := range entries {
33: 		value, ok := c.Get(e.key)
34: 		if assert.True(t, ok) {
35: 			assert.Equal(t, e.value, value.(string))
36: 		}
37: 	}
38: 
39: 	for _, e := range entries {
40: 		c.Delete(e.key)
41: 
42: 		_, ok := c.Get(e.key)
43: 		assert.False(t, ok)
44: 	}
45: }
46: 
47: func TestLRUMaxAge(t *testing.T) {
48: 	c := New(WithAge(86400))
49: 
50: 	now := time.Now().Unix()
51: 	expected := now + 86400
52: 
53: 	// Add one expired entry
54: 	c.Set("foo", "bar")
55: 	c.lru.Back().Value.(*entry).expires = now
56: 
57: 	// Reset
58: 	c.Set("foo", "bar")
59: 	e := c.lru.Back().Value.(*entry)
60: 	assert.True(t, e.expires >= now)
61: 	c.lru.Back().Value.(*entry).expires = now
62: 
63: 	// Set a few and verify expiration times
64: 	for _, s := range entries {
65: 		c.Set(s.key, s.value)
66: 		e := c.lru.Back().Value.(*entry)
67: 		assert.True(t, e.expires >= expected && e.expires <= expected+10)
68: 	}
69: 
70: 	// Make sure we can get them all
71: 	for _, s := range entries {
72: 		_, ok := c.Get(s.key)
73: 		assert.True(t, ok)
74: 	}
75: 
76: 	// Expire all entries
77: 	for _, s := range entries {
78: 		le, ok := c.cache[s.key]
79: 		if assert.True(t, ok) {
80: 			le.Value.(*entry).expires = now
81: 		}
82: 	}
83: 
84: 	// Get one expired entry, which should clear all expired entries
85: 	_, ok := c.Get("3")
86: 	assert.False(t, ok)
87: 	assert.Equal(t, c.lru.Len(), 0)
88: }
89: 
90: func TestLRUpdateOnGet(t *testing.T) {
91: 	c := New(WithAge(86400), WithUpdateAgeOnGet())
92: 
93: 	now := time.Now().Unix()
94: 	expires := now + 86400/2
95: 
96: 	// Add one expired entry
97: 	c.Set("foo", "bar")
98: 	c.lru.Back().Value.(*entry).expires = expires
99: 
100: 	_, ok := c.Get("foo")
101: 	assert.True(t, ok)
102: 	assert.True(t, c.lru.Back().Value.(*entry).expires > expires)
103: }
104: 
105: func TestMaxSize(t *testing.T) {
106: 	c := New(WithSize(2))
107: 	// Add one expired entry
108: 	c.Set("foo", "bar")
109: 	_, ok := c.Get("foo")
110: 	assert.True(t, ok)
111: 
112: 	c.Set("bar", "foo")
113: 	c.Set("baz", "foo")
114: 
115: 	_, ok = c.Get("foo")
116: 	assert.False(t, ok)
117: }
118: 
119: func TestExist(t *testing.T) {
120: 	c := New(WithSize(1))
121: 	c.Set(1, 2)
122: 	assert.True(t, c.Exist(1))
123: 	c.Set(2, 3)
124: 	assert.False(t, c.Exist(1))
125: }
126: 
127: func TestEvict(t *testing.T) {
128: 	temp := 0
129: 	evict := func(key any, value any) {
130: 		temp = key.(int) + value.(int)
131: 	}
132: 
133: 	c := New(WithEvict(evict), WithSize(1))
134: 	c.Set(1, 2)
135: 	c.Set(2, 3)
136: 
137: 	assert.Equal(t, temp, 3)
138: }
139: 
140: func TestSetWithExpire(t *testing.T) {
141: 	c := New(WithAge(1))
142: 	now := time.Now().Unix()
143: 
144: 	tenSecBefore := time.Unix(now-10, 0)
145: 	c.SetWithExpire(1, 2, tenSecBefore)
146: 
147: 	// res is expected not to exist, and expires should be empty time.Time
148: 	res, expires, exist := c.GetWithExpire(1)
149: 	assert.Equal(t, nil, res)
150: 	assert.Equal(t, time.Time{}, expires)
151: 	assert.Equal(t, false, exist)
152: }
153: 
154: func TestStale(t *testing.T) {
155: 	c := New(WithAge(1), WithStale(true))
156: 	now := time.Now().Unix()
157: 
158: 	tenSecBefore := time.Unix(now-10, 0)
159: 	c.SetWithExpire(1, 2, tenSecBefore)
160: 
161: 	res, expires, exist := c.GetWithExpire(1)
162: 	assert.Equal(t, 2, res)
163: 	assert.Equal(t, tenSecBefore, expires)
164: 	assert.Equal(t, true, exist)
165: }
166: 
167: func TestCloneTo(t *testing.T) {
168: 	o := New(WithSize(10))
169: 	o.Set("1", 1)
170: 	o.Set("2", 2)
171: 
172: 	n := New(WithSize(2))
173: 	n.Set("3", 3)
174: 	n.Set("4", 4)
175: 
176: 	o.CloneTo(n)
177: 
178: 	assert.False(t, n.Exist("3"))
179: 	assert.True(t, n.Exist("1"))
180: 
181: 	n.Set("5", 5)
182: 	assert.False(t, n.Exist("1"))
183: }


./common\murmur3\murmur.go
1: package murmur3
2: 
3: type bmixer interface {
4: 	bmix(p []byte) (tail []byte)
5: 	Size() (n int)
6: 	reset()
7: }
8: 
9: type digest struct {
10: 	clen int      // Digested input cumulative length.
11: 	tail []byte   // 0 to Size()-1 bytes view of `buf'.
12: 	buf  [16]byte // Expected (but not required) to be Size() large.
13: 	seed uint32   // Seed for initializing the hash.
14: 	bmixer
15: }
16: 
17: func (d *digest) BlockSize() int { return 1 }
18: 
19: func (d *digest) Write(p []byte) (n int, err error) {
20: 	n = len(p)
21: 	d.clen += n
22: 
23: 	if len(d.tail) > 0 {
24: 		// Stick back pending bytes.
25: 		nfree := d.Size() - len(d.tail) // nfree ∈ [1, d.Size()-1].
26: 		if nfree < len(p) {
27: 			// One full block can be formed.
28: 			block := append(d.tail, p[:nfree]...)
29: 			p = p[nfree:]
30: 			_ = d.bmix(block) // No tail.
31: 		} else {
32: 			// Tail's buf is large enough to prevent reallocs.
33: 			p = append(d.tail, p...)
34: 		}
35: 	}
36: 
37: 	d.tail = d.bmix(p)
38: 
39: 	// Keep own copy of the 0 to Size()-1 pending bytes.
40: 	nn := copy(d.buf[:], d.tail)
41: 	d.tail = d.buf[:nn]
42: 
43: 	return n, nil
44: }
45: 
46: func (d *digest) Reset() {
47: 	d.clen = 0
48: 	d.tail = nil
49: 	d.bmixer.reset()
50: }


./common\murmur3\murmur32.go
1: package murmur3
2: 
3: // https://github.com/spaolacci/murmur3/blob/master/murmur32.go
4: 
5: import (
6: 	"hash"
7: 	"math/bits"
8: 	"unsafe"
9: )
10: 
11: // Make sure interfaces are correctly implemented.
12: var (
13: 	_ hash.Hash32 = new(digest32)
14: 	_ bmixer      = new(digest32)
15: )
16: 
17: const (
18: 	c1_32 uint32 = 0xcc9e2d51
19: 	c2_32 uint32 = 0x1b873593
20: )
21: 
22: // digest32 represents a partial evaluation of a 32 bites hash.
23: type digest32 struct {
24: 	digest
25: 	h1 uint32 // Unfinalized running hash.
26: }
27: 
28: // New32 returns new 32-bit hasher
29: func New32() hash.Hash32 { return New32WithSeed(0) }
30: 
31: // New32WithSeed returns new 32-bit hasher set with explicit seed value
32: func New32WithSeed(seed uint32) hash.Hash32 {
33: 	d := new(digest32)
34: 	d.seed = seed
35: 	d.bmixer = d
36: 	d.Reset()
37: 	return d
38: }
39: 
40: func (d *digest32) Size() int { return 4 }
41: 
42: func (d *digest32) reset() { d.h1 = d.seed }
43: 
44: func (d *digest32) Sum(b []byte) []byte {
45: 	h := d.Sum32()
46: 	return append(b, byte(h>>24), byte(h>>16), byte(h>>8), byte(h))
47: }
48: 
49: // Digest as many blocks as possible.
50: func (d *digest32) bmix(p []byte) (tail []byte) {
51: 	h1 := d.h1
52: 
53: 	nblocks := len(p) / 4
54: 	for i := 0; i < nblocks; i++ {
55: 		k1 := *(*uint32)(unsafe.Pointer(&p[i*4]))
56: 
57: 		k1 *= c1_32
58: 		k1 = bits.RotateLeft32(k1, 15)
59: 		k1 *= c2_32
60: 
61: 		h1 ^= k1
62: 		h1 = bits.RotateLeft32(h1, 13)
63: 		h1 = h1*4 + h1 + 0xe6546b64
64: 	}
65: 	d.h1 = h1
66: 	return p[nblocks*d.Size():]
67: }
68: 
69: func (d *digest32) Sum32() (h1 uint32) {
70: 	h1 = d.h1
71: 
72: 	var k1 uint32
73: 	switch len(d.tail) & 3 {
74: 	case 3:
75: 		k1 ^= uint32(d.tail[2]) << 16
76: 		fallthrough
77: 	case 2:
78: 		k1 ^= uint32(d.tail[1]) << 8
79: 		fallthrough
80: 	case 1:
81: 		k1 ^= uint32(d.tail[0])
82: 		k1 *= c1_32
83: 		k1 = bits.RotateLeft32(k1, 15)
84: 		k1 *= c2_32
85: 		h1 ^= k1
86: 	}
87: 
88: 	h1 ^= uint32(d.clen)
89: 
90: 	h1 ^= h1 >> 16
91: 	h1 *= 0x85ebca6b
92: 	h1 ^= h1 >> 13
93: 	h1 *= 0xc2b2ae35
94: 	h1 ^= h1 >> 16
95: 
96: 	return h1
97: }
98: 
99: func Sum32(data []byte) uint32 { return Sum32WithSeed(data, 0) }
100: 
101: func Sum32WithSeed(data []byte, seed uint32) uint32 {
102: 	h1 := seed
103: 
104: 	nblocks := len(data) / 4
105: 	for i := 0; i < nblocks; i++ {
106: 		k1 := *(*uint32)(unsafe.Pointer(&data[i*4]))
107: 
108: 		k1 *= c1_32
109: 		k1 = bits.RotateLeft32(k1, 15)
110: 		k1 *= c2_32
111: 
112: 		h1 ^= k1
113: 		h1 = bits.RotateLeft32(h1, 13)
114: 		h1 = h1*4 + h1 + 0xe6546b64
115: 	}
116: 
117: 	tail := data[nblocks*4:]
118: 
119: 	var k1 uint32
120: 	switch len(tail) & 3 {
121: 	case 3:
122: 		k1 ^= uint32(tail[2]) << 16
123: 		fallthrough
124: 	case 2:
125: 		k1 ^= uint32(tail[1]) << 8
126: 		fallthrough
127: 	case 1:
128: 		k1 ^= uint32(tail[0])
129: 		k1 *= c1_32
130: 		k1 = bits.RotateLeft32(k1, 15)
131: 		k1 *= c2_32
132: 		h1 ^= k1
133: 	}
134: 
135: 	h1 ^= uint32(len(data))
136: 
137: 	h1 ^= h1 >> 16
138: 	h1 *= 0x85ebca6b
139: 	h1 ^= h1 >> 13
140: 	h1 *= 0xc2b2ae35
141: 	h1 ^= h1 >> 16
142: 
143: 	return h1
144: }


./common\net\bufconn.go
1: package net
2: 
3: import (
4: 	"bufio"
5: 	"net"
6: )
7: 
8: type BufferedConn struct {
9: 	r *bufio.Reader
10: 	net.Conn
11: }
12: 
13: func NewBufferedConn(c net.Conn) *BufferedConn {
14: 	if bc, ok := c.(*BufferedConn); ok {
15: 		return bc
16: 	}
17: 	return &BufferedConn{bufio.NewReader(c), c}
18: }
19: 
20: // Reader returns the internal bufio.Reader.
21: func (c *BufferedConn) Reader() *bufio.Reader {
22: 	return c.r
23: }
24: 
25: // Peek returns the next n bytes without advancing the reader.
26: func (c *BufferedConn) Peek(n int) ([]byte, error) {
27: 	return c.r.Peek(n)
28: }
29: 
30: func (c *BufferedConn) Read(p []byte) (int, error) {
31: 	return c.r.Read(p)
32: }
33: 
34: func (c *BufferedConn) ReadByte() (byte, error) {
35: 	return c.r.ReadByte()
36: }
37: 
38: func (c *BufferedConn) UnreadByte() error {
39: 	return c.r.UnreadByte()
40: }
41: 
42: func (c *BufferedConn) Buffered() int {
43: 	return c.r.Buffered()
44: }


./common\net\io.go
1: package net
2: 
3: import "io"
4: 
5: type ReadOnlyReader struct {
6: 	io.Reader
7: }
8: 
9: type WriteOnlyWriter struct {
10: 	io.Writer
11: }


./common\net\relay.go
1: package net
2: 
3: import (
4: 	"io"
5: 	"net"
6: 	"time"
7: )
8: 
9: // Relay copies between left and right bidirectionally.
10: func Relay(leftConn, rightConn net.Conn) {
11: 	ch := make(chan error)
12: 
13: 	go func() {
14: 		// Wrapping to avoid using *net.TCPConn.(ReadFrom)
15: 		// See also https://github.com/Dreamacro/clash/pull/1209
16: 		_, err := io.Copy(WriteOnlyWriter{Writer: leftConn}, ReadOnlyReader{Reader: rightConn})
17: 		leftConn.SetReadDeadline(time.Now())
18: 		ch <- err
19: 	}()
20: 
21: 	io.Copy(WriteOnlyWriter{Writer: rightConn}, ReadOnlyReader{Reader: leftConn})
22: 	rightConn.SetReadDeadline(time.Now())
23: 	<-ch
24: }


./common\observable\iterable.go
1: package observable
2: 
3: type Iterable <-chan any


./common\observable\observable.go
1: package observable
2: 
3: import (
4: 	"errors"
5: 	"sync"
6: )
7: 
8: type Observable struct {
9: 	iterable Iterable
10: 	listener map[Subscription]*Subscriber
11: 	mux      sync.Mutex
12: 	done     bool
13: }
14: 
15: func (o *Observable) process() {
16: 	for item := range o.iterable {
17: 		o.mux.Lock()
18: 		for _, sub := range o.listener {
19: 			sub.Emit(item)
20: 		}
21: 		o.mux.Unlock()
22: 	}
23: 	o.close()
24: }
25: 
26: func (o *Observable) close() {
27: 	o.mux.Lock()
28: 	defer o.mux.Unlock()
29: 
30: 	o.done = true
31: 	for _, sub := range o.listener {
32: 		sub.Close()
33: 	}
34: }
35: 
36: func (o *Observable) Subscribe() (Subscription, error) {
37: 	o.mux.Lock()
38: 	defer o.mux.Unlock()
39: 	if o.done {
40: 		return nil, errors.New("Observable is closed")
41: 	}
42: 	subscriber := newSubscriber()
43: 	o.listener[subscriber.Out()] = subscriber
44: 	return subscriber.Out(), nil
45: }
46: 
47: func (o *Observable) UnSubscribe(sub Subscription) {
48: 	o.mux.Lock()
49: 	defer o.mux.Unlock()
50: 	subscriber, exist := o.listener[sub]
51: 	if !exist {
52: 		return
53: 	}
54: 	delete(o.listener, sub)
55: 	subscriber.Close()
56: }
57: 
58: func NewObservable(any Iterable) *Observable {
59: 	observable := &Observable{
60: 		iterable: any,
61: 		listener: map[Subscription]*Subscriber{},
62: 	}
63: 	go observable.process()
64: 	return observable
65: }


./common\observable\observable_test.go
1: package observable
2: 
3: import (
4: 	"sync"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/stretchr/testify/assert"
9: 	"go.uber.org/atomic"
10: )
11: 
12: func iterator(item []any) chan any {
13: 	ch := make(chan any)
14: 	go func() {
15: 		time.Sleep(100 * time.Millisecond)
16: 		for _, elm := range item {
17: 			ch <- elm
18: 		}
19: 		close(ch)
20: 	}()
21: 	return ch
22: }
23: 
24: func TestObservable(t *testing.T) {
25: 	iter := iterator([]any{1, 2, 3, 4, 5})
26: 	src := NewObservable(iter)
27: 	data, err := src.Subscribe()
28: 	assert.Nil(t, err)
29: 	count := 0
30: 	for range data {
31: 		count++
32: 	}
33: 	assert.Equal(t, count, 5)
34: }
35: 
36: func TestObservable_MultiSubscribe(t *testing.T) {
37: 	iter := iterator([]any{1, 2, 3, 4, 5})
38: 	src := NewObservable(iter)
39: 	ch1, _ := src.Subscribe()
40: 	ch2, _ := src.Subscribe()
41: 	count := atomic.NewInt32(0)
42: 
43: 	var wg sync.WaitGroup
44: 	wg.Add(2)
45: 	waitCh := func(ch <-chan any) {
46: 		for range ch {
47: 			count.Inc()
48: 		}
49: 		wg.Done()
50: 	}
51: 	go waitCh(ch1)
52: 	go waitCh(ch2)
53: 	wg.Wait()
54: 	assert.Equal(t, int32(10), count.Load())
55: }
56: 
57: func TestObservable_UnSubscribe(t *testing.T) {
58: 	iter := iterator([]any{1, 2, 3, 4, 5})
59: 	src := NewObservable(iter)
60: 	data, err := src.Subscribe()
61: 	assert.Nil(t, err)
62: 	src.UnSubscribe(data)
63: 	_, open := <-data
64: 	assert.False(t, open)
65: }
66: 
67: func TestObservable_SubscribeClosedSource(t *testing.T) {
68: 	iter := iterator([]any{1})
69: 	src := NewObservable(iter)
70: 	data, _ := src.Subscribe()
71: 	<-data
72: 
73: 	_, closed := src.Subscribe()
74: 	assert.NotNil(t, closed)
75: }
76: 
77: func TestObservable_UnSubscribeWithNotExistSubscription(t *testing.T) {
78: 	sub := Subscription(make(chan any))
79: 	iter := iterator([]any{1})
80: 	src := NewObservable(iter)
81: 	src.UnSubscribe(sub)
82: }
83: 
84: func TestObservable_SubscribeGoroutineLeak(t *testing.T) {
85: 	iter := iterator([]any{1, 2, 3, 4, 5})
86: 	src := NewObservable(iter)
87: 	max := 100
88: 
89: 	var list []Subscription
90: 	for i := 0; i < max; i++ {
91: 		ch, _ := src.Subscribe()
92: 		list = append(list, ch)
93: 	}
94: 
95: 	var wg sync.WaitGroup
96: 	wg.Add(max)
97: 	waitCh := func(ch <-chan any) {
98: 		for range ch {
99: 		}
100: 		wg.Done()
101: 	}
102: 
103: 	for _, ch := range list {
104: 		go waitCh(ch)
105: 	}
106: 	wg.Wait()
107: 
108: 	for _, sub := range list {
109: 		_, more := <-sub
110: 		assert.False(t, more)
111: 	}
112: 
113: 	_, more := <-list[0]
114: 	assert.False(t, more)
115: }
116: 
117: func Benchmark_Observable_1000(b *testing.B) {
118: 	ch := make(chan any)
119: 	o := NewObservable(ch)
120: 	num := 1000
121: 
122: 	subs := []Subscription{}
123: 	for i := 0; i < num; i++ {
124: 		sub, _ := o.Subscribe()
125: 		subs = append(subs, sub)
126: 	}
127: 
128: 	wg := sync.WaitGroup{}
129: 	wg.Add(num)
130: 
131: 	b.ResetTimer()
132: 	for _, sub := range subs {
133: 		go func(s Subscription) {
134: 			for range s {
135: 			}
136: 			wg.Done()
137: 		}(sub)
138: 	}
139: 
140: 	for i := 0; i < b.N; i++ {
141: 		ch <- i
142: 	}
143: 
144: 	close(ch)
145: 	wg.Wait()
146: }


./common\observable\subscriber.go
1: package observable
2: 
3: import (
4: 	"sync"
5: )
6: 
7: type Subscription <-chan any
8: 
9: type Subscriber struct {
10: 	buffer chan any
11: 	once   sync.Once
12: }
13: 
14: func (s *Subscriber) Emit(item any) {
15: 	s.buffer <- item
16: }
17: 
18: func (s *Subscriber) Out() Subscription {
19: 	return s.buffer
20: }
21: 
22: func (s *Subscriber) Close() {
23: 	s.once.Do(func() {
24: 		close(s.buffer)
25: 	})
26: }
27: 
28: func newSubscriber() *Subscriber {
29: 	sub := &Subscriber{
30: 		buffer: make(chan any, 200),
31: 	}
32: 	return sub
33: }


./common\picker\picker.go
1: package picker
2: 
3: import (
4: 	"context"
5: 	"sync"
6: 	"time"
7: )
8: 
9: // Picker provides synchronization, and Context cancelation
10: // for groups of goroutines working on subtasks of a common task.
11: // Inspired by errGroup
12: type Picker struct {
13: 	ctx    context.Context
14: 	cancel func()
15: 
16: 	wg sync.WaitGroup
17: 
18: 	once    sync.Once
19: 	errOnce sync.Once
20: 	result  any
21: 	err     error
22: }
23: 
24: func newPicker(ctx context.Context, cancel func()) *Picker {
25: 	return &Picker{
26: 		ctx:    ctx,
27: 		cancel: cancel,
28: 	}
29: }
30: 
31: // WithContext returns a new Picker and an associated Context derived from ctx.
32: // and cancel when first element return.
33: func WithContext(ctx context.Context) (*Picker, context.Context) {
34: 	ctx, cancel := context.WithCancel(ctx)
35: 	return newPicker(ctx, cancel), ctx
36: }
37: 
38: // WithTimeout returns a new Picker and an associated Context derived from ctx with timeout.
39: func WithTimeout(ctx context.Context, timeout time.Duration) (*Picker, context.Context) {
40: 	ctx, cancel := context.WithTimeout(ctx, timeout)
41: 	return newPicker(ctx, cancel), ctx
42: }
43: 
44: // Wait blocks until all function calls from the Go method have returned,
45: // then returns the first nil error result (if any) from them.
46: func (p *Picker) Wait() any {
47: 	p.wg.Wait()
48: 	if p.cancel != nil {
49: 		p.cancel()
50: 	}
51: 	return p.result
52: }
53: 
54: // Error return the first error (if all success return nil)
55: func (p *Picker) Error() error {
56: 	return p.err
57: }
58: 
59: // Go calls the given function in a new goroutine.
60: // The first call to return a nil error cancels the group; its result will be returned by Wait.
61: func (p *Picker) Go(f func() (any, error)) {
62: 	p.wg.Add(1)
63: 
64: 	go func() {
65: 		defer p.wg.Done()
66: 
67: 		if ret, err := f(); err == nil {
68: 			p.once.Do(func() {
69: 				p.result = ret
70: 				if p.cancel != nil {
71: 					p.cancel()
72: 				}
73: 			})
74: 		} else {
75: 			p.errOnce.Do(func() {
76: 				p.err = err
77: 			})
78: 		}
79: 	}()
80: }


./common\picker\picker_test.go
1: package picker
2: 
3: import (
4: 	"context"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/stretchr/testify/assert"
9: )
10: 
11: func sleepAndSend(ctx context.Context, delay int, input any) func() (any, error) {
12: 	return func() (any, error) {
13: 		timer := time.NewTimer(time.Millisecond * time.Duration(delay))
14: 		select {
15: 		case <-timer.C:
16: 			return input, nil
17: 		case <-ctx.Done():
18: 			return nil, ctx.Err()
19: 		}
20: 	}
21: }
22: 
23: func TestPicker_Basic(t *testing.T) {
24: 	picker, ctx := WithContext(context.Background())
25: 	picker.Go(sleepAndSend(ctx, 30, 2))
26: 	picker.Go(sleepAndSend(ctx, 20, 1))
27: 
28: 	number := picker.Wait()
29: 	assert.NotNil(t, number)
30: 	assert.Equal(t, number.(int), 1)
31: }
32: 
33: func TestPicker_Timeout(t *testing.T) {
34: 	picker, ctx := WithTimeout(context.Background(), time.Millisecond*5)
35: 	picker.Go(sleepAndSend(ctx, 20, 1))
36: 
37: 	number := picker.Wait()
38: 	assert.Nil(t, number)
39: 	assert.NotNil(t, picker.Error())
40: }


./common\pool\alloc.go
1: package pool
2: 
3: // Inspired by https://github.com/xtaci/smux/blob/master/alloc.go
4: 
5: import (
6: 	"errors"
7: 	"math/bits"
8: 	"sync"
9: )
10: 
11: var defaultAllocator = NewAllocator()
12: 
13: // Allocator for incoming frames, optimized to prevent overwriting after zeroing
14: type Allocator struct {
15: 	buffers []sync.Pool
16: }
17: 
18: // NewAllocator initiates a []byte allocator for frames less than 65536 bytes,
19: // the waste(memory fragmentation) of space allocation is guaranteed to be
20: // no more than 50%.
21: func NewAllocator() *Allocator {
22: 	alloc := new(Allocator)
23: 	alloc.buffers = make([]sync.Pool, 17) // 1B -> 64K
24: 	for k := range alloc.buffers {
25: 		i := k
26: 		alloc.buffers[k].New = func() any {
27: 			return make([]byte, 1<<uint32(i))
28: 		}
29: 	}
30: 	return alloc
31: }
32: 
33: // Get a []byte from pool with most appropriate cap
34: func (alloc *Allocator) Get(size int) []byte {
35: 	switch {
36: 	case size < 0:
37: 		panic("alloc.Get: len out of range")
38: 	case size == 0:
39: 		return nil
40: 	case size > 65536:
41: 		return make([]byte, size)
42: 	default:
43: 		bits := msb(size)
44: 		if size == 1<<bits {
45: 			return alloc.buffers[bits].Get().([]byte)[:size]
46: 		}
47: 
48: 		return alloc.buffers[bits+1].Get().([]byte)[:size]
49: 	}
50: }
51: 
52: // Put returns a []byte to pool for future use,
53: // which the cap must be exactly 2^n
54: func (alloc *Allocator) Put(buf []byte) error {
55: 	if cap(buf) == 0 || cap(buf) > 65536 {
56: 		return nil
57: 	}
58: 
59: 	bits := msb(cap(buf))
60: 	if cap(buf) != 1<<bits {
61: 		return errors.New("allocator Put() incorrect buffer size")
62: 	}
63: 
64: 	//nolint
65: 	//lint:ignore SA6002 ignore temporarily
66: 	alloc.buffers[bits].Put(buf)
67: 	return nil
68: }
69: 
70: // msb return the pos of most significant bit
71: func msb(size int) uint16 {
72: 	return uint16(bits.Len32(uint32(size)) - 1)
73: }


./common\pool\alloc_test.go
1: package pool
2: 
3: import (
4: 	"math/rand"
5: 	"testing"
6: 
7: 	"github.com/stretchr/testify/assert"
8: )
9: 
10: func TestAllocGet(t *testing.T) {
11: 	alloc := NewAllocator()
12: 	assert.Nil(t, alloc.Get(0))
13: 	assert.Equal(t, 1, len(alloc.Get(1)))
14: 	assert.Equal(t, 2, len(alloc.Get(2)))
15: 	assert.Equal(t, 3, len(alloc.Get(3)))
16: 	assert.Equal(t, 4, cap(alloc.Get(3)))
17: 	assert.Equal(t, 4, cap(alloc.Get(4)))
18: 	assert.Equal(t, 1023, len(alloc.Get(1023)))
19: 	assert.Equal(t, 1024, cap(alloc.Get(1023)))
20: 	assert.Equal(t, 1024, len(alloc.Get(1024)))
21: 	assert.Equal(t, 65536, len(alloc.Get(65536)))
22: 	assert.Equal(t, 65537, len(alloc.Get(65537)))
23: }
24: 
25: func TestAllocPut(t *testing.T) {
26: 	alloc := NewAllocator()
27: 	assert.Nil(t, alloc.Put(nil), "put nil misbehavior")
28: 	assert.NotNil(t, alloc.Put(make([]byte, 3)), "put elem:3 []bytes misbehavior")
29: 	assert.Nil(t, alloc.Put(make([]byte, 4)), "put elem:4 []bytes misbehavior")
30: 	assert.Nil(t, alloc.Put(make([]byte, 1023, 1024)), "put elem:1024 []bytes misbehavior")
31: 	assert.Nil(t, alloc.Put(make([]byte, 65536)), "put elem:65536 []bytes misbehavior")
32: 	assert.Nil(t, alloc.Put(make([]byte, 65537)), "put elem:65537 []bytes misbehavior")
33: }
34: 
35: func TestAllocPutThenGet(t *testing.T) {
36: 	alloc := NewAllocator()
37: 	data := alloc.Get(4)
38: 	alloc.Put(data)
39: 	newData := alloc.Get(4)
40: 
41: 	assert.Equal(t, cap(data), cap(newData), "different cap while alloc.Get()")
42: }
43: 
44: func BenchmarkMSB(b *testing.B) {
45: 	for i := 0; i < b.N; i++ {
46: 		msb(rand.Int())
47: 	}
48: }


./common\pool\buffer.go
1: package pool
2: 
3: import (
4: 	"bytes"
5: 	"sync"
6: 
7: 	"github.com/Dreamacro/protobytes"
8: )
9: 
10: var (
11: 	bufferPool      = sync.Pool{New: func() any { return &bytes.Buffer{} }}
12: 	bytesBufferPool = sync.Pool{New: func() any { return &protobytes.BytesWriter{} }}
13: )
14: 
15: func GetBuffer() *bytes.Buffer {
16: 	return bufferPool.Get().(*bytes.Buffer)
17: }
18: 
19: func PutBuffer(buf *bytes.Buffer) {
20: 	buf.Reset()
21: 	bufferPool.Put(buf)
22: }
23: 
24: func GetBytesBuffer() *protobytes.BytesWriter {
25: 	return bytesBufferPool.Get().(*protobytes.BytesWriter)
26: }
27: 
28: func PutBytesBuffer(buf *protobytes.BytesWriter) {
29: 	buf.Reset()
30: 	bytesBufferPool.Put(buf)
31: }


./common\pool\pool.go
1: package pool
2: 
3: const (
4: 	// io.Copy default buffer size is 32 KiB
5: 	// but the maximum packet size of vmess/shadowsocks is about 16 KiB
6: 	// so define a buffer of 20 KiB to reduce the memory of each TCP relay
7: 	RelayBufferSize = 20 * 1024
8: 
9: 	// RelayBufferSize uses 20KiB, but due to the allocator it will actually
10: 	// request 32Kib. Most UDPs are smaller than the MTU, and the TUN's MTU
11: 	// set to 9000, so the UDP Buffer size set to 16Kib
12: 	UDPBufferSize = 16 * 1024
13: )
14: 
15: func Get(size int) []byte {
16: 	return defaultAllocator.Get(size)
17: }
18: 
19: func Put(buf []byte) error {
20: 	return defaultAllocator.Put(buf)
21: }


./common\queue\queue.go
1: package queue
2: 
3: import (
4: 	"sync"
5: )
6: 
7: // Queue is a simple concurrent safe queue
8: type Queue struct {
9: 	items []any
10: 	lock  sync.RWMutex
11: }
12: 
13: // Put add the item to the queue.
14: func (q *Queue) Put(items ...any) {
15: 	if len(items) == 0 {
16: 		return
17: 	}
18: 
19: 	q.lock.Lock()
20: 	q.items = append(q.items, items...)
21: 	q.lock.Unlock()
22: }
23: 
24: // Pop returns the head of items.
25: func (q *Queue) Pop() any {
26: 	if len(q.items) == 0 {
27: 		return nil
28: 	}
29: 
30: 	q.lock.Lock()
31: 	head := q.items[0]
32: 	q.items = q.items[1:]
33: 	q.lock.Unlock()
34: 	return head
35: }
36: 
37: // Last returns the last of item.
38: func (q *Queue) Last() any {
39: 	if len(q.items) == 0 {
40: 		return nil
41: 	}
42: 
43: 	q.lock.RLock()
44: 	last := q.items[len(q.items)-1]
45: 	q.lock.RUnlock()
46: 	return last
47: }
48: 
49: // Copy get the copy of queue.
50: func (q *Queue) Copy() []any {
51: 	items := []any{}
52: 	q.lock.RLock()
53: 	items = append(items, q.items...)
54: 	q.lock.RUnlock()
55: 	return items
56: }
57: 
58: // Len returns the number of items in this queue.
59: func (q *Queue) Len() int64 {
60: 	q.lock.Lock()
61: 	defer q.lock.Unlock()
62: 
63: 	return int64(len(q.items))
64: }
65: 
66: // New is a constructor for a new concurrent safe queue.
67: func New(hint int64) *Queue {
68: 	return &Queue{
69: 		items: make([]any, 0, hint),
70: 	}
71: }


./common\singledo\singledo.go
1: package singledo
2: 
3: import (
4: 	"sync"
5: 	"time"
6: )
7: 
8: type call struct {
9: 	wg  sync.WaitGroup
10: 	val any
11: 	err error
12: }
13: 
14: type Single struct {
15: 	mux    sync.Mutex
16: 	last   time.Time
17: 	wait   time.Duration
18: 	call   *call
19: 	result *Result
20: }
21: 
22: type Result struct {
23: 	Val any
24: 	Err error
25: }
26: 
27: // Do single.Do likes sync.singleFlight
28: func (s *Single) Do(fn func() (any, error)) (v any, err error, shared bool) {
29: 	s.mux.Lock()
30: 	now := time.Now()
31: 	if now.Before(s.last.Add(s.wait)) {
32: 		s.mux.Unlock()
33: 		return s.result.Val, s.result.Err, true
34: 	}
35: 
36: 	if call := s.call; call != nil {
37: 		s.mux.Unlock()
38: 		call.wg.Wait()
39: 		return call.val, call.err, true
40: 	}
41: 
42: 	call := &call{}
43: 	call.wg.Add(1)
44: 	s.call = call
45: 	s.mux.Unlock()
46: 	call.val, call.err = fn()
47: 	call.wg.Done()
48: 
49: 	s.mux.Lock()
50: 	s.call = nil
51: 	s.result = &Result{call.val, call.err}
52: 	s.last = now
53: 	s.mux.Unlock()
54: 	return call.val, call.err, false
55: }
56: 
57: func (s *Single) Reset() {
58: 	s.last = time.Time{}
59: }
60: 
61: func NewSingle(wait time.Duration) *Single {
62: 	return &Single{wait: wait}
63: }


./common\singledo\singledo_test.go
1: package singledo
2: 
3: import (
4: 	"sync"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/stretchr/testify/assert"
9: 	"go.uber.org/atomic"
10: )
11: 
12: func TestBasic(t *testing.T) {
13: 	single := NewSingle(time.Millisecond * 30)
14: 	foo := 0
15: 	shardCount := atomic.NewInt32(0)
16: 	call := func() (any, error) {
17: 		foo++
18: 		time.Sleep(time.Millisecond * 5)
19: 		return nil, nil
20: 	}
21: 
22: 	var wg sync.WaitGroup
23: 	const n = 5
24: 	wg.Add(n)
25: 	for i := 0; i < n; i++ {
26: 		go func() {
27: 			_, _, shard := single.Do(call)
28: 			if shard {
29: 				shardCount.Inc()
30: 			}
31: 			wg.Done()
32: 		}()
33: 	}
34: 
35: 	wg.Wait()
36: 	assert.Equal(t, 1, foo)
37: 	assert.Equal(t, int32(4), shardCount.Load())
38: }
39: 
40: func TestTimer(t *testing.T) {
41: 	single := NewSingle(time.Millisecond * 30)
42: 	foo := 0
43: 	call := func() (any, error) {
44: 		foo++
45: 		return nil, nil
46: 	}
47: 
48: 	single.Do(call)
49: 	time.Sleep(10 * time.Millisecond)
50: 	_, _, shard := single.Do(call)
51: 
52: 	assert.Equal(t, 1, foo)
53: 	assert.True(t, shard)
54: }
55: 
56: func TestReset(t *testing.T) {
57: 	single := NewSingle(time.Millisecond * 30)
58: 	foo := 0
59: 	call := func() (any, error) {
60: 		foo++
61: 		return nil, nil
62: 	}
63: 
64: 	single.Do(call)
65: 	single.Reset()
66: 	single.Do(call)
67: 
68: 	assert.Equal(t, 2, foo)
69: }


./common\sockopt\reuseaddr_linux.go
1: package sockopt
2: 
3: import (
4: 	"net"
5: 	"syscall"
6: )
7: 
8: func UDPReuseaddr(c *net.UDPConn) (err error) {
9: 	rc, err := c.SyscallConn()
10: 	if err != nil {
11: 		return
12: 	}
13: 
14: 	rc.Control(func(fd uintptr) {
15: 		err = syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)
16: 	})
17: 
18: 	return
19: }


./common\sockopt\reuseaddr_other.go
1: //go:build !linux
2: 
3: package sockopt
4: 
5: import (
6: 	"net"
7: )
8: 
9: func UDPReuseaddr(c *net.UDPConn) (err error) {
10: 	return
11: }


./common\structure\structure.go
1: package structure
2: 
3: // references: https://github.com/mitchellh/mapstructure
4: 
5: import (
6: 	"fmt"
7: 	"reflect"
8: 	"strconv"
9: 	"strings"
10: )
11: 
12: // Option is the configuration that is used to create a new decoder
13: type Option struct {
14: 	TagName          string
15: 	WeaklyTypedInput bool
16: }
17: 
18: // Decoder is the core of structure
19: type Decoder struct {
20: 	option *Option
21: }
22: 
23: // NewDecoder return a Decoder by Option
24: func NewDecoder(option Option) *Decoder {
25: 	if option.TagName == "" {
26: 		option.TagName = "structure"
27: 	}
28: 	return &Decoder{option: &option}
29: }
30: 
31: // Decode transform a map[string]any to a struct
32: func (d *Decoder) Decode(src map[string]any, dst any) error {
33: 	if reflect.TypeOf(dst).Kind() != reflect.Ptr {
34: 		return fmt.Errorf("Decode must recive a ptr struct")
35: 	}
36: 	t := reflect.TypeOf(dst).Elem()
37: 	v := reflect.ValueOf(dst).Elem()
38: 	for idx := 0; idx < v.NumField(); idx++ {
39: 		field := t.Field(idx)
40: 		if field.Anonymous {
41: 			if err := d.decodeStruct(field.Name, src, v.Field(idx)); err != nil {
42: 				return err
43: 			}
44: 			continue
45: 		}
46: 
47: 		tag := field.Tag.Get(d.option.TagName)
48: 		key, omitKey, found := strings.Cut(tag, ",")
49: 		omitempty := found && omitKey == "omitempty"
50: 
51: 		value, ok := src[key]
52: 		if !ok || value == nil {
53: 			if omitempty {
54: 				continue
55: 			}
56: 			return fmt.Errorf("key '%s' missing", key)
57: 		}
58: 
59: 		err := d.decode(key, value, v.Field(idx))
60: 		if err != nil {
61: 			return err
62: 		}
63: 	}
64: 	return nil
65: }
66: 
67: func (d *Decoder) decode(name string, data any, val reflect.Value) error {
68: 	switch val.Kind() {
69: 	case reflect.Int:
70: 		return d.decodeInt(name, data, val)
71: 	case reflect.String:
72: 		return d.decodeString(name, data, val)
73: 	case reflect.Bool:
74: 		return d.decodeBool(name, data, val)
75: 	case reflect.Slice:
76: 		return d.decodeSlice(name, data, val)
77: 	case reflect.Map:
78: 		return d.decodeMap(name, data, val)
79: 	case reflect.Interface:
80: 		return d.setInterface(name, data, val)
81: 	case reflect.Struct:
82: 		return d.decodeStruct(name, data, val)
83: 	default:
84: 		return fmt.Errorf("type %s not support", val.Kind().String())
85: 	}
86: }
87: 
88: func (d *Decoder) decodeInt(name string, data any, val reflect.Value) (err error) {
89: 	dataVal := reflect.ValueOf(data)
90: 	kind := dataVal.Kind()
91: 	switch {
92: 	case kind == reflect.Int:
93: 		val.SetInt(dataVal.Int())
94: 	case kind == reflect.Float64 && d.option.WeaklyTypedInput:
95: 		val.SetInt(int64(dataVal.Float()))
96: 	case kind == reflect.String && d.option.WeaklyTypedInput:
97: 		var i int64
98: 		i, err = strconv.ParseInt(dataVal.String(), 0, val.Type().Bits())
99: 		if err == nil {
100: 			val.SetInt(i)
101: 		} else {
102: 			err = fmt.Errorf("cannot parse '%s' as int: %s", name, err)
103: 		}
104: 	default:
105: 		err = fmt.Errorf(
106: 			"'%s' expected type '%s', got unconvertible type '%s'",
107: 			name, val.Type(), dataVal.Type(),
108: 		)
109: 	}
110: 	return err
111: }
112: 
113: func (d *Decoder) decodeString(name string, data any, val reflect.Value) (err error) {
114: 	dataVal := reflect.ValueOf(data)
115: 	kind := dataVal.Kind()
116: 	switch {
117: 	case kind == reflect.String:
118: 		val.SetString(dataVal.String())
119: 	case kind == reflect.Int && d.option.WeaklyTypedInput:
120: 		val.SetString(strconv.FormatInt(dataVal.Int(), 10))
121: 	default:
122: 		err = fmt.Errorf(
123: 			"'%s' expected type '%s', got unconvertible type '%s'",
124: 			name, val.Type(), dataVal.Type(),
125: 		)
126: 	}
127: 	return err
128: }
129: 
130: func (d *Decoder) decodeBool(name string, data any, val reflect.Value) (err error) {
131: 	dataVal := reflect.ValueOf(data)
132: 	kind := dataVal.Kind()
133: 	switch {
134: 	case kind == reflect.Bool:
135: 		val.SetBool(dataVal.Bool())
136: 	case kind == reflect.Int && d.option.WeaklyTypedInput:
137: 		val.SetBool(dataVal.Int() != 0)
138: 	default:
139: 		err = fmt.Errorf(
140: 			"'%s' expected type '%s', got unconvertible type '%s'",
141: 			name, val.Type(), dataVal.Type(),
142: 		)
143: 	}
144: 	return err
145: }
146: 
147: func (d *Decoder) decodeSlice(name string, data any, val reflect.Value) error {
148: 	dataVal := reflect.Indirect(reflect.ValueOf(data))
149: 	valType := val.Type()
150: 	valElemType := valType.Elem()
151: 
152: 	if dataVal.Kind() != reflect.Slice {
153: 		return fmt.Errorf("'%s' is not a slice", name)
154: 	}
155: 
156: 	valSlice := val
157: 	for i := 0; i < dataVal.Len(); i++ {
158: 		currentData := dataVal.Index(i).Interface()
159: 		for valSlice.Len() <= i {
160: 			valSlice = reflect.Append(valSlice, reflect.Zero(valElemType))
161: 		}
162: 		fieldName := fmt.Sprintf("%s[%d]", name, i)
163: 		if currentData == nil {
164: 			// in weakly type mode, null will convert to zero value
165: 			if d.option.WeaklyTypedInput {
166: 				continue
167: 			}
168: 			// in non-weakly type mode, null will convert to nil if element's zero value is nil, otherwise return an error
169: 			if elemKind := valElemType.Kind(); elemKind == reflect.Map || elemKind == reflect.Slice {
170: 				continue
171: 			}
172: 			return fmt.Errorf("'%s' can not be null", fieldName)
173: 		}
174: 		currentField := valSlice.Index(i)
175: 		if err := d.decode(fieldName, currentData, currentField); err != nil {
176: 			return err
177: 		}
178: 	}
179: 
180: 	val.Set(valSlice)
181: 	return nil
182: }
183: 
184: func (d *Decoder) decodeMap(name string, data any, val reflect.Value) error {
185: 	valType := val.Type()
186: 	valKeyType := valType.Key()
187: 	valElemType := valType.Elem()
188: 
189: 	valMap := val
190: 
191: 	if valMap.IsNil() {
192: 		mapType := reflect.MapOf(valKeyType, valElemType)
193: 		valMap = reflect.MakeMap(mapType)
194: 	}
195: 
196: 	dataVal := reflect.Indirect(reflect.ValueOf(data))
197: 	if dataVal.Kind() != reflect.Map {
198: 		return fmt.Errorf("'%s' expected a map, got '%s'", name, dataVal.Kind())
199: 	}
200: 
201: 	return d.decodeMapFromMap(name, dataVal, val, valMap)
202: }
203: 
204: func (d *Decoder) decodeMapFromMap(name string, dataVal reflect.Value, val reflect.Value, valMap reflect.Value) error {
205: 	valType := val.Type()
206: 	valKeyType := valType.Key()
207: 	valElemType := valType.Elem()
208: 
209: 	errors := make([]string, 0)
210: 
211: 	if dataVal.Len() == 0 {
212: 		if dataVal.IsNil() {
213: 			if !val.IsNil() {
214: 				val.Set(dataVal)
215: 			}
216: 		} else {
217: 			val.Set(valMap)
218: 		}
219: 
220: 		return nil
221: 	}
222: 
223: 	for _, k := range dataVal.MapKeys() {
224: 		fieldName := fmt.Sprintf("%s[%s]", name, k)
225: 
226: 		currentKey := reflect.Indirect(reflect.New(valKeyType))
227: 		if err := d.decode(fieldName, k.Interface(), currentKey); err != nil {
228: 			errors = append(errors, err.Error())
229: 			continue
230: 		}
231: 
232: 		v := dataVal.MapIndex(k).Interface()
233: 		if v == nil {
234: 			errors = append(errors, fmt.Sprintf("filed %s invalid", fieldName))
235: 			continue
236: 		}
237: 
238: 		currentVal := reflect.Indirect(reflect.New(valElemType))
239: 		if err := d.decode(fieldName, v, currentVal); err != nil {
240: 			errors = append(errors, err.Error())
241: 			continue
242: 		}
243: 
244: 		valMap.SetMapIndex(currentKey, currentVal)
245: 	}
246: 
247: 	val.Set(valMap)
248: 
249: 	if len(errors) > 0 {
250: 		return fmt.Errorf(strings.Join(errors, ","))
251: 	}
252: 
253: 	return nil
254: }
255: 
256: func (d *Decoder) decodeStruct(name string, data any, val reflect.Value) error {
257: 	dataVal := reflect.Indirect(reflect.ValueOf(data))
258: 
259: 	// If the type of the value to write to and the data match directly,
260: 	// then we just set it directly instead of recursing into the structure.
261: 	if dataVal.Type() == val.Type() {
262: 		val.Set(dataVal)
263: 		return nil
264: 	}
265: 
266: 	dataValKind := dataVal.Kind()
267: 	switch dataValKind {
268: 	case reflect.Map:
269: 		return d.decodeStructFromMap(name, dataVal, val)
270: 	default:
271: 		return fmt.Errorf("'%s' expected a map, got '%s'", name, dataVal.Kind())
272: 	}
273: }
274: 
275: func (d *Decoder) decodeStructFromMap(name string, dataVal, val reflect.Value) error {
276: 	dataValType := dataVal.Type()
277: 	if kind := dataValType.Key().Kind(); kind != reflect.String && kind != reflect.Interface {
278: 		return fmt.Errorf(
279: 			"'%s' needs a map with string keys, has '%s' keys",
280: 			name, dataValType.Key().Kind())
281: 	}
282: 
283: 	dataValKeys := make(map[reflect.Value]struct{})
284: 	dataValKeysUnused := make(map[any]struct{})
285: 	for _, dataValKey := range dataVal.MapKeys() {
286: 		dataValKeys[dataValKey] = struct{}{}
287: 		dataValKeysUnused[dataValKey.Interface()] = struct{}{}
288: 	}
289: 
290: 	errors := make([]string, 0)
291: 
292: 	// This slice will keep track of all the structs we'll be decoding.
293: 	// There can be more than one struct if there are embedded structs
294: 	// that are squashed.
295: 	structs := make([]reflect.Value, 1, 5)
296: 	structs[0] = val
297: 
298: 	// Compile the list of all the fields that we're going to be decoding
299: 	// from all the structs.
300: 	type field struct {
301: 		field reflect.StructField
302: 		val   reflect.Value
303: 	}
304: 	fields := []field{}
305: 	for len(structs) > 0 {
306: 		structVal := structs[0]
307: 		structs = structs[1:]
308: 
309: 		structType := structVal.Type()
310: 
311: 		for i := 0; i < structType.NumField(); i++ {
312: 			fieldType := structType.Field(i)
313: 			fieldKind := fieldType.Type.Kind()
314: 
315: 			// If "squash" is specified in the tag, we squash the field down.
316: 			squash := false
317: 			tagParts := strings.Split(fieldType.Tag.Get(d.option.TagName), ",")
318: 			for _, tag := range tagParts[1:] {
319: 				if tag == "squash" {
320: 					squash = true
321: 					break
322: 				}
323: 			}
324: 
325: 			if squash {
326: 				if fieldKind != reflect.Struct {
327: 					errors = append(errors,
328: 						fmt.Errorf("%s: unsupported type for squash: %s", fieldType.Name, fieldKind).Error())
329: 				} else {
330: 					structs = append(structs, structVal.FieldByName(fieldType.Name))
331: 				}
332: 				continue
333: 			}
334: 
335: 			// Normal struct field, store it away
336: 			fields = append(fields, field{fieldType, structVal.Field(i)})
337: 		}
338: 	}
339: 
340: 	// for fieldType, field := range fields {
341: 	for _, f := range fields {
342: 		field, fieldValue := f.field, f.val
343: 		fieldName := field.Name
344: 
345: 		tagValue := field.Tag.Get(d.option.TagName)
346: 		tagValue = strings.SplitN(tagValue, ",", 2)[0]
347: 		if tagValue != "" {
348: 			fieldName = tagValue
349: 		}
350: 
351: 		rawMapKey := reflect.ValueOf(fieldName)
352: 		rawMapVal := dataVal.MapIndex(rawMapKey)
353: 		if !rawMapVal.IsValid() {
354: 			// Do a slower search by iterating over each key and
355: 			// doing case-insensitive search.
356: 			for dataValKey := range dataValKeys {
357: 				mK, ok := dataValKey.Interface().(string)
358: 				if !ok {
359: 					// Not a string key
360: 					continue
361: 				}
362: 
363: 				if strings.EqualFold(mK, fieldName) {
364: 					rawMapKey = dataValKey
365: 					rawMapVal = dataVal.MapIndex(dataValKey)
366: 					break
367: 				}
368: 			}
369: 
370: 			if !rawMapVal.IsValid() {
371: 				// There was no matching key in the map for the value in
372: 				// the struct. Just ignore.
373: 				continue
374: 			}
375: 		}
376: 
377: 		// Delete the key we're using from the unused map so we stop tracking
378: 		delete(dataValKeysUnused, rawMapKey.Interface())
379: 
380: 		if !fieldValue.IsValid() {
381: 			// This should never happen
382: 			panic("field is not valid")
383: 		}
384: 
385: 		// If we can't set the field, then it is unexported or something,
386: 		// and we just continue onwards.
387: 		if !fieldValue.CanSet() {
388: 			continue
389: 		}
390: 
391: 		// If the name is empty string, then we're at the root, and we
392: 		// don't dot-join the fields.
393: 		if name != "" {
394: 			fieldName = fmt.Sprintf("%s.%s", name, fieldName)
395: 		}
396: 
397: 		if err := d.decode(fieldName, rawMapVal.Interface(), fieldValue); err != nil {
398: 			errors = append(errors, err.Error())
399: 		}
400: 	}
401: 
402: 	if len(errors) > 0 {
403: 		return fmt.Errorf(strings.Join(errors, ","))
404: 	}
405: 
406: 	return nil
407: }
408: 
409: func (d *Decoder) setInterface(name string, data any, val reflect.Value) (err error) {
410: 	dataVal := reflect.ValueOf(data)
411: 	val.Set(dataVal)
412: 	return nil
413: }


./common\structure\structure_test.go
1: package structure
2: 
3: import (
4: 	"testing"
5: 
6: 	"github.com/stretchr/testify/assert"
7: )
8: 
9: var (
10: 	decoder         = NewDecoder(Option{TagName: "test"})
11: 	weakTypeDecoder = NewDecoder(Option{TagName: "test", WeaklyTypedInput: true})
12: )
13: 
14: type Baz struct {
15: 	Foo int    `test:"foo"`
16: 	Bar string `test:"bar"`
17: }
18: 
19: type BazSlice struct {
20: 	Foo int      `test:"foo"`
21: 	Bar []string `test:"bar"`
22: }
23: 
24: type BazOptional struct {
25: 	Foo int    `test:"foo,omitempty"`
26: 	Bar string `test:"bar,omitempty"`
27: }
28: 
29: func TestStructure_Basic(t *testing.T) {
30: 	rawMap := map[string]any{
31: 		"foo":   1,
32: 		"bar":   "test",
33: 		"extra": false,
34: 	}
35: 
36: 	goal := &Baz{
37: 		Foo: 1,
38: 		Bar: "test",
39: 	}
40: 
41: 	s := &Baz{}
42: 	err := decoder.Decode(rawMap, s)
43: 	assert.Nil(t, err)
44: 	assert.Equal(t, goal, s)
45: }
46: 
47: func TestStructure_Slice(t *testing.T) {
48: 	rawMap := map[string]any{
49: 		"foo": 1,
50: 		"bar": []string{"one", "two"},
51: 	}
52: 
53: 	goal := &BazSlice{
54: 		Foo: 1,
55: 		Bar: []string{"one", "two"},
56: 	}
57: 
58: 	s := &BazSlice{}
59: 	err := decoder.Decode(rawMap, s)
60: 	assert.Nil(t, err)
61: 	assert.Equal(t, goal, s)
62: }
63: 
64: func TestStructure_Optional(t *testing.T) {
65: 	rawMap := map[string]any{
66: 		"foo": 1,
67: 	}
68: 
69: 	goal := &BazOptional{
70: 		Foo: 1,
71: 	}
72: 
73: 	s := &BazOptional{}
74: 	err := decoder.Decode(rawMap, s)
75: 	assert.Nil(t, err)
76: 	assert.Equal(t, goal, s)
77: }
78: 
79: func TestStructure_MissingKey(t *testing.T) {
80: 	rawMap := map[string]any{
81: 		"foo": 1,
82: 	}
83: 
84: 	s := &Baz{}
85: 	err := decoder.Decode(rawMap, s)
86: 	assert.NotNilf(t, err, "should throw error: %#v", s)
87: }
88: 
89: func TestStructure_ParamError(t *testing.T) {
90: 	rawMap := map[string]any{}
91: 	s := Baz{}
92: 	err := decoder.Decode(rawMap, s)
93: 	assert.NotNilf(t, err, "should throw error: %#v", s)
94: }
95: 
96: func TestStructure_SliceTypeError(t *testing.T) {
97: 	rawMap := map[string]any{
98: 		"foo": 1,
99: 		"bar": []int{1, 2},
100: 	}
101: 
102: 	s := &BazSlice{}
103: 	err := decoder.Decode(rawMap, s)
104: 	assert.NotNilf(t, err, "should throw error: %#v", s)
105: }
106: 
107: func TestStructure_WeakType(t *testing.T) {
108: 	rawMap := map[string]any{
109: 		"foo": "1",
110: 		"bar": []int{1},
111: 	}
112: 
113: 	goal := &BazSlice{
114: 		Foo: 1,
115: 		Bar: []string{"1"},
116: 	}
117: 
118: 	s := &BazSlice{}
119: 	err := weakTypeDecoder.Decode(rawMap, s)
120: 	assert.Nil(t, err)
121: 	assert.Equal(t, goal, s)
122: }
123: 
124: func TestStructure_Nest(t *testing.T) {
125: 	rawMap := map[string]any{
126: 		"foo": 1,
127: 	}
128: 
129: 	goal := BazOptional{
130: 		Foo: 1,
131: 	}
132: 
133: 	s := &struct {
134: 		BazOptional
135: 	}{}
136: 	err := decoder.Decode(rawMap, s)
137: 	assert.Nil(t, err)
138: 	assert.Equal(t, s.BazOptional, goal)
139: }
140: 
141: func TestStructure_SliceNilValue(t *testing.T) {
142: 	rawMap := map[string]any{
143: 		"foo": 1,
144: 		"bar": []any{"bar", nil},
145: 	}
146: 
147: 	goal := &BazSlice{
148: 		Foo: 1,
149: 		Bar: []string{"bar", ""},
150: 	}
151: 
152: 	s := &BazSlice{}
153: 	err := weakTypeDecoder.Decode(rawMap, s)
154: 	assert.Nil(t, err)
155: 	assert.Equal(t, goal.Bar, s.Bar)
156: 
157: 	s = &BazSlice{}
158: 	err = decoder.Decode(rawMap, s)
159: 	assert.NotNil(t, err)
160: }
161: 
162: func TestStructure_SliceNilValueComplex(t *testing.T) {
163: 	rawMap := map[string]any{
164: 		"bar": []any{map[string]any{"bar": "foo"}, nil},
165: 	}
166: 
167: 	s := &struct {
168: 		Bar []map[string]any `test:"bar"`
169: 	}{}
170: 
171: 	err := decoder.Decode(rawMap, s)
172: 	assert.Nil(t, err)
173: 	assert.Nil(t, s.Bar[1])
174: 
175: 	ss := &struct {
176: 		Bar []Baz `test:"bar"`
177: 	}{}
178: 
179: 	err = decoder.Decode(rawMap, ss)
180: 	assert.NotNil(t, err)
181: }


./common\util\manipulation.go
1: package util
2: 
3: import "github.com/samber/lo"
4: 
5: func EmptyOr[T comparable](v T, def T) T {
6: 	ret, _ := lo.Coalesce(v, def)
7: 	return ret
8: }


./component\auth\auth.go
1: package auth
2: 
3: import (
4: 	"sync"
5: )
6: 
7: type Authenticator interface {
8: 	Verify(user string, pass string) bool
9: 	Users() []string
10: }
11: 
12: type AuthUser struct {
13: 	User string
14: 	Pass string
15: }
16: 
17: type inMemoryAuthenticator struct {
18: 	storage   *sync.Map
19: 	usernames []string
20: }
21: 
22: func (au *inMemoryAuthenticator) Verify(user string, pass string) bool {
23: 	realPass, ok := au.storage.Load(user)
24: 	return ok && realPass == pass
25: }
26: 
27: func (au *inMemoryAuthenticator) Users() []string { return au.usernames }
28: 
29: func NewAuthenticator(users []AuthUser) Authenticator {
30: 	if len(users) == 0 {
31: 		return nil
32: 	}
33: 
34: 	au := &inMemoryAuthenticator{storage: &sync.Map{}}
35: 	for _, user := range users {
36: 		au.storage.Store(user.User, user.Pass)
37: 	}
38: 	usernames := make([]string, 0, len(users))
39: 	au.storage.Range(func(key, value any) bool {
40: 		usernames = append(usernames, key.(string))
41: 		return true
42: 	})
43: 	au.usernames = usernames
44: 
45: 	return au
46: }


./component\dhcp\conn.go
1: package dhcp
2: 
3: import (
4: 	"context"
5: 	"net"
6: 	"runtime"
7: 
8: 	"github.com/Dreamacro/clash/component/dialer"
9: )
10: 
11: func ListenDHCPClient(ctx context.Context, ifaceName string) (net.PacketConn, error) {
12: 	listenAddr := "0.0.0.0:68"
13: 	if runtime.GOOS == "linux" || runtime.GOOS == "android" {
14: 		listenAddr = "255.255.255.255:68"
15: 	}
16: 
17: 	options := []dialer.Option{
18: 		dialer.WithInterface(ifaceName),
19: 		dialer.WithAddrReuse(true),
20: 	}
21: 
22: 	// fallback bind on windows, because syscall bind can not receive broadcast
23: 	if runtime.GOOS == "windows" {
24: 		options = append(options, dialer.WithFallbackBind(true))
25: 	}
26: 
27: 	return dialer.ListenPacket(ctx, "udp4", listenAddr, options...)
28: }


./component\dhcp\dhcp.go
1: package dhcp
2: 
3: import (
4: 	"context"
5: 	"errors"
6: 	"net"
7: 
8: 	"github.com/Dreamacro/clash/component/iface"
9: 
10: 	"github.com/insomniacslk/dhcp/dhcpv4"
11: )
12: 
13: var (
14: 	ErrNotResponding = errors.New("DHCP not responding")
15: 	ErrNotFound      = errors.New("DNS option not found")
16: )
17: 
18: func ResolveDNSFromDHCP(context context.Context, ifaceName string) ([]net.IP, error) {
19: 	conn, err := ListenDHCPClient(context, ifaceName)
20: 	if err != nil {
21: 		return nil, err
22: 	}
23: 	defer conn.Close()
24: 
25: 	result := make(chan []net.IP, 1)
26: 
27: 	ifaceObj, err := iface.ResolveInterface(ifaceName)
28: 	if err != nil {
29: 		return nil, err
30: 	}
31: 
32: 	discovery, err := dhcpv4.NewDiscovery(ifaceObj.HardwareAddr, dhcpv4.WithBroadcast(true), dhcpv4.WithRequestedOptions(dhcpv4.OptionDomainNameServer))
33: 	if err != nil {
34: 		return nil, err
35: 	}
36: 
37: 	go receiveOffer(conn, discovery.TransactionID, result)
38: 
39: 	_, err = conn.WriteTo(discovery.ToBytes(), &net.UDPAddr{IP: net.IPv4bcast, Port: 67})
40: 	if err != nil {
41: 		return nil, err
42: 	}
43: 
44: 	select {
45: 	case r, ok := <-result:
46: 		if !ok {
47: 			return nil, ErrNotFound
48: 		}
49: 		return r, nil
50: 	case <-context.Done():
51: 		return nil, ErrNotResponding
52: 	}
53: }
54: 
55: func receiveOffer(conn net.PacketConn, id dhcpv4.TransactionID, result chan<- []net.IP) {
56: 	defer close(result)
57: 
58: 	buf := make([]byte, dhcpv4.MaxMessageSize)
59: 
60: 	for {
61: 		n, _, err := conn.ReadFrom(buf)
62: 		if err != nil {
63: 			return
64: 		}
65: 
66: 		pkt, err := dhcpv4.FromBytes(buf[:n])
67: 		if err != nil {
68: 			continue
69: 		}
70: 
71: 		if pkt.MessageType() != dhcpv4.MessageTypeOffer {
72: 			continue
73: 		}
74: 
75: 		if pkt.TransactionID != id {
76: 			continue
77: 		}
78: 
79: 		dns := pkt.DNS()
80: 		if len(dns) == 0 {
81: 			return
82: 		}
83: 
84: 		result <- dns
85: 
86: 		return
87: 	}
88: }


./component\dialer\bind_darwin.go
1: package dialer
2: 
3: import (
4: 	"net"
5: 	"syscall"
6: 
7: 	"github.com/Dreamacro/clash/component/iface"
8: 
9: 	"golang.org/x/sys/unix"
10: )
11: 
12: type controlFn = func(network, address string, c syscall.RawConn) error
13: 
14: func bindControl(ifaceIdx int, chain controlFn) controlFn {
15: 	return func(network, address string, c syscall.RawConn) (err error) {
16: 		defer func() {
17: 			if err == nil && chain != nil {
18: 				err = chain(network, address, c)
19: 			}
20: 		}()
21: 
22: 		ipStr, _, err := net.SplitHostPort(address)
23: 		if err == nil {
24: 			ip := net.ParseIP(ipStr)
25: 			if ip != nil && !ip.IsGlobalUnicast() {
26: 				return
27: 			}
28: 		}
29: 
30: 		var innerErr error
31: 		err = c.Control(func(fd uintptr) {
32: 			switch network {
33: 			case "tcp4", "udp4":
34: 				innerErr = unix.SetsockoptInt(int(fd), unix.IPPROTO_IP, unix.IP_BOUND_IF, ifaceIdx)
35: 			case "tcp6", "udp6":
36: 				innerErr = unix.SetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_BOUND_IF, ifaceIdx)
37: 			}
38: 		})
39: 
40: 		if innerErr != nil {
41: 			err = innerErr
42: 		}
43: 
44: 		return
45: 	}
46: }
47: 
48: func bindIfaceToDialer(ifaceName string, dialer *net.Dialer, _ string, _ net.IP) error {
49: 	ifaceObj, err := iface.ResolveInterface(ifaceName)
50: 	if err != nil {
51: 		return err
52: 	}
53: 
54: 	dialer.Control = bindControl(ifaceObj.Index, dialer.Control)
55: 	return nil
56: }
57: 
58: func bindIfaceToListenConfig(ifaceName string, lc *net.ListenConfig, _, address string) (string, error) {
59: 	ifaceObj, err := iface.ResolveInterface(ifaceName)
60: 	if err != nil {
61: 		return "", err
62: 	}
63: 
64: 	lc.Control = bindControl(ifaceObj.Index, lc.Control)
65: 	return address, nil
66: }


./component\dialer\bind_linux.go
1: package dialer
2: 
3: import (
4: 	"net"
5: 	"syscall"
6: 
7: 	"golang.org/x/sys/unix"
8: )
9: 
10: type controlFn = func(network, address string, c syscall.RawConn) error
11: 
12: func bindControl(ifaceName string, chain controlFn) controlFn {
13: 	return func(network, address string, c syscall.RawConn) (err error) {
14: 		defer func() {
15: 			if err == nil && chain != nil {
16: 				err = chain(network, address, c)
17: 			}
18: 		}()
19: 
20: 		ipStr, _, err := net.SplitHostPort(address)
21: 		if err == nil {
22: 			ip := net.ParseIP(ipStr)
23: 			if ip != nil && !ip.IsGlobalUnicast() {
24: 				return
25: 			}
26: 		}
27: 
28: 		var innerErr error
29: 		err = c.Control(func(fd uintptr) {
30: 			innerErr = unix.BindToDevice(int(fd), ifaceName)
31: 		})
32: 
33: 		if innerErr != nil {
34: 			err = innerErr
35: 		}
36: 
37: 		return
38: 	}
39: }
40: 
41: func bindIfaceToDialer(ifaceName string, dialer *net.Dialer, _ string, _ net.IP) error {
42: 	dialer.Control = bindControl(ifaceName, dialer.Control)
43: 
44: 	return nil
45: }
46: 
47: func bindIfaceToListenConfig(ifaceName string, lc *net.ListenConfig, _, address string) (string, error) {
48: 	lc.Control = bindControl(ifaceName, lc.Control)
49: 
50: 	return address, nil
51: }


./component\dialer\bind_others.go
1: //go:build !linux && !darwin && !windows
2: 
3: package dialer
4: 
5: import (
6: 	"net"
7: 	"strconv"
8: )
9: 
10: func bindIfaceToDialer(ifaceName string, dialer *net.Dialer, network string, destination net.IP) error {
11: 	if !destination.IsGlobalUnicast() {
12: 		return nil
13: 	}
14: 
15: 	local := uint64(0)
16: 	if dialer.LocalAddr != nil {
17: 		_, port, err := net.SplitHostPort(dialer.LocalAddr.String())
18: 		if err == nil {
19: 			local, _ = strconv.ParseUint(port, 10, 16)
20: 		}
21: 	}
22: 
23: 	addr, err := lookupLocalAddr(ifaceName, network, destination, int(local))
24: 	if err != nil {
25: 		return err
26: 	}
27: 
28: 	dialer.LocalAddr = addr
29: 
30: 	return nil
31: }
32: 
33: func bindIfaceToListenConfig(ifaceName string, _ *net.ListenConfig, network, address string) (string, error) {
34: 	_, port, err := net.SplitHostPort(address)
35: 	if err != nil {
36: 		port = "0"
37: 	}
38: 
39: 	local, _ := strconv.ParseUint(port, 10, 16)
40: 
41: 	addr, err := lookupLocalAddr(ifaceName, network, nil, int(local))
42: 	if err != nil {
43: 		return "", err
44: 	}
45: 
46: 	return addr.String(), nil
47: }


./component\dialer\bind_windows.go
1: package dialer
2: 
3: import (
4: 	"encoding/binary"
5: 	"net"
6: 	"strings"
7: 	"syscall"
8: 	"unsafe"
9: 
10: 	"github.com/Dreamacro/clash/component/iface"
11: 
12: 	"golang.org/x/sys/windows"
13: )
14: 
15: const (
16: 	IP_UNICAST_IF   = 31
17: 	IPV6_UNICAST_IF = 31
18: )
19: 
20: type controlFn = func(network, address string, c syscall.RawConn) error
21: 
22: func bindControl(ifaceIdx int, chain controlFn) controlFn {
23: 	return func(network, address string, c syscall.RawConn) (err error) {
24: 		defer func() {
25: 			if err == nil && chain != nil {
26: 				err = chain(network, address, c)
27: 			}
28: 		}()
29: 
30: 		ipStr, _, err := net.SplitHostPort(address)
31: 		if err == nil {
32: 			ip := net.ParseIP(ipStr)
33: 			if ip != nil && !ip.IsGlobalUnicast() {
34: 				return
35: 			}
36: 		}
37: 
38: 		var innerErr error
39: 		err = c.Control(func(fd uintptr) {
40: 			if ipStr == "" && strings.HasPrefix(network, "udp") {
41: 				// When listening udp ":0", we should bind socket to interface4 and interface6 at the same time
42: 				// and ignore the error of bind6
43: 				_ = bindSocketToInterface6(windows.Handle(fd), ifaceIdx)
44: 				innerErr = bindSocketToInterface4(windows.Handle(fd), ifaceIdx)
45: 				return
46: 			}
47: 			switch network {
48: 			case "tcp4", "udp4":
49: 				innerErr = bindSocketToInterface4(windows.Handle(fd), ifaceIdx)
50: 			case "tcp6", "udp6":
51: 				innerErr = bindSocketToInterface6(windows.Handle(fd), ifaceIdx)
52: 			}
53: 		})
54: 
55: 		if innerErr != nil {
56: 			err = innerErr
57: 		}
58: 
59: 		return
60: 	}
61: }
62: 
63: func bindSocketToInterface4(handle windows.Handle, ifaceIdx int) error {
64: 	// MSDN says for IPv4 this needs to be in net byte order, so that it's like an IP address with leading zeros.
65: 	// Ref: https://learn.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options
66: 	var bytes [4]byte
67: 	binary.BigEndian.PutUint32(bytes[:], uint32(ifaceIdx))
68: 	index := *(*uint32)(unsafe.Pointer(&bytes[0]))
69: 	err := windows.SetsockoptInt(handle, windows.IPPROTO_IP, IP_UNICAST_IF, int(index))
70: 	if err != nil {
71: 		return err
72: 	}
73: 	return nil
74: }
75: 
76: func bindSocketToInterface6(handle windows.Handle, ifaceIdx int) error {
77: 	return windows.SetsockoptInt(handle, windows.IPPROTO_IPV6, IPV6_UNICAST_IF, ifaceIdx)
78: }
79: 
80: func bindIfaceToDialer(ifaceName string, dialer *net.Dialer, _ string, _ net.IP) error {
81: 	ifaceObj, err := iface.ResolveInterface(ifaceName)
82: 	if err != nil {
83: 		return err
84: 	}
85: 
86: 	dialer.Control = bindControl(ifaceObj.Index, dialer.Control)
87: 	return nil
88: }
89: 
90: func bindIfaceToListenConfig(ifaceName string, lc *net.ListenConfig, _, address string) (string, error) {
91: 	ifaceObj, err := iface.ResolveInterface(ifaceName)
92: 	if err != nil {
93: 		return "", err
94: 	}
95: 
96: 	lc.Control = bindControl(ifaceObj.Index, lc.Control)
97: 	return address, nil
98: }


./component\dialer\dialer.go
1: package dialer
2: 
3: import (
4: 	"context"
5: 	"errors"
6: 	"net"
7: 
8: 	"github.com/Dreamacro/clash/component/resolver"
9: )
10: 
11: func DialContext(ctx context.Context, network, address string, options ...Option) (net.Conn, error) {
12: 	switch network {
13: 	case "tcp4", "tcp6", "udp4", "udp6":
14: 		host, port, err := net.SplitHostPort(address)
15: 		if err != nil {
16: 			return nil, err
17: 		}
18: 
19: 		var ip net.IP
20: 		switch network {
21: 		case "tcp4", "udp4":
22: 			ip, err = resolver.ResolveIPv4(host)
23: 		default:
24: 			ip, err = resolver.ResolveIPv6(host)
25: 		}
26: 		if err != nil {
27: 			return nil, err
28: 		}
29: 
30: 		return dialContext(ctx, network, ip, port, options)
31: 	case "tcp", "udp":
32: 		return dualStackDialContext(ctx, network, address, options)
33: 	default:
34: 		return nil, errors.New("network invalid")
35: 	}
36: }
37: 
38: func ListenPacket(ctx context.Context, network, address string, options ...Option) (net.PacketConn, error) {
39: 	cfg := &option{
40: 		interfaceName: DefaultInterface.Load(),
41: 		routingMark:   int(DefaultRoutingMark.Load()),
42: 	}
43: 
44: 	for _, o := range DefaultOptions {
45: 		o(cfg)
46: 	}
47: 
48: 	for _, o := range options {
49: 		o(cfg)
50: 	}
51: 
52: 	lc := &net.ListenConfig{}
53: 	if cfg.interfaceName != "" {
54: 		var (
55: 			addr string
56: 			err  error
57: 		)
58: 		if cfg.fallbackBind {
59: 			addr, err = fallbackBindIfaceToListenConfig(cfg.interfaceName, lc, network, address)
60: 		} else {
61: 			addr, err = bindIfaceToListenConfig(cfg.interfaceName, lc, network, address)
62: 		}
63: 		if err != nil {
64: 			return nil, err
65: 		}
66: 		address = addr
67: 	}
68: 	if cfg.addrReuse {
69: 		addrReuseToListenConfig(lc)
70: 	}
71: 	if cfg.routingMark != 0 {
72: 		bindMarkToListenConfig(cfg.routingMark, lc, network, address)
73: 	}
74: 
75: 	return lc.ListenPacket(ctx, network, address)
76: }
77: 
78: func dialContext(ctx context.Context, network string, destination net.IP, port string, options []Option) (net.Conn, error) {
79: 	opt := &option{
80: 		interfaceName: DefaultInterface.Load(),
81: 		routingMark:   int(DefaultRoutingMark.Load()),
82: 	}
83: 
84: 	for _, o := range DefaultOptions {
85: 		o(opt)
86: 	}
87: 
88: 	for _, o := range options {
89: 		o(opt)
90: 	}
91: 
92: 	dialer := &net.Dialer{}
93: 	if opt.interfaceName != "" {
94: 		if opt.fallbackBind {
95: 			if err := fallbackBindIfaceToDialer(opt.interfaceName, dialer, network, destination); err != nil {
96: 				return nil, err
97: 			}
98: 		} else {
99: 			if err := bindIfaceToDialer(opt.interfaceName, dialer, network, destination); err != nil {
100: 				return nil, err
101: 			}
102: 		}
103: 	}
104: 	if opt.routingMark != 0 {
105: 		bindMarkToDialer(opt.routingMark, dialer, network, destination)
106: 	}
107: 
108: 	return dialer.DialContext(ctx, network, net.JoinHostPort(destination.String(), port))
109: }
110: 
111: func dualStackDialContext(ctx context.Context, network, address string, options []Option) (net.Conn, error) {
112: 	host, port, err := net.SplitHostPort(address)
113: 	if err != nil {
114: 		return nil, err
115: 	}
116: 
117: 	returned := make(chan struct{})
118: 	defer close(returned)
119: 
120: 	type dialResult struct {
121: 		net.Conn
122: 		error
123: 		resolved bool
124: 		ipv6     bool
125: 		done     bool
126: 	}
127: 	results := make(chan dialResult)
128: 	var primary, fallback dialResult
129: 
130: 	startRacer := func(ctx context.Context, network, host string, ipv6 bool) {
131: 		result := dialResult{ipv6: ipv6, done: true}
132: 		defer func() {
133: 			select {
134: 			case results <- result:
135: 			case <-returned:
136: 				if result.Conn != nil {
137: 					result.Conn.Close()
138: 				}
139: 			}
140: 		}()
141: 
142: 		var ip net.IP
143: 		if ipv6 {
144: 			ip, result.error = resolver.ResolveIPv6(host)
145: 		} else {
146: 			ip, result.error = resolver.ResolveIPv4(host)
147: 		}
148: 		if result.error != nil {
149: 			return
150: 		}
151: 		result.resolved = true
152: 
153: 		result.Conn, result.error = dialContext(ctx, network, ip, port, options)
154: 	}
155: 
156: 	go startRacer(ctx, network+"4", host, false)
157: 	go startRacer(ctx, network+"6", host, true)
158: 
159: 	for res := range results {
160: 		if res.error == nil {
161: 			return res.Conn, nil
162: 		}
163: 
164: 		if !res.ipv6 {
165: 			primary = res
166: 		} else {
167: 			fallback = res
168: 		}
169: 
170: 		if primary.done && fallback.done {
171: 			if primary.resolved {
172: 				return nil, primary.error
173: 			} else if fallback.resolved {
174: 				return nil, fallback.error
175: 			} else {
176: 				return nil, primary.error
177: 			}
178: 		}
179: 	}
180: 
181: 	return nil, errors.New("never touched")
182: }


./component\dialer\fallbackbind.go
1: package dialer
2: 
3: import (
4: 	"net"
5: 	"strconv"
6: 	"strings"
7: 
8: 	"github.com/Dreamacro/clash/component/iface"
9: )
10: 
11: func lookupLocalAddr(ifaceName string, network string, destination net.IP, port int) (net.Addr, error) {
12: 	ifaceObj, err := iface.ResolveInterface(ifaceName)
13: 	if err != nil {
14: 		return nil, err
15: 	}
16: 
17: 	var addr *net.IPNet
18: 	switch network {
19: 	case "udp4", "tcp4":
20: 		addr, err = ifaceObj.PickIPv4Addr(destination)
21: 	case "tcp6", "udp6":
22: 		addr, err = ifaceObj.PickIPv6Addr(destination)
23: 	default:
24: 		if destination != nil {
25: 			if destination.To4() != nil {
26: 				addr, err = ifaceObj.PickIPv4Addr(destination)
27: 			} else {
28: 				addr, err = ifaceObj.PickIPv6Addr(destination)
29: 			}
30: 		} else {
31: 			addr, err = ifaceObj.PickIPv4Addr(destination)
32: 		}
33: 	}
34: 	if err != nil {
35: 		return nil, err
36: 	}
37: 
38: 	if strings.HasPrefix(network, "tcp") {
39: 		return &net.TCPAddr{
40: 			IP:   addr.IP,
41: 			Port: port,
42: 		}, nil
43: 	} else if strings.HasPrefix(network, "udp") {
44: 		return &net.UDPAddr{
45: 			IP:   addr.IP,
46: 			Port: port,
47: 		}, nil
48: 	}
49: 
50: 	return nil, iface.ErrAddrNotFound
51: }
52: 
53: func fallbackBindIfaceToDialer(ifaceName string, dialer *net.Dialer, network string, destination net.IP) error {
54: 	if !destination.IsGlobalUnicast() {
55: 		return nil
56: 	}
57: 
58: 	local := uint64(0)
59: 	if dialer.LocalAddr != nil {
60: 		_, port, err := net.SplitHostPort(dialer.LocalAddr.String())
61: 		if err == nil {
62: 			local, _ = strconv.ParseUint(port, 10, 16)
63: 		}
64: 	}
65: 
66: 	addr, err := lookupLocalAddr(ifaceName, network, destination, int(local))
67: 	if err != nil {
68: 		return err
69: 	}
70: 
71: 	dialer.LocalAddr = addr
72: 
73: 	return nil
74: }
75: 
76: func fallbackBindIfaceToListenConfig(ifaceName string, _ *net.ListenConfig, network, address string) (string, error) {
77: 	_, port, err := net.SplitHostPort(address)
78: 	if err != nil {
79: 		port = "0"
80: 	}
81: 
82: 	local, _ := strconv.ParseUint(port, 10, 16)
83: 
84: 	addr, err := lookupLocalAddr(ifaceName, network, nil, int(local))
85: 	if err != nil {
86: 		return "", err
87: 	}
88: 
89: 	return addr.String(), nil
90: }


./component\dialer\mark_linux.go
1: //go:build linux
2: 
3: package dialer
4: 
5: import (
6: 	"net"
7: 	"syscall"
8: )
9: 
10: func bindMarkToDialer(mark int, dialer *net.Dialer, _ string, _ net.IP) {
11: 	dialer.Control = bindMarkToControl(mark, dialer.Control)
12: }
13: 
14: func bindMarkToListenConfig(mark int, lc *net.ListenConfig, _, address string) {
15: 	lc.Control = bindMarkToControl(mark, lc.Control)
16: }
17: 
18: func bindMarkToControl(mark int, chain controlFn) controlFn {
19: 	return func(network, address string, c syscall.RawConn) (err error) {
20: 		defer func() {
21: 			if err == nil && chain != nil {
22: 				err = chain(network, address, c)
23: 			}
24: 		}()
25: 
26: 		ipStr, _, err := net.SplitHostPort(address)
27: 		if err == nil {
28: 			ip := net.ParseIP(ipStr)
29: 			if ip != nil && !ip.IsGlobalUnicast() {
30: 				return
31: 			}
32: 		}
33: 
34: 		var innerErr error
35: 		err = c.Control(func(fd uintptr) {
36: 			innerErr = syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_MARK, mark)
37: 		})
38: 		if innerErr != nil {
39: 			err = innerErr
40: 		}
41: 		return
42: 	}
43: }


./component\dialer\mark_nonlinux.go
1: //go:build !linux
2: 
3: package dialer
4: 
5: import (
6: 	"net"
7: 	"sync"
8: 
9: 	"github.com/Dreamacro/clash/log"
10: )
11: 
12: var printMarkWarn = sync.OnceFunc(func() {
13: 	log.Warnln("Routing mark on socket is not supported on current platform")
14: })
15: 
16: func bindMarkToDialer(mark int, dialer *net.Dialer, _ string, _ net.IP) {
17: 	printMarkWarn()
18: }
19: 
20: func bindMarkToListenConfig(mark int, lc *net.ListenConfig, _, address string) {
21: 	printMarkWarn()
22: }


./component\dialer\options.go
1: package dialer
2: 
3: import "go.uber.org/atomic"
4: 
5: var (
6: 	DefaultOptions     []Option
7: 	DefaultInterface   = atomic.NewString("")
8: 	DefaultRoutingMark = atomic.NewInt32(0)
9: )
10: 
11: type option struct {
12: 	interfaceName string
13: 	fallbackBind  bool
14: 	addrReuse     bool
15: 	routingMark   int
16: }
17: 
18: type Option func(opt *option)
19: 
20: func WithInterface(name string) Option {
21: 	return func(opt *option) {
22: 		opt.interfaceName = name
23: 	}
24: }
25: 
26: func WithFallbackBind(fallback bool) Option {
27: 	return func(opt *option) {
28: 		opt.fallbackBind = fallback
29: 	}
30: }
31: 
32: func WithAddrReuse(reuse bool) Option {
33: 	return func(opt *option) {
34: 		opt.addrReuse = reuse
35: 	}
36: }
37: 
38: func WithRoutingMark(mark int) Option {
39: 	return func(opt *option) {
40: 		opt.routingMark = mark
41: 	}
42: }


./component\dialer\reuse_others.go
1: //go:build !darwin && !dragonfly && !freebsd && !linux && !netbsd && !openbsd && !solaris && !windows
2: 
3: package dialer
4: 
5: import (
6: 	"net"
7: )
8: 
9: func addrReuseToListenConfig(*net.ListenConfig) {}


./component\dialer\reuse_unix.go
1: //go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris
2: 
3: package dialer
4: 
5: import (
6: 	"net"
7: 	"syscall"
8: 
9: 	"golang.org/x/sys/unix"
10: )
11: 
12: func addrReuseToListenConfig(lc *net.ListenConfig) {
13: 	chain := lc.Control
14: 
15: 	lc.Control = func(network, address string, c syscall.RawConn) (err error) {
16: 		defer func() {
17: 			if err == nil && chain != nil {
18: 				err = chain(network, address, c)
19: 			}
20: 		}()
21: 
22: 		return c.Control(func(fd uintptr) {
23: 			unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEADDR, 1)
24: 			unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)
25: 		})
26: 	}
27: }


./component\dialer\reuse_windows.go
1: package dialer
2: 
3: import (
4: 	"net"
5: 	"syscall"
6: 
7: 	"golang.org/x/sys/windows"
8: )
9: 
10: func addrReuseToListenConfig(lc *net.ListenConfig) {
11: 	chain := lc.Control
12: 
13: 	lc.Control = func(network, address string, c syscall.RawConn) (err error) {
14: 		defer func() {
15: 			if err == nil && chain != nil {
16: 				err = chain(network, address, c)
17: 			}
18: 		}()
19: 
20: 		return c.Control(func(fd uintptr) {
21: 			windows.SetsockoptInt(windows.Handle(fd), windows.SOL_SOCKET, windows.SO_REUSEADDR, 1)
22: 		})
23: 	}
24: }


./component\fakeip\cachefile.go
1: package fakeip
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/component/profile/cachefile"
7: )
8: 
9: type cachefileStore struct {
10: 	cache *cachefile.CacheFile
11: }
12: 
13: // GetByHost implements store.GetByHost
14: func (c *cachefileStore) GetByHost(host string) (net.IP, bool) {
15: 	elm := c.cache.GetFakeip([]byte(host))
16: 	if elm == nil {
17: 		return nil, false
18: 	}
19: 	return net.IP(elm), true
20: }
21: 
22: // PutByHost implements store.PutByHost
23: func (c *cachefileStore) PutByHost(host string, ip net.IP) {
24: 	c.cache.PutFakeip([]byte(host), ip)
25: }
26: 
27: // GetByIP implements store.GetByIP
28: func (c *cachefileStore) GetByIP(ip net.IP) (string, bool) {
29: 	elm := c.cache.GetFakeip(ip.To4())
30: 	if elm == nil {
31: 		return "", false
32: 	}
33: 	return string(elm), true
34: }
35: 
36: // PutByIP implements store.PutByIP
37: func (c *cachefileStore) PutByIP(ip net.IP, host string) {
38: 	c.cache.PutFakeip(ip.To4(), []byte(host))
39: }
40: 
41: // DelByIP implements store.DelByIP
42: func (c *cachefileStore) DelByIP(ip net.IP) {
43: 	ip = ip.To4()
44: 	c.cache.DelFakeipPair(ip, c.cache.GetFakeip(ip.To4()))
45: }
46: 
47: // Exist implements store.Exist
48: func (c *cachefileStore) Exist(ip net.IP) bool {
49: 	_, exist := c.GetByIP(ip)
50: 	return exist
51: }
52: 
53: // CloneTo implements store.CloneTo
54: // already persistence
55: func (c *cachefileStore) CloneTo(store store) {}


./component\fakeip\memory.go
1: package fakeip
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/common/cache"
7: )
8: 
9: type memoryStore struct {
10: 	cache *cache.LruCache
11: }
12: 
13: // GetByHost implements store.GetByHost
14: func (m *memoryStore) GetByHost(host string) (net.IP, bool) {
15: 	if elm, exist := m.cache.Get(host); exist {
16: 		ip := elm.(net.IP)
17: 
18: 		// ensure ip --> host on head of linked list
19: 		m.cache.Get(ipToUint(ip.To4()))
20: 		return ip, true
21: 	}
22: 
23: 	return nil, false
24: }
25: 
26: // PutByHost implements store.PutByHost
27: func (m *memoryStore) PutByHost(host string, ip net.IP) {
28: 	m.cache.Set(host, ip)
29: }
30: 
31: // GetByIP implements store.GetByIP
32: func (m *memoryStore) GetByIP(ip net.IP) (string, bool) {
33: 	if elm, exist := m.cache.Get(ipToUint(ip.To4())); exist {
34: 		host := elm.(string)
35: 
36: 		// ensure host --> ip on head of linked list
37: 		m.cache.Get(host)
38: 		return host, true
39: 	}
40: 
41: 	return "", false
42: }
43: 
44: // PutByIP implements store.PutByIP
45: func (m *memoryStore) PutByIP(ip net.IP, host string) {
46: 	m.cache.Set(ipToUint(ip.To4()), host)
47: }
48: 
49: // DelByIP implements store.DelByIP
50: func (m *memoryStore) DelByIP(ip net.IP) {
51: 	ipNum := ipToUint(ip.To4())
52: 	if elm, exist := m.cache.Get(ipNum); exist {
53: 		m.cache.Delete(elm.(string))
54: 	}
55: 	m.cache.Delete(ipNum)
56: }
57: 
58: // Exist implements store.Exist
59: func (m *memoryStore) Exist(ip net.IP) bool {
60: 	return m.cache.Exist(ipToUint(ip.To4()))
61: }
62: 
63: // CloneTo implements store.CloneTo
64: // only for memoryStore to memoryStore
65: func (m *memoryStore) CloneTo(store store) {
66: 	if ms, ok := store.(*memoryStore); ok {
67: 		m.cache.CloneTo(ms.cache)
68: 	}
69: }


./component\fakeip\pool.go
1: package fakeip
2: 
3: import (
4: 	"errors"
5: 	"net"
6: 	"strings"
7: 	"sync"
8: 
9: 	"github.com/Dreamacro/clash/common/cache"
10: 	"github.com/Dreamacro/clash/component/profile/cachefile"
11: 	"github.com/Dreamacro/clash/component/trie"
12: )
13: 
14: type store interface {
15: 	GetByHost(host string) (net.IP, bool)
16: 	PutByHost(host string, ip net.IP)
17: 	GetByIP(ip net.IP) (string, bool)
18: 	PutByIP(ip net.IP, host string)
19: 	DelByIP(ip net.IP)
20: 	Exist(ip net.IP) bool
21: 	CloneTo(store)
22: }
23: 
24: // Pool is an implementation about fake ip generator without storage
25: type Pool struct {
26: 	max     uint32
27: 	min     uint32
28: 	gateway uint32
29: 	offset  uint32
30: 	mux     sync.Mutex
31: 	host    *trie.DomainTrie
32: 	ipnet   *net.IPNet
33: 	store   store
34: }
35: 
36: // Lookup return a fake ip with host
37: func (p *Pool) Lookup(host string) net.IP {
38: 	p.mux.Lock()
39: 	defer p.mux.Unlock()
40: 
41: 	// RFC4343: DNS Case Insensitive, we SHOULD return result with all cases.
42: 	host = strings.ToLower(host)
43: 	if ip, exist := p.store.GetByHost(host); exist {
44: 		return ip
45: 	}
46: 
47: 	ip := p.get(host)
48: 	p.store.PutByHost(host, ip)
49: 	return ip
50: }
51: 
52: // LookBack return host with the fake ip
53: func (p *Pool) LookBack(ip net.IP) (string, bool) {
54: 	p.mux.Lock()
55: 	defer p.mux.Unlock()
56: 
57: 	if ip = ip.To4(); ip == nil {
58: 		return "", false
59: 	}
60: 
61: 	return p.store.GetByIP(ip)
62: }
63: 
64: // ShouldSkipped return if domain should be skipped
65: func (p *Pool) ShouldSkipped(domain string) bool {
66: 	if p.host == nil {
67: 		return false
68: 	}
69: 	return p.host.Search(domain) != nil
70: }
71: 
72: // Exist returns if given ip exists in fake-ip pool
73: func (p *Pool) Exist(ip net.IP) bool {
74: 	p.mux.Lock()
75: 	defer p.mux.Unlock()
76: 
77: 	if ip = ip.To4(); ip == nil {
78: 		return false
79: 	}
80: 
81: 	return p.store.Exist(ip)
82: }
83: 
84: // Gateway return gateway ip
85: func (p *Pool) Gateway() net.IP {
86: 	return uintToIP(p.gateway)
87: }
88: 
89: // IPNet return raw ipnet
90: func (p *Pool) IPNet() *net.IPNet {
91: 	return p.ipnet
92: }
93: 
94: // CloneFrom clone cache from old pool
95: func (p *Pool) CloneFrom(o *Pool) {
96: 	o.store.CloneTo(p.store)
97: }
98: 
99: func (p *Pool) get(host string) net.IP {
100: 	current := p.offset
101: 	for {
102: 		ip := uintToIP(p.min + p.offset)
103: 		if !p.store.Exist(ip) {
104: 			break
105: 		}
106: 
107: 		p.offset = (p.offset + 1) % (p.max - p.min)
108: 		// Avoid infinite loops
109: 		if p.offset == current {
110: 			p.offset = (p.offset + 1) % (p.max - p.min)
111: 			ip := uintToIP(p.min + p.offset)
112: 			p.store.DelByIP(ip)
113: 			break
114: 		}
115: 	}
116: 	ip := uintToIP(p.min + p.offset)
117: 	p.store.PutByIP(ip, host)
118: 	return ip
119: }
120: 
121: func ipToUint(ip net.IP) uint32 {
122: 	v := uint32(ip[0]) << 24
123: 	v += uint32(ip[1]) << 16
124: 	v += uint32(ip[2]) << 8
125: 	v += uint32(ip[3])
126: 	return v
127: }
128: 
129: func uintToIP(v uint32) net.IP {
130: 	return net.IP{byte(v >> 24), byte(v >> 16), byte(v >> 8), byte(v)}
131: }
132: 
133: type Options struct {
134: 	IPNet *net.IPNet
135: 	Host  *trie.DomainTrie
136: 
137: 	// Size sets the maximum number of entries in memory
138: 	// and does not work if Persistence is true
139: 	Size int
140: 
141: 	// Persistence will save the data to disk.
142: 	// Size will not work and record will be fully stored.
143: 	Persistence bool
144: }
145: 
146: // New return Pool instance
147: func New(options Options) (*Pool, error) {
148: 	min := ipToUint(options.IPNet.IP) + 2
149: 
150: 	ones, bits := options.IPNet.Mask.Size()
151: 	total := 1<<uint(bits-ones) - 2
152: 
153: 	if total <= 0 {
154: 		return nil, errors.New("ipnet don't have valid ip")
155: 	}
156: 
157: 	max := min + uint32(total) - 1
158: 	pool := &Pool{
159: 		min:     min,
160: 		max:     max,
161: 		gateway: min - 1,
162: 		host:    options.Host,
163: 		ipnet:   options.IPNet,
164: 	}
165: 	if options.Persistence {
166: 		pool.store = &cachefileStore{
167: 			cache: cachefile.Cache(),
168: 		}
169: 	} else {
170: 		pool.store = &memoryStore{
171: 			cache: cache.New(cache.WithSize(options.Size * 2)),
172: 		}
173: 	}
174: 
175: 	return pool, nil
176: }


./component\fakeip\pool_test.go
1: package fakeip
2: 
3: import (
4: 	"net"
5: 	"os"
6: 	"testing"
7: 	"time"
8: 
9: 	"github.com/Dreamacro/clash/component/profile/cachefile"
10: 	"github.com/Dreamacro/clash/component/trie"
11: 
12: 	"github.com/stretchr/testify/assert"
13: 	"go.etcd.io/bbolt"
14: )
15: 
16: func createPools(options Options) ([]*Pool, string, error) {
17: 	pool, err := New(options)
18: 	if err != nil {
19: 		return nil, "", err
20: 	}
21: 	filePool, tempfile, err := createCachefileStore(options)
22: 	if err != nil {
23: 		return nil, "", err
24: 	}
25: 
26: 	return []*Pool{pool, filePool}, tempfile, nil
27: }
28: 
29: func createCachefileStore(options Options) (*Pool, string, error) {
30: 	pool, err := New(options)
31: 	if err != nil {
32: 		return nil, "", err
33: 	}
34: 	f, err := os.CreateTemp("", "clash")
35: 	if err != nil {
36: 		return nil, "", err
37: 	}
38: 
39: 	db, err := bbolt.Open(f.Name(), 0o666, &bbolt.Options{Timeout: time.Second})
40: 	if err != nil {
41: 		return nil, "", err
42: 	}
43: 
44: 	pool.store = &cachefileStore{
45: 		cache: &cachefile.CacheFile{DB: db},
46: 	}
47: 	return pool, f.Name(), nil
48: }
49: 
50: func TestPool_Basic(t *testing.T) {
51: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/29")
52: 	pools, tempfile, err := createPools(Options{
53: 		IPNet: ipnet,
54: 		Size:  10,
55: 	})
56: 	assert.Nil(t, err)
57: 	defer os.Remove(tempfile)
58: 
59: 	for _, pool := range pools {
60: 		first := pool.Lookup("foo.com")
61: 		last := pool.Lookup("bar.com")
62: 		bar, exist := pool.LookBack(last)
63: 
64: 		assert.True(t, first.Equal(net.IP{192, 168, 0, 2}))
65: 		assert.Equal(t, pool.Lookup("foo.com"), net.IP{192, 168, 0, 2})
66: 		assert.True(t, last.Equal(net.IP{192, 168, 0, 3}))
67: 		assert.True(t, exist)
68: 		assert.Equal(t, bar, "bar.com")
69: 		assert.Equal(t, pool.Gateway(), net.IP{192, 168, 0, 1})
70: 		assert.Equal(t, pool.IPNet().String(), ipnet.String())
71: 		assert.True(t, pool.Exist(net.IP{192, 168, 0, 3}))
72: 		assert.False(t, pool.Exist(net.IP{192, 168, 0, 4}))
73: 		assert.False(t, pool.Exist(net.ParseIP("::1")))
74: 	}
75: }
76: 
77: func TestPool_Case_Insensitive(t *testing.T) {
78: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/29")
79: 	pools, tempfile, err := createPools(Options{
80: 		IPNet: ipnet,
81: 		Size:  10,
82: 	})
83: 	assert.Nil(t, err)
84: 	defer os.Remove(tempfile)
85: 
86: 	for _, pool := range pools {
87: 		first := pool.Lookup("foo.com")
88: 		last := pool.Lookup("Foo.Com")
89: 		foo, exist := pool.LookBack(last)
90: 
91: 		assert.True(t, first.Equal(pool.Lookup("Foo.Com")))
92: 		assert.Equal(t, pool.Lookup("fOo.cOM"), first)
93: 		assert.True(t, exist)
94: 		assert.Equal(t, foo, "foo.com")
95: 	}
96: }
97: 
98: func TestPool_CycleUsed(t *testing.T) {
99: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/29")
100: 	pools, tempfile, err := createPools(Options{
101: 		IPNet: ipnet,
102: 		Size:  10,
103: 	})
104: 	assert.Nil(t, err)
105: 	defer os.Remove(tempfile)
106: 
107: 	for _, pool := range pools {
108: 		assert.Equal(t, net.IP{192, 168, 0, 2}, pool.Lookup("2.com"))
109: 		assert.Equal(t, net.IP{192, 168, 0, 3}, pool.Lookup("3.com"))
110: 		assert.Equal(t, net.IP{192, 168, 0, 4}, pool.Lookup("4.com"))
111: 		assert.Equal(t, net.IP{192, 168, 0, 5}, pool.Lookup("5.com"))
112: 		assert.Equal(t, net.IP{192, 168, 0, 6}, pool.Lookup("6.com"))
113: 		assert.Equal(t, net.IP{192, 168, 0, 2}, pool.Lookup("12.com"))
114: 		assert.Equal(t, net.IP{192, 168, 0, 3}, pool.Lookup("3.com"))
115: 	}
116: }
117: 
118: func TestPool_Skip(t *testing.T) {
119: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/30")
120: 	tree := trie.New()
121: 	tree.Insert("example.com", tree)
122: 	pools, tempfile, err := createPools(Options{
123: 		IPNet: ipnet,
124: 		Size:  10,
125: 		Host:  tree,
126: 	})
127: 	assert.Nil(t, err)
128: 	defer os.Remove(tempfile)
129: 
130: 	for _, pool := range pools {
131: 		assert.True(t, pool.ShouldSkipped("example.com"))
132: 		assert.False(t, pool.ShouldSkipped("foo.com"))
133: 	}
134: }
135: 
136: func TestPool_MaxCacheSize(t *testing.T) {
137: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/24")
138: 	pool, _ := New(Options{
139: 		IPNet: ipnet,
140: 		Size:  2,
141: 	})
142: 
143: 	first := pool.Lookup("foo.com")
144: 	pool.Lookup("bar.com")
145: 	pool.Lookup("baz.com")
146: 	next := pool.Lookup("foo.com")
147: 
148: 	assert.False(t, first.Equal(next))
149: }
150: 
151: func TestPool_DoubleMapping(t *testing.T) {
152: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/24")
153: 	pool, _ := New(Options{
154: 		IPNet: ipnet,
155: 		Size:  2,
156: 	})
157: 
158: 	// fill cache
159: 	fooIP := pool.Lookup("foo.com")
160: 	bazIP := pool.Lookup("baz.com")
161: 
162: 	// make foo.com hot
163: 	pool.Lookup("foo.com")
164: 
165: 	// should drop baz.com
166: 	barIP := pool.Lookup("bar.com")
167: 
168: 	_, fooExist := pool.LookBack(fooIP)
169: 	_, bazExist := pool.LookBack(bazIP)
170: 	_, barExist := pool.LookBack(barIP)
171: 
172: 	newBazIP := pool.Lookup("baz.com")
173: 
174: 	assert.True(t, fooExist)
175: 	assert.False(t, bazExist)
176: 	assert.True(t, barExist)
177: 
178: 	assert.False(t, bazIP.Equal(newBazIP))
179: }
180: 
181: func TestPool_Clone(t *testing.T) {
182: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/24")
183: 	pool, _ := New(Options{
184: 		IPNet: ipnet,
185: 		Size:  2,
186: 	})
187: 
188: 	first := pool.Lookup("foo.com")
189: 	last := pool.Lookup("bar.com")
190: 	assert.True(t, first.Equal(net.IP{192, 168, 0, 2}))
191: 	assert.True(t, last.Equal(net.IP{192, 168, 0, 3}))
192: 
193: 	newPool, _ := New(Options{
194: 		IPNet: ipnet,
195: 		Size:  2,
196: 	})
197: 	newPool.CloneFrom(pool)
198: 	_, firstExist := newPool.LookBack(first)
199: 	_, lastExist := newPool.LookBack(last)
200: 	assert.True(t, firstExist)
201: 	assert.True(t, lastExist)
202: }
203: 
204: func TestPool_Error(t *testing.T) {
205: 	_, ipnet, _ := net.ParseCIDR("192.168.0.1/31")
206: 	_, err := New(Options{
207: 		IPNet: ipnet,
208: 		Size:  10,
209: 	})
210: 
211: 	assert.Error(t, err)
212: }


./component\iface\iface.go
1: package iface
2: 
3: import (
4: 	"errors"
5: 	"net"
6: 	"time"
7: 
8: 	"github.com/Dreamacro/clash/common/singledo"
9: )
10: 
11: type Interface struct {
12: 	Index        int
13: 	Name         string
14: 	Addrs        []*net.IPNet
15: 	HardwareAddr net.HardwareAddr
16: }
17: 
18: var (
19: 	ErrIfaceNotFound = errors.New("interface not found")
20: 	ErrAddrNotFound  = errors.New("addr not found")
21: )
22: 
23: var interfaces = singledo.NewSingle(time.Second * 20)
24: 
25: func ResolveInterface(name string) (*Interface, error) {
26: 	value, err, _ := interfaces.Do(func() (any, error) {
27: 		ifaces, err := net.Interfaces()
28: 		if err != nil {
29: 			return nil, err
30: 		}
31: 
32: 		r := map[string]*Interface{}
33: 
34: 		for _, iface := range ifaces {
35: 			addrs, err := iface.Addrs()
36: 			if err != nil {
37: 				continue
38: 			}
39: 
40: 			ipNets := make([]*net.IPNet, 0, len(addrs))
41: 			for _, addr := range addrs {
42: 				ipNet := addr.(*net.IPNet)
43: 				if v4 := ipNet.IP.To4(); v4 != nil {
44: 					ipNet.IP = v4
45: 				}
46: 
47: 				ipNets = append(ipNets, ipNet)
48: 			}
49: 
50: 			r[iface.Name] = &Interface{
51: 				Index:        iface.Index,
52: 				Name:         iface.Name,
53: 				Addrs:        ipNets,
54: 				HardwareAddr: iface.HardwareAddr,
55: 			}
56: 		}
57: 
58: 		return r, nil
59: 	})
60: 	if err != nil {
61: 		return nil, err
62: 	}
63: 
64: 	ifaces := value.(map[string]*Interface)
65: 	iface, ok := ifaces[name]
66: 	if !ok {
67: 		return nil, ErrIfaceNotFound
68: 	}
69: 
70: 	return iface, nil
71: }
72: 
73: func FlushCache() {
74: 	interfaces.Reset()
75: }
76: 
77: func (iface *Interface) PickIPv4Addr(destination net.IP) (*net.IPNet, error) {
78: 	return iface.pickIPAddr(destination, func(addr *net.IPNet) bool {
79: 		return addr.IP.To4() != nil
80: 	})
81: }
82: 
83: func (iface *Interface) PickIPv6Addr(destination net.IP) (*net.IPNet, error) {
84: 	return iface.pickIPAddr(destination, func(addr *net.IPNet) bool {
85: 		return addr.IP.To4() == nil
86: 	})
87: }
88: 
89: func (iface *Interface) pickIPAddr(destination net.IP, accept func(addr *net.IPNet) bool) (*net.IPNet, error) {
90: 	var fallback *net.IPNet
91: 
92: 	for _, addr := range iface.Addrs {
93: 		if !accept(addr) {
94: 			continue
95: 		}
96: 
97: 		if fallback == nil && !addr.IP.IsLinkLocalUnicast() {
98: 			fallback = addr
99: 
100: 			if destination == nil {
101: 				break
102: 			}
103: 		}
104: 
105: 		if destination != nil && addr.Contains(destination) {
106: 			return addr, nil
107: 		}
108: 	}
109: 
110: 	if fallback == nil {
111: 		return nil, ErrAddrNotFound
112: 	}
113: 
114: 	return fallback, nil
115: }


./component\ipset\ipset_linux.go
1: //go:build linux
2: 
3: package ipset
4: 
5: import (
6: 	"net"
7: 
8: 	"github.com/vishvananda/netlink"
9: )
10: 
11: // Test whether the ip is in the set or not
12: func Test(setName string, ip net.IP) (bool, error) {
13: 	return netlink.IpsetTest(setName, &netlink.IPSetEntry{
14: 		IP: ip,
15: 	})
16: }
17: 
18: // Verify dumps a specific ipset to check if we can use the set normally
19: func Verify(setName string) error {
20: 	_, err := netlink.IpsetList(setName)
21: 	return err
22: }


./component\ipset\ipset_others.go
1: //go:build !linux
2: 
3: package ipset
4: 
5: import (
6: 	"net"
7: )
8: 
9: // Always return false in non-linux
10: func Test(setName string, ip net.IP) (bool, error) {
11: 	return false, nil
12: }
13: 
14: // Always pass in non-linux
15: func Verify(setName string) error {
16: 	return nil
17: }


./component\mmdb\mmdb.go
1: package mmdb
2: 
3: import (
4: 	"sync"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: 	"github.com/Dreamacro/clash/log"
8: 
9: 	"github.com/oschwald/geoip2-golang"
10: )
11: 
12: var (
13: 	mmdb *geoip2.Reader
14: 	once sync.Once
15: )
16: 
17: func LoadFromBytes(buffer []byte) {
18: 	once.Do(func() {
19: 		var err error
20: 		mmdb, err = geoip2.FromBytes(buffer)
21: 		if err != nil {
22: 			log.Fatalln("Can't load mmdb: %s", err.Error())
23: 		}
24: 	})
25: }
26: 
27: func Verify() bool {
28: 	instance, err := geoip2.Open(C.Path.MMDB())
29: 	if err == nil {
30: 		instance.Close()
31: 	}
32: 	return err == nil
33: }
34: 
35: func Instance() *geoip2.Reader {
36: 	once.Do(func() {
37: 		var err error
38: 		mmdb, err = geoip2.Open(C.Path.MMDB())
39: 		if err != nil {
40: 			log.Fatalln("Can't load mmdb: %s", err.Error())
41: 		}
42: 	})
43: 
44: 	return mmdb
45: }


./component\nat\table.go
1: package nat
2: 
3: import (
4: 	"sync"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: )
8: 
9: type Table struct {
10: 	mapping sync.Map
11: }
12: 
13: func (t *Table) Set(key string, pc C.PacketConn) {
14: 	t.mapping.Store(key, pc)
15: }
16: 
17: func (t *Table) Get(key string) C.PacketConn {
18: 	item, exist := t.mapping.Load(key)
19: 	if !exist {
20: 		return nil
21: 	}
22: 	return item.(C.PacketConn)
23: }
24: 
25: func (t *Table) GetOrCreateLock(key string) (*sync.Cond, bool) {
26: 	item, loaded := t.mapping.LoadOrStore(key, sync.NewCond(&sync.Mutex{}))
27: 	return item.(*sync.Cond), loaded
28: }
29: 
30: func (t *Table) Delete(key string) {
31: 	t.mapping.Delete(key)
32: }
33: 
34: // New return *Cache
35: func New() *Table {
36: 	return &Table{}
37: }


./component\pool\pool.go
1: package pool
2: 
3: import (
4: 	"context"
5: 	"runtime"
6: 	"time"
7: )
8: 
9: type Factory = func(context.Context) (any, error)
10: 
11: type entry struct {
12: 	elm  any
13: 	time time.Time
14: }
15: 
16: type Option func(*pool)
17: 
18: // WithEvict set the evict callback
19: func WithEvict(cb func(any)) Option {
20: 	return func(p *pool) {
21: 		p.evict = cb
22: 	}
23: }
24: 
25: // WithAge defined element max age (millisecond)
26: func WithAge(maxAge int64) Option {
27: 	return func(p *pool) {
28: 		p.maxAge = maxAge
29: 	}
30: }
31: 
32: // WithSize defined max size of Pool
33: func WithSize(maxSize int) Option {
34: 	return func(p *pool) {
35: 		p.ch = make(chan any, maxSize)
36: 	}
37: }
38: 
39: // Pool is for GC, see New for detail
40: type Pool struct {
41: 	*pool
42: }
43: 
44: type pool struct {
45: 	ch      chan any
46: 	factory Factory
47: 	evict   func(any)
48: 	maxAge  int64
49: }
50: 
51: func (p *pool) GetContext(ctx context.Context) (any, error) {
52: 	now := time.Now()
53: 	for {
54: 		select {
55: 		case item := <-p.ch:
56: 			elm := item.(*entry)
57: 			if p.maxAge != 0 && now.Sub(item.(*entry).time).Milliseconds() > p.maxAge {
58: 				if p.evict != nil {
59: 					p.evict(elm.elm)
60: 				}
61: 				continue
62: 			}
63: 
64: 			return elm.elm, nil
65: 		default:
66: 			return p.factory(ctx)
67: 		}
68: 	}
69: }
70: 
71: func (p *pool) Get() (any, error) {
72: 	return p.GetContext(context.Background())
73: }
74: 
75: func (p *pool) Put(item any) {
76: 	e := &entry{
77: 		elm:  item,
78: 		time: time.Now(),
79: 	}
80: 
81: 	select {
82: 	case p.ch <- e:
83: 		return
84: 	default:
85: 		// pool is full
86: 		if p.evict != nil {
87: 			p.evict(item)
88: 		}
89: 		return
90: 	}
91: }
92: 
93: func recycle(p *Pool) {
94: 	for item := range p.pool.ch {
95: 		if p.pool.evict != nil {
96: 			p.pool.evict(item.(*entry).elm)
97: 		}
98: 	}
99: }
100: 
101: func New(factory Factory, options ...Option) *Pool {
102: 	p := &pool{
103: 		ch:      make(chan any, 10),
104: 		factory: factory,
105: 	}
106: 
107: 	for _, option := range options {
108: 		option(p)
109: 	}
110: 
111: 	P := &Pool{p}
112: 	runtime.SetFinalizer(P, recycle)
113: 	return P
114: }


./component\pool\pool_test.go
1: package pool
2: 
3: import (
4: 	"context"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/stretchr/testify/assert"
9: )
10: 
11: func lg() Factory {
12: 	initial := -1
13: 	return func(context.Context) (any, error) {
14: 		initial++
15: 		return initial, nil
16: 	}
17: }
18: 
19: func TestPool_Basic(t *testing.T) {
20: 	g := lg()
21: 	pool := New(g)
22: 
23: 	elm, _ := pool.Get()
24: 	assert.Equal(t, 0, elm.(int))
25: 	pool.Put(elm)
26: 	elm, _ = pool.Get()
27: 	assert.Equal(t, 0, elm.(int))
28: 	elm, _ = pool.Get()
29: 	assert.Equal(t, 1, elm.(int))
30: }
31: 
32: func TestPool_MaxSize(t *testing.T) {
33: 	g := lg()
34: 	size := 5
35: 	pool := New(g, WithSize(size))
36: 
37: 	items := []any{}
38: 
39: 	for i := 0; i < size; i++ {
40: 		item, _ := pool.Get()
41: 		items = append(items, item)
42: 	}
43: 
44: 	extra, _ := pool.Get()
45: 	assert.Equal(t, size, extra.(int))
46: 
47: 	for _, item := range items {
48: 		pool.Put(item)
49: 	}
50: 
51: 	pool.Put(extra)
52: 
53: 	for _, item := range items {
54: 		elm, _ := pool.Get()
55: 		assert.Equal(t, item.(int), elm.(int))
56: 	}
57: }
58: 
59: func TestPool_MaxAge(t *testing.T) {
60: 	g := lg()
61: 	pool := New(g, WithAge(20))
62: 
63: 	elm, _ := pool.Get()
64: 	pool.Put(elm)
65: 
66: 	elm, _ = pool.Get()
67: 	assert.Equal(t, 0, elm.(int))
68: 	pool.Put(elm)
69: 
70: 	time.Sleep(time.Millisecond * 22)
71: 	elm, _ = pool.Get()
72: 	assert.Equal(t, 1, elm.(int))
73: }


./component\process\process.go
1: package process
2: 
3: import (
4: 	"errors"
5: 	"net/netip"
6: )
7: 
8: var (
9: 	ErrInvalidNetwork     = errors.New("invalid network")
10: 	ErrPlatformNotSupport = errors.New("not support on this platform")
11: 	ErrNotFound           = errors.New("process not found")
12: )
13: 
14: const (
15: 	TCP = "tcp"
16: 	UDP = "udp"
17: )
18: 
19: func FindProcessPath(network string, from netip.AddrPort, to netip.AddrPort) (string, error) {
20: 	return findProcessPath(network, from, to)
21: }


./component\process\process_darwin.go
1: package process
2: 
3: import (
4: 	"encoding/binary"
5: 	"net/netip"
6: 	"strconv"
7: 	"strings"
8: 	"syscall"
9: 	"unsafe"
10: 
11: 	"golang.org/x/sys/unix"
12: )
13: 
14: const (
15: 	procpidpathinfo     = 0xb
16: 	procpidpathinfosize = 1024
17: 	proccallnumpidinfo  = 0x2
18: )
19: 
20: var structSize = func() int {
21: 	value, _ := syscall.Sysctl("kern.osrelease")
22: 	major, _, _ := strings.Cut(value, ".")
23: 	n, _ := strconv.ParseInt(major, 10, 64)
24: 	switch true {
25: 	case n >= 22:
26: 		return 408
27: 	default:
28: 		// from darwin-xnu/bsd/netinet/in_pcblist.c:get_pcblist_n
29: 		// size/offset are round up (aligned) to 8 bytes in darwin
30: 		// rup8(sizeof(xinpcb_n)) + rup8(sizeof(xsocket_n)) +
31: 		// 2 * rup8(sizeof(xsockbuf_n)) + rup8(sizeof(xsockstat_n))
32: 		return 384
33: 	}
34: }()
35: 
36: func findProcessPath(network string, from netip.AddrPort, _ netip.AddrPort) (string, error) {
37: 	var spath string
38: 	switch network {
39: 	case TCP:
40: 		spath = "net.inet.tcp.pcblist_n"
41: 	case UDP:
42: 		spath = "net.inet.udp.pcblist_n"
43: 	default:
44: 		return "", ErrInvalidNetwork
45: 	}
46: 
47: 	isIPv4 := from.Addr().Is4()
48: 
49: 	value, err := syscall.Sysctl(spath)
50: 	if err != nil {
51: 		return "", err
52: 	}
53: 
54: 	buf := []byte(value)
55: 	itemSize := structSize
56: 	if network == TCP {
57: 		// rup8(sizeof(xtcpcb_n))
58: 		itemSize += 208
59: 	}
60: 
61: 	var fallbackUDPProcess string
62: 	// skip the first xinpgen(24 bytes) block
63: 	for i := 24; i+itemSize <= len(buf); i += itemSize {
64: 		// offset of xinpcb_n and xsocket_n
65: 		inp, so := i, i+104
66: 
67: 		srcPort := binary.BigEndian.Uint16(buf[inp+18 : inp+20])
68: 		if from.Port() != srcPort {
69: 			continue
70: 		}
71: 
72: 		// FIXME: add dstPort check
73: 
74: 		// xinpcb_n.inp_vflag
75: 		flag := buf[inp+44]
76: 
77: 		var (
78: 			srcIP     netip.Addr
79: 			srcIPOk   bool
80: 			srcIsIPv4 bool
81: 		)
82: 		switch {
83: 		case flag&0x1 > 0 && isIPv4:
84: 			// ipv4
85: 			srcIP, srcIPOk = netip.AddrFromSlice(buf[inp+76 : inp+80])
86: 			srcIsIPv4 = true
87: 		case flag&0x2 > 0 && !isIPv4:
88: 			// ipv6
89: 			srcIP, srcIPOk = netip.AddrFromSlice(buf[inp+64 : inp+80])
90: 		default:
91: 			continue
92: 		}
93: 		if !srcIPOk {
94: 			continue
95: 		}
96: 
97: 		if from.Addr() == srcIP { // FIXME: add dstIP check
98: 			// xsocket_n.so_last_pid
99: 			pid := readNativeUint32(buf[so+68 : so+72])
100: 			return getExecPathFromPID(pid)
101: 		}
102: 
103: 		// udp packet connection may be not equal with srcIP
104: 		if network == UDP && srcIP.IsUnspecified() && isIPv4 == srcIsIPv4 {
105: 			fallbackUDPProcess, _ = getExecPathFromPID(readNativeUint32(buf[so+68 : so+72]))
106: 		}
107: 	}
108: 
109: 	if network == UDP && fallbackUDPProcess != "" {
110: 		return fallbackUDPProcess, nil
111: 	}
112: 
113: 	return "", ErrNotFound
114: }
115: 
116: func getExecPathFromPID(pid uint32) (string, error) {
117: 	buf := make([]byte, procpidpathinfosize)
118: 	_, _, errno := syscall.Syscall6(
119: 		syscall.SYS_PROC_INFO,
120: 		proccallnumpidinfo,
121: 		uintptr(pid),
122: 		procpidpathinfo,
123: 		0,
124: 		uintptr(unsafe.Pointer(&buf[0])),
125: 		procpidpathinfosize)
126: 	if errno != 0 {
127: 		return "", errno
128: 	}
129: 
130: 	return unix.ByteSliceToString(buf), nil
131: }
132: 
133: func readNativeUint32(b []byte) uint32 {
134: 	return *(*uint32)(unsafe.Pointer(&b[0]))
135: }


./component\process\process_freebsd.go
1: package process
2: 
3: import (
4: 	"encoding/binary"
5: 	"fmt"
6: 	"net/netip"
7: 	"strconv"
8: 	"strings"
9: 	"unsafe"
10: 
11: 	"golang.org/x/sys/unix"
12: )
13: 
14: type Xinpgen12 [64]byte // size 64
15: 
16: type InEndpoints12 struct {
17: 	FPort  [2]byte
18: 	LPort  [2]byte
19: 	FAddr  [16]byte
20: 	LAddr  [16]byte
21: 	ZoneID uint32
22: } // size 40
23: 
24: type XTcpcb12 struct {
25: 	Len         uint32        // offset 0
26: 	_           [20]byte      // offset 4
27: 	SocketAddr  uint64        // offset 24
28: 	_           [84]byte      // offset 32
29: 	Family      uint32        // offset 116
30: 	_           [140]byte     // offset 120
31: 	InEndpoints InEndpoints12 // offset 260
32: 	_           [444]byte     // offset 300
33: } // size 744
34: 
35: type XInpcb12 struct {
36: 	Len         uint32        // offset 0
37: 	_           [12]byte      // offset 4
38: 	SocketAddr  uint64        // offset 16
39: 	_           [84]byte      // offset 24
40: 	Family      uint32        // offset 108
41: 	_           [140]byte     // offset 112
42: 	InEndpoints InEndpoints12 // offset 252
43: 	_           [108]byte     // offset 292
44: } // size 400
45: 
46: type XFile12 struct {
47: 	Size     uint64   // offset 0
48: 	Pid      uint32   // offset 8
49: 	_        [44]byte // offset 12
50: 	DataAddr uint64   // offset 56
51: 	_        [64]byte // offset 64
52: } // size 128
53: 
54: var majorVersion = func() int {
55: 	releaseVersion, err := unix.Sysctl("kern.osrelease")
56: 	if err != nil {
57: 		return 0
58: 	}
59: 
60: 	majorVersionText, _, _ := strings.Cut(releaseVersion, ".")
61: 
62: 	majorVersion, err := strconv.Atoi(majorVersionText)
63: 	if err != nil {
64: 		return 0
65: 	}
66: 
67: 	return majorVersion
68: }()
69: 
70: func findProcessPath(network string, from netip.AddrPort, to netip.AddrPort) (string, error) {
71: 	switch majorVersion {
72: 	case 12, 13:
73: 		return findProcessPath12(network, from, to)
74: 	}
75: 
76: 	return "", ErrPlatformNotSupport
77: }
78: 
79: func findProcessPath12(network string, from netip.AddrPort, to netip.AddrPort) (string, error) {
80: 	switch network {
81: 	case TCP:
82: 		data, err := unix.SysctlRaw("net.inet.tcp.pcblist")
83: 		if err != nil {
84: 			return "", err
85: 		}
86: 
87: 		if len(data) < int(unsafe.Sizeof(Xinpgen12{})) {
88: 			return "", fmt.Errorf("invalid sysctl data len: %d", len(data))
89: 		}
90: 
91: 		data = data[unsafe.Sizeof(Xinpgen12{}):]
92: 
93: 		for len(data) > int(unsafe.Sizeof(XTcpcb12{}.Len)) {
94: 			tcb := (*XTcpcb12)(unsafe.Pointer(&data[0]))
95: 			if tcb.Len < uint32(unsafe.Sizeof(XTcpcb12{})) || uint32(len(data)) < tcb.Len {
96: 				break
97: 			}
98: 
99: 			data = data[tcb.Len:]
100: 
101: 			var (
102: 				connFromAddr netip.Addr
103: 				connToAddr   netip.Addr
104: 			)
105: 			if tcb.Family == unix.AF_INET {
106: 				connFromAddr = netip.AddrFrom4([4]byte(tcb.InEndpoints.LAddr[12:16]))
107: 				connToAddr = netip.AddrFrom4([4]byte(tcb.InEndpoints.FAddr[12:16]))
108: 			} else if tcb.Family == unix.AF_INET6 {
109: 				connFromAddr = netip.AddrFrom16(tcb.InEndpoints.LAddr)
110: 				connToAddr = netip.AddrFrom16(tcb.InEndpoints.FAddr)
111: 			} else {
112: 				continue
113: 			}
114: 
115: 			connFrom := netip.AddrPortFrom(connFromAddr, binary.BigEndian.Uint16(tcb.InEndpoints.LPort[:]))
116: 			connTo := netip.AddrPortFrom(connToAddr, binary.BigEndian.Uint16(tcb.InEndpoints.FPort[:]))
117: 
118: 			if connFrom == from && connTo == to {
119: 				pid, err := findPidBySocketAddr12(tcb.SocketAddr)
120: 				if err != nil {
121: 					return "", err
122: 				}
123: 
124: 				return findExecutableByPid(pid)
125: 			}
126: 		}
127: 	case UDP:
128: 		data, err := unix.SysctlRaw("net.inet.udp.pcblist")
129: 		if err != nil {
130: 			return "", err
131: 		}
132: 
133: 		if len(data) < int(unsafe.Sizeof(Xinpgen12{})) {
134: 			return "", fmt.Errorf("invalid sysctl data len: %d", len(data))
135: 		}
136: 
137: 		data = data[unsafe.Sizeof(Xinpgen12{}):]
138: 
139: 		for len(data) > int(unsafe.Sizeof(XInpcb12{}.Len)) {
140: 			icb := (*XInpcb12)(unsafe.Pointer(&data[0]))
141: 			if icb.Len < uint32(unsafe.Sizeof(XInpcb12{})) || uint32(len(data)) < icb.Len {
142: 				break
143: 			}
144: 			data = data[icb.Len:]
145: 
146: 			var connFromAddr netip.Addr
147: 			if icb.Family == unix.AF_INET {
148: 				connFromAddr = netip.AddrFrom4([4]byte(icb.InEndpoints.LAddr[12:16]))
149: 			} else if icb.Family == unix.AF_INET6 {
150: 				connFromAddr = netip.AddrFrom16(icb.InEndpoints.LAddr)
151: 			} else {
152: 				continue
153: 			}
154: 
155: 			connFromPort := binary.BigEndian.Uint16(icb.InEndpoints.LPort[:])
156: 
157: 			if (connFromAddr == from.Addr() || connFromAddr.IsUnspecified()) && connFromPort == from.Port() {
158: 				pid, err := findPidBySocketAddr12(icb.SocketAddr)
159: 				if err != nil {
160: 					return "", err
161: 				}
162: 
163: 				return findExecutableByPid(pid)
164: 			}
165: 		}
166: 	}
167: 
168: 	return "", ErrNotFound
169: }
170: 
171: func findPidBySocketAddr12(socketAddr uint64) (uint32, error) {
172: 	buf, err := unix.SysctlRaw("kern.file")
173: 	if err != nil {
174: 		return 0, err
175: 	}
176: 
177: 	filesLen := len(buf) / int(unsafe.Sizeof(XFile12{}))
178: 	files := unsafe.Slice((*XFile12)(unsafe.Pointer(&buf[0])), filesLen)
179: 
180: 	for _, file := range files {
181: 		if file.Size != uint64(unsafe.Sizeof(XFile12{})) {
182: 			return 0, fmt.Errorf("invalid xfile size: %d", file.Size)
183: 		}
184: 
185: 		if file.DataAddr == socketAddr {
186: 			return file.Pid, nil
187: 		}
188: 	}
189: 
190: 	return 0, ErrNotFound
191: }
192: 
193: func findExecutableByPid(pid uint32) (string, error) {
194: 	buf := make([]byte, unix.PathMax)
195: 	size := uint64(len(buf))
196: 	mib := [4]uint32{
197: 		unix.CTL_KERN,
198: 		14, // KERN_PROC
199: 		12, // KERN_PROC_PATHNAME
200: 		pid,
201: 	}
202: 
203: 	_, _, errno := unix.Syscall6(
204: 		unix.SYS___SYSCTL,
205: 		uintptr(unsafe.Pointer(&mib[0])),
206: 		uintptr(len(mib)),
207: 		uintptr(unsafe.Pointer(&buf[0])),
208: 		uintptr(unsafe.Pointer(&size)),
209: 		0,
210: 		0,
211: 	)
212: 	if errno != 0 || size == 0 {
213: 		return "", fmt.Errorf("sysctl: get proc name: %w", errno)
214: 	}
215: 
216: 	return string(buf[:size-1]), nil
217: }


./component\process\process_freebsd_test.go
1: //go:build freebsd
2: 
3: package process
4: 
5: import (
6: 	"testing"
7: 	"unsafe"
8: 
9: 	"github.com/stretchr/testify/assert"
10: )
11: 
12: func TestEnforceStructValid12(t *testing.T) {
13: 	if majorVersion != 12 && majorVersion != 13 {
14: 		t.Skipf("Unsupported freebsd version: %d", majorVersion)
15: 
16: 		return
17: 	}
18: 
19: 	assert.Equal(t, 0, int(unsafe.Offsetof(XTcpcb12{}.Len)))
20: 	assert.Equal(t, 24, int(unsafe.Offsetof(XTcpcb12{}.SocketAddr)))
21: 	assert.Equal(t, 116, int(unsafe.Offsetof(XTcpcb12{}.Family)))
22: 	assert.Equal(t, 260, int(unsafe.Offsetof(XTcpcb12{}.InEndpoints)))
23: 	assert.Equal(t, 0, int(unsafe.Offsetof(XInpcb12{}.Len)))
24: 	assert.Equal(t, 16, int(unsafe.Offsetof(XInpcb12{}.SocketAddr)))
25: 	assert.Equal(t, 108, int(unsafe.Offsetof(XInpcb12{}.Family)))
26: 	assert.Equal(t, 252, int(unsafe.Offsetof(XInpcb12{}.InEndpoints)))
27: 	assert.Equal(t, 0, int(unsafe.Offsetof(XFile12{}.Size)))
28: 	assert.Equal(t, 8, int(unsafe.Offsetof(XFile12{}.Pid)))
29: 	assert.Equal(t, 56, int(unsafe.Offsetof(XFile12{}.DataAddr)))
30: 	assert.Equal(t, 64, int(unsafe.Sizeof(Xinpgen12{})))
31: 	assert.Equal(t, 744, int(unsafe.Sizeof(XTcpcb12{})))
32: 	assert.Equal(t, 400, int(unsafe.Sizeof(XInpcb12{})))
33: 	assert.Equal(t, 40, int(unsafe.Sizeof(InEndpoints12{})))
34: 	assert.Equal(t, 128, int(unsafe.Sizeof(XFile12{})))
35: }


./component\process\process_linux.go
1: package process
2: 
3: import (
4: 	"bytes"
5: 	"encoding/binary"
6: 	"fmt"
7: 	"net"
8: 	"net/netip"
9: 	"os"
10: 	"unsafe"
11: 
12: 	"github.com/Dreamacro/clash/common/pool"
13: 
14: 	"github.com/mdlayher/netlink"
15: 	"golang.org/x/sys/unix"
16: )
17: 
18: type inetDiagRequest struct {
19: 	Family   byte
20: 	Protocol byte
21: 	Ext      byte
22: 	Pad      byte
23: 	States   uint32
24: 
25: 	SrcPort [2]byte
26: 	DstPort [2]byte
27: 	Src     [16]byte
28: 	Dst     [16]byte
29: 	If      uint32
30: 	Cookie  [2]uint32
31: }
32: 
33: type inetDiagResponse struct {
34: 	Family  byte
35: 	State   byte
36: 	Timer   byte
37: 	ReTrans byte
38: 
39: 	SrcPort [2]byte
40: 	DstPort [2]byte
41: 	Src     [16]byte
42: 	Dst     [16]byte
43: 	If      uint32
44: 	Cookie  [2]uint32
45: 
46: 	Expires uint32
47: 	RQueue  uint32
48: 	WQueue  uint32
49: 	UID     uint32
50: 	INode   uint32
51: }
52: 
53: func findProcessPath(network string, from netip.AddrPort, to netip.AddrPort) (string, error) {
54: 	inode, uid, err := resolveSocketByNetlink(network, from, to)
55: 	if err != nil {
56: 		return "", err
57: 	}
58: 
59: 	return resolveProcessPathByProcSearch(inode, uid)
60: }
61: 
62: func resolveSocketByNetlink(network string, from netip.AddrPort, to netip.AddrPort) (inode uint32, uid uint32, err error) {
63: 	var families []byte
64: 	if from.Addr().Unmap().Is4() {
65: 		families = []byte{unix.AF_INET, unix.AF_INET6}
66: 	} else {
67: 		families = []byte{unix.AF_INET6, unix.AF_INET}
68: 	}
69: 
70: 	var protocol byte
71: 	switch network {
72: 	case TCP:
73: 		protocol = unix.IPPROTO_TCP
74: 	case UDP:
75: 		protocol = unix.IPPROTO_UDP
76: 	default:
77: 		return 0, 0, ErrInvalidNetwork
78: 	}
79: 
80: 	if protocol == unix.IPPROTO_UDP {
81: 		// Swap from & to for udp
82: 		// See also https://www.mail-archive.com/netdev@vger.kernel.org/msg248638.html
83: 		from, to = to, from
84: 	}
85: 
86: 	for _, family := range families {
87: 		inode, uid, err = resolveSocketByNetlinkExact(family, protocol, from, to, netlink.Request)
88: 		if err == nil {
89: 			return inode, uid, err
90: 		}
91: 	}
92: 
93: 	return 0, 0, ErrNotFound
94: }
95: 
96: func resolveSocketByNetlinkExact(family byte, protocol byte, from netip.AddrPort, to netip.AddrPort, flags netlink.HeaderFlags) (inode uint32, uid uint32, err error) {
97: 	request := &inetDiagRequest{
98: 		Family:   family,
99: 		Protocol: protocol,
100: 		States:   0xffffffff,
101: 		Cookie:   [2]uint32{0xffffffff, 0xffffffff},
102: 	}
103: 
104: 	var (
105: 		fromAddr []byte
106: 		toAddr   []byte
107: 	)
108: 	if family == unix.AF_INET {
109: 		fromAddr = net.IP(from.Addr().AsSlice()).To4()
110: 		toAddr = net.IP(to.Addr().AsSlice()).To4()
111: 	} else {
112: 		fromAddr = net.IP(from.Addr().AsSlice()).To16()
113: 		toAddr = net.IP(to.Addr().AsSlice()).To16()
114: 	}
115: 
116: 	copy(request.Src[:], fromAddr)
117: 	copy(request.Dst[:], toAddr)
118: 
119: 	binary.BigEndian.PutUint16(request.SrcPort[:], from.Port())
120: 	binary.BigEndian.PutUint16(request.DstPort[:], to.Port())
121: 
122: 	conn, err := netlink.Dial(unix.NETLINK_INET_DIAG, nil)
123: 	if err != nil {
124: 		return 0, 0, err
125: 	}
126: 	defer conn.Close()
127: 
128: 	message := netlink.Message{
129: 		Header: netlink.Header{
130: 			Type:  20, // SOCK_DIAG_BY_FAMILY
131: 			Flags: flags,
132: 		},
133: 		Data: (*(*[unsafe.Sizeof(*request)]byte)(unsafe.Pointer(request)))[:],
134: 	}
135: 
136: 	messages, err := conn.Execute(message)
137: 	if err != nil {
138: 		return 0, 0, err
139: 	}
140: 
141: 	for _, msg := range messages {
142: 		if len(msg.Data) < int(unsafe.Sizeof(inetDiagResponse{})) {
143: 			continue
144: 		}
145: 
146: 		response := (*inetDiagResponse)(unsafe.Pointer(&msg.Data[0]))
147: 
148: 		return response.INode, response.UID, nil
149: 	}
150: 
151: 	return 0, 0, ErrNotFound
152: }
153: 
154: func resolveProcessPathByProcSearch(inode, uid uint32) (string, error) {
155: 	procDir, err := os.Open("/proc")
156: 	if err != nil {
157: 		return "", err
158: 	}
159: 	defer procDir.Close()
160: 
161: 	pids, err := procDir.Readdirnames(-1)
162: 	if err != nil {
163: 		return "", err
164: 	}
165: 
166: 	expectedSocketName := fmt.Appendf(nil, "socket:[%d]", inode)
167: 
168: 	pathBuffer := pool.Get(64)
169: 	defer pool.Put(pathBuffer)
170: 
171: 	readlinkBuffer := pool.Get(32)
172: 	defer pool.Put(readlinkBuffer)
173: 
174: 	copy(pathBuffer, "/proc/")
175: 
176: 	for _, pid := range pids {
177: 		if !isPid(pid) {
178: 			continue
179: 		}
180: 
181: 		pathBuffer = append(pathBuffer[:len("/proc/")], pid...)
182: 
183: 		stat := &unix.Stat_t{}
184: 		err = unix.Stat(string(pathBuffer), stat)
185: 		if err != nil {
186: 			continue
187: 		} else if stat.Uid != uid {
188: 			continue
189: 		}
190: 
191: 		pathBuffer = append(pathBuffer, "/fd/"...)
192: 		fdsPrefixLength := len(pathBuffer)
193: 
194: 		fdDir, err := os.Open(string(pathBuffer))
195: 		if err != nil {
196: 			continue
197: 		}
198: 
199: 		fds, err := fdDir.Readdirnames(-1)
200: 		fdDir.Close()
201: 		if err != nil {
202: 			continue
203: 		}
204: 
205: 		for _, fd := range fds {
206: 			pathBuffer = pathBuffer[:fdsPrefixLength]
207: 
208: 			pathBuffer = append(pathBuffer, fd...)
209: 
210: 			n, err := unix.Readlink(string(pathBuffer), readlinkBuffer)
211: 			if err != nil {
212: 				continue
213: 			}
214: 
215: 			if bytes.Equal(readlinkBuffer[:n], expectedSocketName) {
216: 				return os.Readlink("/proc/" + pid + "/exe")
217: 			}
218: 		}
219: 	}
220: 
221: 	return "", fmt.Errorf("inode %d of uid %d not found", inode, uid)
222: }
223: 
224: func isPid(name string) bool {
225: 	for _, c := range name {
226: 		if c < '0' || c > '9' {
227: 			return false
228: 		}
229: 	}
230: 
231: 	return true
232: }


./component\process\process_other.go
1: //go:build !darwin && !linux && !windows && !freebsd
2: 
3: package process
4: 
5: import (
6: 	"net/netip"
7: )
8: 
9: func findProcessPath(_ string, _, _ netip.AddrPort) (string, error) {
10: 	return "", ErrPlatformNotSupport
11: }


./component\process\process_test.go
1: package process
2: 
3: import (
4: 	"net"
5: 	"net/netip"
6: 	"os"
7: 	"testing"
8: 
9: 	"github.com/stretchr/testify/assert"
10: )
11: 
12: func testConn(t *testing.T, network, address string) {
13: 	l, err := net.Listen(network, address)
14: 	if err != nil {
15: 		assert.FailNow(t, "Listen failed", err)
16: 	}
17: 	defer l.Close()
18: 
19: 	conn, err := net.Dial("tcp", l.Addr().String())
20: 	if err != nil {
21: 		assert.FailNow(t, "Dial failed", err)
22: 	}
23: 	defer conn.Close()
24: 
25: 	rConn, err := l.Accept()
26: 	if err != nil {
27: 		assert.FailNow(t, "Accept conn failed", err)
28: 	}
29: 	defer rConn.Close()
30: 
31: 	path, err := FindProcessPath(TCP, conn.LocalAddr().(*net.TCPAddr).AddrPort(), conn.RemoteAddr().(*net.TCPAddr).AddrPort())
32: 	if err != nil {
33: 		assert.FailNow(t, "Find process path failed", err)
34: 	}
35: 
36: 	exePath, err := os.Executable()
37: 	if err != nil {
38: 		assert.FailNow(t, "Get executable failed", err)
39: 	}
40: 
41: 	assert.Equal(t, exePath, path)
42: }
43: 
44: func TestFindProcessPathTCP(t *testing.T) {
45: 	t.Run("v4", func(t *testing.T) {
46: 		testConn(t, "tcp4", "127.0.0.1:0")
47: 	})
48: 	t.Run("v6", func(t *testing.T) {
49: 		testConn(t, "tcp6", "[::1]:0")
50: 	})
51: }
52: 
53: func testPacketConn(t *testing.T, network, lAddress, rAddress string) {
54: 	lConn, err := net.ListenPacket(network, lAddress)
55: 	if err != nil {
56: 		assert.FailNow(t, "ListenPacket failed", err)
57: 	}
58: 	defer lConn.Close()
59: 
60: 	rConn, err := net.ListenPacket(network, rAddress)
61: 	if err != nil {
62: 		assert.FailNow(t, "ListenPacket failed", err)
63: 	}
64: 	defer rConn.Close()
65: 
66: 	_, err = lConn.WriteTo([]byte{0}, rConn.LocalAddr())
67: 	if err != nil {
68: 		assert.FailNow(t, "Send message failed", err)
69: 	}
70: 
71: 	_, lAddr, err := rConn.ReadFrom([]byte{0})
72: 	if err != nil {
73: 		assert.FailNow(t, "Receive message failed", err)
74: 	}
75: 
76: 	path, err := FindProcessPath(UDP, lAddr.(*net.UDPAddr).AddrPort(), rConn.LocalAddr().(*net.UDPAddr).AddrPort())
77: 	if err != nil {
78: 		assert.FailNow(t, "Find process path", err)
79: 	}
80: 
81: 	exePath, err := os.Executable()
82: 	if err != nil {
83: 		assert.FailNow(t, "Find executable", err)
84: 	}
85: 
86: 	assert.Equal(t, exePath, path)
87: }
88: 
89: func TestFindProcessPathUDP(t *testing.T) {
90: 	t.Run("v4", func(t *testing.T) {
91: 		testPacketConn(t, "udp4", "127.0.0.1:0", "127.0.0.1:0")
92: 	})
93: 	t.Run("v6", func(t *testing.T) {
94: 		testPacketConn(t, "udp6", "[::1]:0", "[::1]:0")
95: 	})
96: 	t.Run("v4AnyLocal", func(t *testing.T) {
97: 		testPacketConn(t, "udp4", "0.0.0.0:0", "127.0.0.1:0")
98: 	})
99: 	t.Run("v6AnyLocal", func(t *testing.T) {
100: 		testPacketConn(t, "udp6", "[::]:0", "[::1]:0")
101: 	})
102: }
103: 
104: func BenchmarkFindProcessName(b *testing.B) {
105: 	from := netip.MustParseAddrPort("127.0.0.1:11447")
106: 	to := netip.MustParseAddrPort("127.0.0.1:33669")
107: 
108: 	b.ResetTimer()
109: 	for i := 0; i < b.N; i++ {
110: 		FindProcessPath(TCP, from, to)
111: 	}
112: }


./component\process\process_windows.go
1: package process
2: 
3: import (
4: 	"errors"
5: 	"fmt"
6: 	"net/netip"
7: 	"unsafe"
8: 
9: 	"github.com/Dreamacro/clash/common/pool"
10: 
11: 	"golang.org/x/sys/windows"
12: )
13: 
14: var (
15: 	modIphlpapi = windows.NewLazySystemDLL("iphlpapi.dll")
16: 
17: 	procGetExtendedTcpTable = modIphlpapi.NewProc("GetExtendedTcpTable")
18: 	procGetExtendedUdpTable = modIphlpapi.NewProc("GetExtendedUdpTable")
19: )
20: 
21: func findProcessPath(network string, from netip.AddrPort, to netip.AddrPort) (string, error) {
22: 	family := uint32(windows.AF_INET)
23: 	if from.Addr().Is6() {
24: 		family = windows.AF_INET6
25: 	}
26: 
27: 	var protocol uint32
28: 	switch network {
29: 	case TCP:
30: 		protocol = windows.IPPROTO_TCP
31: 	case UDP:
32: 		protocol = windows.IPPROTO_UDP
33: 	default:
34: 		return "", ErrInvalidNetwork
35: 	}
36: 
37: 	pid, err := findPidByConnectionEndpoint(family, protocol, from, to)
38: 	if err != nil {
39: 		return "", err
40: 	}
41: 
42: 	return getExecPathFromPID(pid)
43: }
44: 
45: func findPidByConnectionEndpoint(family uint32, protocol uint32, from netip.AddrPort, to netip.AddrPort) (uint32, error) {
46: 	buf := pool.Get(0)
47: 	defer pool.Put(buf)
48: 
49: 	bufSize := uint32(len(buf))
50: 
51: loop:
52: 	for {
53: 		var ret uintptr
54: 
55: 		switch protocol {
56: 		case windows.IPPROTO_TCP:
57: 			ret, _, _ = procGetExtendedTcpTable.Call(
58: 				uintptr(unsafe.Pointer(unsafe.SliceData(buf))),
59: 				uintptr(unsafe.Pointer(&bufSize)),
60: 				0,
61: 				uintptr(family),
62: 				4, // TCP_TABLE_OWNER_PID_CONNECTIONS
63: 				0,
64: 			)
65: 		case windows.IPPROTO_UDP:
66: 			ret, _, _ = procGetExtendedUdpTable.Call(
67: 				uintptr(unsafe.Pointer(unsafe.SliceData(buf))),
68: 				uintptr(unsafe.Pointer(&bufSize)),
69: 				0,
70: 				uintptr(family),
71: 				1, // UDP_TABLE_OWNER_PID
72: 				0,
73: 			)
74: 		default:
75: 			return 0, errors.New("unsupported network")
76: 		}
77: 
78: 		switch ret {
79: 		case 0:
80: 			buf = buf[:bufSize]
81: 
82: 			break loop
83: 		case uintptr(windows.ERROR_INSUFFICIENT_BUFFER):
84: 			pool.Put(buf)
85: 			buf = pool.Get(int(bufSize))
86: 
87: 			continue loop
88: 		default:
89: 			return 0, fmt.Errorf("syscall error: %d", ret)
90: 		}
91: 	}
92: 
93: 	if len(buf) < int(unsafe.Sizeof(uint32(0))) {
94: 		return 0, fmt.Errorf("invalid table size: %d", len(buf))
95: 	}
96: 
97: 	entriesSize := *(*uint32)(unsafe.Pointer(&buf[0]))
98: 
99: 	switch protocol {
100: 	case windows.IPPROTO_TCP:
101: 		if family == windows.AF_INET {
102: 			type MibTcpRowOwnerPid struct {
103: 				State      uint32
104: 				LocalAddr  [4]byte
105: 				LocalPort  uint32
106: 				RemoteAddr [4]byte
107: 				RemotePort uint32
108: 				OwningPid  uint32
109: 			}
110: 
111: 			if uint32(len(buf))-4 < entriesSize*uint32(unsafe.Sizeof(MibTcpRowOwnerPid{})) {
112: 				return 0, fmt.Errorf("invalid tables size: %d", len(buf))
113: 			}
114: 
115: 			entries := unsafe.Slice((*MibTcpRowOwnerPid)(unsafe.Pointer(&buf[4])), entriesSize)
116: 			for _, entry := range entries {
117: 				localAddr := netip.AddrFrom4(entry.LocalAddr)
118: 				localPort := windows.Ntohs(uint16(entry.LocalPort))
119: 				remoteAddr := netip.AddrFrom4(entry.RemoteAddr)
120: 				remotePort := windows.Ntohs(uint16(entry.RemotePort))
121: 
122: 				if localAddr == from.Addr() && remoteAddr == to.Addr() && localPort == from.Port() && remotePort == to.Port() {
123: 					return entry.OwningPid, nil
124: 				}
125: 			}
126: 		} else {
127: 			type MibTcp6RowOwnerPid struct {
128: 				LocalAddr     [16]byte
129: 				LocalScopeID  uint32
130: 				LocalPort     uint32
131: 				RemoteAddr    [16]byte
132: 				RemoteScopeID uint32
133: 				RemotePort    uint32
134: 				State         uint32
135: 				OwningPid     uint32
136: 			}
137: 
138: 			if uint32(len(buf))-4 < entriesSize*uint32(unsafe.Sizeof(MibTcp6RowOwnerPid{})) {
139: 				return 0, fmt.Errorf("invalid tables size: %d", len(buf))
140: 			}
141: 
142: 			entries := unsafe.Slice((*MibTcp6RowOwnerPid)(unsafe.Pointer(&buf[4])), entriesSize)
143: 			for _, entry := range entries {
144: 				localAddr := netip.AddrFrom16(entry.LocalAddr)
145: 				localPort := windows.Ntohs(uint16(entry.LocalPort))
146: 				remoteAddr := netip.AddrFrom16(entry.RemoteAddr)
147: 				remotePort := windows.Ntohs(uint16(entry.RemotePort))
148: 
149: 				if localAddr == from.Addr() && remoteAddr == to.Addr() && localPort == from.Port() && remotePort == to.Port() {
150: 					return entry.OwningPid, nil
151: 				}
152: 			}
153: 		}
154: 	case windows.IPPROTO_UDP:
155: 		if family == windows.AF_INET {
156: 			type MibUdpRowOwnerPid struct {
157: 				LocalAddr [4]byte
158: 				LocalPort uint32
159: 				OwningPid uint32
160: 			}
161: 
162: 			if uint32(len(buf))-4 < entriesSize*uint32(unsafe.Sizeof(MibUdpRowOwnerPid{})) {
163: 				return 0, fmt.Errorf("invalid tables size: %d", len(buf))
164: 			}
165: 
166: 			entries := unsafe.Slice((*MibUdpRowOwnerPid)(unsafe.Pointer(&buf[4])), entriesSize)
167: 			for _, entry := range entries {
168: 				localAddr := netip.AddrFrom4(entry.LocalAddr)
169: 				localPort := windows.Ntohs(uint16(entry.LocalPort))
170: 
171: 				if (localAddr == from.Addr() || localAddr.IsUnspecified()) && localPort == from.Port() {
172: 					return entry.OwningPid, nil
173: 				}
174: 			}
175: 		} else {
176: 			type MibUdp6RowOwnerPid struct {
177: 				LocalAddr    [16]byte
178: 				LocalScopeId uint32
179: 				LocalPort    uint32
180: 				OwningPid    uint32
181: 			}
182: 
183: 			if uint32(len(buf))-4 < entriesSize*uint32(unsafe.Sizeof(MibUdp6RowOwnerPid{})) {
184: 				return 0, fmt.Errorf("invalid tables size: %d", len(buf))
185: 			}
186: 
187: 			entries := unsafe.Slice((*MibUdp6RowOwnerPid)(unsafe.Pointer(&buf[4])), entriesSize)
188: 			for _, entry := range entries {
189: 				localAddr := netip.AddrFrom16(entry.LocalAddr)
190: 				localPort := windows.Ntohs(uint16(entry.LocalPort))
191: 
192: 				if (localAddr == from.Addr() || localAddr.IsUnspecified()) && localPort == from.Port() {
193: 					return entry.OwningPid, nil
194: 				}
195: 			}
196: 		}
197: 	default:
198: 		return 0, ErrInvalidNetwork
199: 	}
200: 
201: 	return 0, ErrNotFound
202: }
203: 
204: func getExecPathFromPID(pid uint32) (string, error) {
205: 	// kernel process starts with a colon in order to distinguish with normal processes
206: 	switch pid {
207: 	case 0:
208: 		// reserved pid for system idle process
209: 		return ":System Idle Process", nil
210: 	case 4:
211: 		// reserved pid for windows kernel image
212: 		return ":System", nil
213: 	}
214: 	h, err := windows.OpenProcess(windows.PROCESS_QUERY_LIMITED_INFORMATION, false, pid)
215: 	if err != nil {
216: 		return "", err
217: 	}
218: 	defer windows.CloseHandle(h)
219: 
220: 	buf := make([]uint16, windows.MAX_LONG_PATH)
221: 	size := uint32(len(buf))
222: 
223: 	err = windows.QueryFullProcessImageName(h, 0, &buf[0], &size)
224: 	if err != nil {
225: 		return "", err
226: 	}
227: 
228: 	return windows.UTF16ToString(buf[:size]), nil
229: }


./component\profile\profile.go
1: package profile
2: 
3: import (
4: 	"go.uber.org/atomic"
5: )
6: 
7: // StoreSelected is a global switch for storing selected proxy to cache
8: var StoreSelected = atomic.NewBool(true)


./component\profile\cachefile\cache.go
1: package cachefile
2: 
3: import (
4: 	"os"
5: 	"sync"
6: 	"time"
7: 
8: 	"github.com/Dreamacro/clash/component/profile"
9: 	C "github.com/Dreamacro/clash/constant"
10: 	"github.com/Dreamacro/clash/log"
11: 
12: 	"go.etcd.io/bbolt"
13: )
14: 
15: var (
16: 	fileMode os.FileMode = 0o666
17: 
18: 	bucketSelected = []byte("selected")
19: 	bucketFakeip   = []byte("fakeip")
20: )
21: 
22: // CacheFile store and update the cache file
23: type CacheFile struct {
24: 	DB *bbolt.DB
25: }
26: 
27: func (c *CacheFile) SetSelected(group, selected string) {
28: 	if !profile.StoreSelected.Load() {
29: 		return
30: 	} else if c.DB == nil {
31: 		return
32: 	}
33: 
34: 	err := c.DB.Batch(func(t *bbolt.Tx) error {
35: 		bucket, err := t.CreateBucketIfNotExists(bucketSelected)
36: 		if err != nil {
37: 			return err
38: 		}
39: 		return bucket.Put([]byte(group), []byte(selected))
40: 	})
41: 	if err != nil {
42: 		log.Warnln("[CacheFile] write cache to %s failed: %s", c.DB.Path(), err.Error())
43: 		return
44: 	}
45: }
46: 
47: func (c *CacheFile) SelectedMap() map[string]string {
48: 	if !profile.StoreSelected.Load() {
49: 		return nil
50: 	} else if c.DB == nil {
51: 		return nil
52: 	}
53: 
54: 	mapping := map[string]string{}
55: 	c.DB.View(func(t *bbolt.Tx) error {
56: 		bucket := t.Bucket(bucketSelected)
57: 		if bucket == nil {
58: 			return nil
59: 		}
60: 
61: 		c := bucket.Cursor()
62: 		for k, v := c.First(); k != nil; k, v = c.Next() {
63: 			mapping[string(k)] = string(v)
64: 		}
65: 		return nil
66: 	})
67: 	return mapping
68: }
69: 
70: func (c *CacheFile) PutFakeip(key, value []byte) error {
71: 	if c.DB == nil {
72: 		return nil
73: 	}
74: 
75: 	err := c.DB.Batch(func(t *bbolt.Tx) error {
76: 		bucket, err := t.CreateBucketIfNotExists(bucketFakeip)
77: 		if err != nil {
78: 			return err
79: 		}
80: 		return bucket.Put(key, value)
81: 	})
82: 	if err != nil {
83: 		log.Warnln("[CacheFile] write cache to %s failed: %s", c.DB.Path(), err.Error())
84: 	}
85: 
86: 	return err
87: }
88: 
89: func (c *CacheFile) DelFakeipPair(ip, host []byte) error {
90: 	if c.DB == nil {
91: 		return nil
92: 	}
93: 
94: 	err := c.DB.Batch(func(t *bbolt.Tx) error {
95: 		bucket, err := t.CreateBucketIfNotExists(bucketFakeip)
96: 		if err != nil {
97: 			return err
98: 		}
99: 		err = bucket.Delete(ip)
100: 		if len(host) > 0 {
101: 			if err := bucket.Delete(host); err != nil {
102: 				return err
103: 			}
104: 		}
105: 		return err
106: 	})
107: 	if err != nil {
108: 		log.Warnln("[CacheFile] write cache to %s failed: %s", c.DB.Path(), err.Error())
109: 	}
110: 
111: 	return err
112: }
113: 
114: func (c *CacheFile) GetFakeip(key []byte) []byte {
115: 	if c.DB == nil {
116: 		return nil
117: 	}
118: 
119: 	tx, err := c.DB.Begin(false)
120: 	if err != nil {
121: 		return nil
122: 	}
123: 	defer tx.Rollback()
124: 
125: 	bucket := tx.Bucket(bucketFakeip)
126: 	if bucket == nil {
127: 		return nil
128: 	}
129: 
130: 	return bucket.Get(key)
131: }
132: 
133: func (c *CacheFile) Close() error {
134: 	return c.DB.Close()
135: }
136: 
137: // Cache return singleton of CacheFile
138: var Cache = sync.OnceValue(func() *CacheFile {
139: 	options := bbolt.Options{Timeout: time.Second}
140: 	db, err := bbolt.Open(C.Path.Cache(), fileMode, &options)
141: 	switch err {
142: 	case bbolt.ErrInvalid, bbolt.ErrChecksum, bbolt.ErrVersionMismatch:
143: 		if err = os.Remove(C.Path.Cache()); err != nil {
144: 			log.Warnln("[CacheFile] remove invalid cache file error: %s", err.Error())
145: 			break
146: 		}
147: 		log.Infoln("[CacheFile] remove invalid cache file and create new one")
148: 		db, err = bbolt.Open(C.Path.Cache(), fileMode, &options)
149: 	}
150: 	if err != nil {
151: 		log.Warnln("[CacheFile] can't open cache file: %s", err.Error())
152: 	}
153: 
154: 	return &CacheFile{
155: 		DB: db,
156: 	}
157: })


./component\resolver\defaults.go
1: //go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris
2: 
3: package resolver
4: 
5: import _ "unsafe"
6: 
7: //go:linkname defaultNS net.defaultNS
8: var defaultNS []string
9: 
10: func init() {
11: 	defaultNS = []string{"114.114.114.114:53", "8.8.8.8:53"}
12: }


./component\resolver\enhancer.go
1: package resolver
2: 
3: import (
4: 	"net"
5: )
6: 
7: var DefaultHostMapper Enhancer
8: 
9: type Enhancer interface {
10: 	FakeIPEnabled() bool
11: 	MappingEnabled() bool
12: 	IsFakeIP(net.IP) bool
13: 	IsExistFakeIP(net.IP) bool
14: 	FindHostByIP(net.IP) (string, bool)
15: }
16: 
17: func FakeIPEnabled() bool {
18: 	if mapper := DefaultHostMapper; mapper != nil {
19: 		return mapper.FakeIPEnabled()
20: 	}
21: 
22: 	return false
23: }
24: 
25: func MappingEnabled() bool {
26: 	if mapper := DefaultHostMapper; mapper != nil {
27: 		return mapper.MappingEnabled()
28: 	}
29: 
30: 	return false
31: }
32: 
33: func IsFakeIP(ip net.IP) bool {
34: 	if mapper := DefaultHostMapper; mapper != nil {
35: 		return mapper.IsFakeIP(ip)
36: 	}
37: 
38: 	return false
39: }
40: 
41: func IsExistFakeIP(ip net.IP) bool {
42: 	if mapper := DefaultHostMapper; mapper != nil {
43: 		return mapper.IsExistFakeIP(ip)
44: 	}
45: 
46: 	return false
47: }
48: 
49: func FindHostByIP(ip net.IP) (string, bool) {
50: 	if mapper := DefaultHostMapper; mapper != nil {
51: 		return mapper.FindHostByIP(ip)
52: 	}
53: 
54: 	return "", false
55: }


./component\resolver\resolver.go
1: package resolver
2: 
3: import (
4: 	"context"
5: 	"errors"
6: 	"fmt"
7: 	"math/rand"
8: 	"net"
9: 	"strings"
10: 	"time"
11: 
12: 	"github.com/Dreamacro/clash/component/trie"
13: 
14: 	"github.com/miekg/dns"
15: )
16: 
17: var (
18: 	// DefaultResolver aim to resolve ip
19: 	DefaultResolver Resolver
20: 
21: 	// DisableIPv6 means don't resolve ipv6 host
22: 	// default value is true
23: 	DisableIPv6 = true
24: 
25: 	// DefaultHosts aim to resolve hosts
26: 	DefaultHosts = trie.New()
27: 
28: 	// DefaultDNSTimeout defined the default dns request timeout
29: 	DefaultDNSTimeout = time.Second * 5
30: )
31: 
32: var (
33: 	ErrIPNotFound   = errors.New("couldn't find ip")
34: 	ErrIPVersion    = errors.New("ip version error")
35: 	ErrIPv6Disabled = errors.New("ipv6 disabled")
36: )
37: 
38: type Resolver interface {
39: 	LookupIP(ctx context.Context, host string) ([]net.IP, error)
40: 	LookupIPv4(ctx context.Context, host string) ([]net.IP, error)
41: 	LookupIPv6(ctx context.Context, host string) ([]net.IP, error)
42: 	ResolveIP(host string) (ip net.IP, err error)
43: 	ResolveIPv4(host string) (ip net.IP, err error)
44: 	ResolveIPv6(host string) (ip net.IP, err error)
45: 	ExchangeContext(ctx context.Context, m *dns.Msg) (msg *dns.Msg, err error)
46: }
47: 
48: // LookupIPv4 with a host, return ipv4 list
49: func LookupIPv4(ctx context.Context, host string) ([]net.IP, error) {
50: 	if node := DefaultHosts.Search(host); node != nil {
51: 		if ip := node.Data.(net.IP).To4(); ip != nil {
52: 			return []net.IP{ip}, nil
53: 		}
54: 	}
55: 
56: 	ip := net.ParseIP(host)
57: 	if ip != nil {
58: 		if !strings.Contains(host, ":") {
59: 			return []net.IP{ip}, nil
60: 		}
61: 		return nil, ErrIPVersion
62: 	}
63: 
64: 	if DefaultResolver != nil {
65: 		return DefaultResolver.LookupIPv4(ctx, host)
66: 	}
67: 
68: 	ctx, cancel := context.WithTimeout(context.Background(), DefaultDNSTimeout)
69: 	defer cancel()
70: 	ipAddrs, err := net.DefaultResolver.LookupIP(ctx, "ip4", host)
71: 	if err != nil {
72: 		return nil, err
73: 	} else if len(ipAddrs) == 0 {
74: 		return nil, ErrIPNotFound
75: 	}
76: 
77: 	return ipAddrs, nil
78: }
79: 
80: // ResolveIPv4 with a host, return ipv4
81: func ResolveIPv4(host string) (net.IP, error) {
82: 	ips, err := LookupIPv4(context.Background(), host)
83: 	if err != nil {
84: 		return nil, err
85: 	} else if len(ips) == 0 {
86: 		return nil, fmt.Errorf("%w: %s", ErrIPNotFound, host)
87: 	}
88: 	return ips[rand.Intn(len(ips))], nil
89: }
90: 
91: // LookupIPv6 with a host, return ipv6 list
92: func LookupIPv6(ctx context.Context, host string) ([]net.IP, error) {
93: 	if DisableIPv6 {
94: 		return nil, ErrIPv6Disabled
95: 	}
96: 
97: 	if node := DefaultHosts.Search(host); node != nil {
98: 		if ip := node.Data.(net.IP).To16(); ip != nil {
99: 			return []net.IP{ip}, nil
100: 		}
101: 	}
102: 
103: 	ip := net.ParseIP(host)
104: 	if ip != nil {
105: 		if strings.Contains(host, ":") {
106: 			return []net.IP{ip}, nil
107: 		}
108: 		return nil, ErrIPVersion
109: 	}
110: 
111: 	if DefaultResolver != nil {
112: 		return DefaultResolver.LookupIPv6(ctx, host)
113: 	}
114: 
115: 	ctx, cancel := context.WithTimeout(context.Background(), DefaultDNSTimeout)
116: 	defer cancel()
117: 	ipAddrs, err := net.DefaultResolver.LookupIP(ctx, "ip6", host)
118: 	if err != nil {
119: 		return nil, err
120: 	} else if len(ipAddrs) == 0 {
121: 		return nil, ErrIPNotFound
122: 	}
123: 
124: 	return ipAddrs, nil
125: }
126: 
127: // ResolveIPv6 with a host, return ipv6
128: func ResolveIPv6(host string) (net.IP, error) {
129: 	ips, err := LookupIPv6(context.Background(), host)
130: 	if err != nil {
131: 		return nil, err
132: 	} else if len(ips) == 0 {
133: 		return nil, fmt.Errorf("%w: %s", ErrIPNotFound, host)
134: 	}
135: 	return ips[rand.Intn(len(ips))], nil
136: }
137: 
138: // LookupIPWithResolver same as ResolveIP, but with a resolver
139: func LookupIPWithResolver(ctx context.Context, host string, r Resolver) ([]net.IP, error) {
140: 	if node := DefaultHosts.Search(host); node != nil {
141: 		return []net.IP{node.Data.(net.IP)}, nil
142: 	}
143: 
144: 	if r != nil {
145: 		if DisableIPv6 {
146: 			return r.LookupIPv4(ctx, host)
147: 		}
148: 		return r.LookupIP(ctx, host)
149: 	} else if DisableIPv6 {
150: 		return LookupIPv4(ctx, host)
151: 	}
152: 
153: 	ip := net.ParseIP(host)
154: 	if ip != nil {
155: 		return []net.IP{ip}, nil
156: 	}
157: 
158: 	ips, err := net.DefaultResolver.LookupIP(ctx, "ip", host)
159: 	if err != nil {
160: 		return nil, err
161: 	} else if len(ips) == 0 {
162: 		return nil, ErrIPNotFound
163: 	}
164: 
165: 	return ips, nil
166: }
167: 
168: // ResolveIP with a host, return ip
169: func LookupIP(ctx context.Context, host string) ([]net.IP, error) {
170: 	return LookupIPWithResolver(ctx, host, DefaultResolver)
171: }
172: 
173: // ResolveIP with a host, return ip
174: func ResolveIP(host string) (net.IP, error) {
175: 	ips, err := LookupIP(context.Background(), host)
176: 	if err != nil {
177: 		return nil, err
178: 	} else if len(ips) == 0 {
179: 		return nil, fmt.Errorf("%w: %s", ErrIPNotFound, host)
180: 	}
181: 	return ips[rand.Intn(len(ips))], nil
182: }


./component\trie\domain.go
1: package trie
2: 
3: import (
4: 	"errors"
5: 	"strings"
6: )
7: 
8: const (
9: 	wildcard        = "*"
10: 	dotWildcard     = ""
11: 	complexWildcard = "+"
12: 	domainStep      = "."
13: )
14: 
15: // ErrInvalidDomain means insert domain is invalid
16: var ErrInvalidDomain = errors.New("invalid domain")
17: 
18: // DomainTrie contains the main logic for adding and searching nodes for domain segments.
19: // support wildcard domain (e.g *.google.com)
20: type DomainTrie struct {
21: 	root *Node
22: }
23: 
24: func ValidAndSplitDomain(domain string) ([]string, bool) {
25: 	if domain != "" && domain[len(domain)-1] == '.' {
26: 		return nil, false
27: 	}
28: 
29: 	parts := strings.Split(domain, domainStep)
30: 	if len(parts) == 1 {
31: 		if parts[0] == "" {
32: 			return nil, false
33: 		}
34: 
35: 		return parts, true
36: 	}
37: 
38: 	for _, part := range parts[1:] {
39: 		if part == "" {
40: 			return nil, false
41: 		}
42: 	}
43: 
44: 	return parts, true
45: }
46: 
47: // Insert adds a node to the trie.
48: // Support
49: // 1. www.example.com
50: // 2. *.example.com
51: // 3. subdomain.*.example.com
52: // 4. .example.com
53: // 5. +.example.com
54: func (t *DomainTrie) Insert(domain string, data any) error {
55: 	parts, valid := ValidAndSplitDomain(domain)
56: 	if !valid {
57: 		return ErrInvalidDomain
58: 	}
59: 
60: 	if parts[0] == complexWildcard {
61: 		t.insert(parts[1:], data)
62: 		parts[0] = dotWildcard
63: 		t.insert(parts, data)
64: 	} else {
65: 		t.insert(parts, data)
66: 	}
67: 
68: 	return nil
69: }
70: 
71: func (t *DomainTrie) insert(parts []string, data any) {
72: 	node := t.root
73: 	// reverse storage domain part to save space
74: 	for i := len(parts) - 1; i >= 0; i-- {
75: 		part := parts[i]
76: 		if !node.hasChild(part) {
77: 			node.addChild(part, newNode(nil))
78: 		}
79: 
80: 		node = node.getChild(part)
81: 	}
82: 
83: 	node.Data = data
84: }
85: 
86: // Search is the most important part of the Trie.
87: // Priority as:
88: // 1. static part
89: // 2. wildcard domain
90: // 2. dot wildcard domain
91: func (t *DomainTrie) Search(domain string) *Node {
92: 	parts, valid := ValidAndSplitDomain(domain)
93: 	if !valid || parts[0] == "" {
94: 		return nil
95: 	}
96: 
97: 	n := t.search(t.root, parts)
98: 
99: 	if n == nil || n.Data == nil {
100: 		return nil
101: 	}
102: 
103: 	return n
104: }
105: 
106: func (t *DomainTrie) search(node *Node, parts []string) *Node {
107: 	if len(parts) == 0 {
108: 		return node
109: 	}
110: 
111: 	if c := node.getChild(parts[len(parts)-1]); c != nil {
112: 		if n := t.search(c, parts[:len(parts)-1]); n != nil && n.Data != nil {
113: 			return n
114: 		}
115: 	}
116: 
117: 	if c := node.getChild(wildcard); c != nil {
118: 		if n := t.search(c, parts[:len(parts)-1]); n != nil && n.Data != nil {
119: 			return n
120: 		}
121: 	}
122: 
123: 	return node.getChild(dotWildcard)
124: }
125: 
126: // New returns a new, empty Trie.
127: func New() *DomainTrie {
128: 	return &DomainTrie{root: newNode(nil)}
129: }


./component\trie\domain_test.go
1: package trie
2: 
3: import (
4: 	"net"
5: 	"testing"
6: 
7: 	"github.com/stretchr/testify/assert"
8: )
9: 
10: var localIP = net.IP{127, 0, 0, 1}
11: 
12: func TestTrie_Basic(t *testing.T) {
13: 	tree := New()
14: 	domains := []string{
15: 		"example.com",
16: 		"google.com",
17: 		"localhost",
18: 	}
19: 
20: 	for _, domain := range domains {
21: 		tree.Insert(domain, localIP)
22: 	}
23: 
24: 	node := tree.Search("example.com")
25: 	assert.NotNil(t, node)
26: 	assert.True(t, node.Data.(net.IP).Equal(localIP))
27: 	assert.NotNil(t, tree.Insert("", localIP))
28: 	assert.Nil(t, tree.Search(""))
29: 	assert.NotNil(t, tree.Search("localhost"))
30: 	assert.Nil(t, tree.Search("www.google.com"))
31: }
32: 
33: func TestTrie_Wildcard(t *testing.T) {
34: 	tree := New()
35: 	domains := []string{
36: 		"*.example.com",
37: 		"sub.*.example.com",
38: 		"*.dev",
39: 		".org",
40: 		".example.net",
41: 		".apple.*",
42: 		"+.foo.com",
43: 		"+.stun.*.*",
44: 		"+.stun.*.*.*",
45: 		"+.stun.*.*.*.*",
46: 		"stun.l.google.com",
47: 	}
48: 
49: 	for _, domain := range domains {
50: 		tree.Insert(domain, localIP)
51: 	}
52: 
53: 	assert.NotNil(t, tree.Search("sub.example.com"))
54: 	assert.NotNil(t, tree.Search("sub.foo.example.com"))
55: 	assert.NotNil(t, tree.Search("test.org"))
56: 	assert.NotNil(t, tree.Search("test.example.net"))
57: 	assert.NotNil(t, tree.Search("test.apple.com"))
58: 	assert.NotNil(t, tree.Search("test.foo.com"))
59: 	assert.NotNil(t, tree.Search("foo.com"))
60: 	assert.NotNil(t, tree.Search("global.stun.website.com"))
61: 	assert.Nil(t, tree.Search("foo.sub.example.com"))
62: 	assert.Nil(t, tree.Search("foo.example.dev"))
63: 	assert.Nil(t, tree.Search("example.com"))
64: }
65: 
66: func TestTrie_Priority(t *testing.T) {
67: 	tree := New()
68: 	domains := []string{
69: 		".dev",
70: 		"example.dev",
71: 		"*.example.dev",
72: 		"test.example.dev",
73: 	}
74: 
75: 	assertFn := func(domain string, data int) {
76: 		node := tree.Search(domain)
77: 		assert.NotNil(t, node)
78: 		assert.Equal(t, data, node.Data)
79: 	}
80: 
81: 	for idx, domain := range domains {
82: 		tree.Insert(domain, idx)
83: 	}
84: 
85: 	assertFn("test.dev", 0)
86: 	assertFn("foo.bar.dev", 0)
87: 	assertFn("example.dev", 1)
88: 	assertFn("foo.example.dev", 2)
89: 	assertFn("test.example.dev", 3)
90: }
91: 
92: func TestTrie_Boundary(t *testing.T) {
93: 	tree := New()
94: 	tree.Insert("*.dev", localIP)
95: 
96: 	assert.NotNil(t, tree.Insert(".", localIP))
97: 	assert.NotNil(t, tree.Insert("..dev", localIP))
98: 	assert.Nil(t, tree.Search("dev"))
99: }
100: 
101: func TestTrie_WildcardBoundary(t *testing.T) {
102: 	tree := New()
103: 	tree.Insert("+.*", localIP)
104: 	tree.Insert("stun.*.*.*", localIP)
105: 
106: 	assert.NotNil(t, tree.Search("example.com"))
107: }


./component\trie\node.go
1: package trie
2: 
3: // Node is the trie's node
4: type Node struct {
5: 	children map[string]*Node
6: 	Data     any
7: }
8: 
9: func (n *Node) getChild(s string) *Node {
10: 	return n.children[s]
11: }
12: 
13: func (n *Node) hasChild(s string) bool {
14: 	return n.getChild(s) != nil
15: }
16: 
17: func (n *Node) addChild(s string, child *Node) {
18: 	n.children[s] = child
19: }
20: 
21: func newNode(data any) *Node {
22: 	return &Node{
23: 		Data:     data,
24: 		children: map[string]*Node{},
25: 	}
26: }


./config\config.go
1: package config
2: 
3: import (
4: 	"errors"
5: 	"fmt"
6: 	"net"
7: 	"net/url"
8: 	"os"
9: 	"strings"
10: 
11: 	"github.com/Dreamacro/clash/adapter"
12: 	"github.com/Dreamacro/clash/adapter/outbound"
13: 	"github.com/Dreamacro/clash/adapter/outboundgroup"
14: 	"github.com/Dreamacro/clash/adapter/provider"
15: 	"github.com/Dreamacro/clash/component/auth"
16: 	"github.com/Dreamacro/clash/component/fakeip"
17: 	"github.com/Dreamacro/clash/component/trie"
18: 	C "github.com/Dreamacro/clash/constant"
19: 	providerTypes "github.com/Dreamacro/clash/constant/provider"
20: 	"github.com/Dreamacro/clash/dns"
21: 	"github.com/Dreamacro/clash/log"
22: 	R "github.com/Dreamacro/clash/rule"
23: 	T "github.com/Dreamacro/clash/tunnel"
24: 
25: 	"github.com/samber/lo"
26: 	"gopkg.in/yaml.v3"
27: )
28: 
29: // General config
30: type General struct {
31: 	LegacyInbound
32: 	Controller
33: 	Authentication []string     `json:"authentication"`
34: 	Mode           T.TunnelMode `json:"mode"`
35: 	LogLevel       log.LogLevel `json:"log-level"`
36: 	IPv6           bool         `json:"ipv6"`
37: 	Interface      string       `json:"-"`
38: 	RoutingMark    int          `json:"-"`
39: }
40: 
41: // Controller
42: type Controller struct {
43: 	ExternalController string `json:"-"`
44: 	ExternalUI         string `json:"-"`
45: 	Secret             string `json:"-"`
46: }
47: 
48: type LegacyInbound struct {
49: 	Port        int    `json:"port"`
50: 	SocksPort   int    `json:"socks-port"`
51: 	RedirPort   int    `json:"redir-port"`
52: 	TProxyPort  int    `json:"tproxy-port"`
53: 	MixedPort   int    `json:"mixed-port"`
54: 	AllowLan    bool   `json:"allow-lan"`
55: 	BindAddress string `json:"bind-address"`
56: }
57: 
58: // DNS config
59: type DNS struct {
60: 	Enable            bool             `yaml:"enable"`
61: 	IPv6              bool             `yaml:"ipv6"`
62: 	NameServer        []dns.NameServer `yaml:"nameserver"`
63: 	Fallback          []dns.NameServer `yaml:"fallback"`
64: 	FallbackFilter    FallbackFilter   `yaml:"fallback-filter"`
65: 	Listen            string           `yaml:"listen"`
66: 	EnhancedMode      C.DNSMode        `yaml:"enhanced-mode"`
67: 	DefaultNameserver []dns.NameServer `yaml:"default-nameserver"`
68: 	FakeIPRange       *fakeip.Pool
69: 	Hosts             *trie.DomainTrie
70: 	NameServerPolicy  map[string]dns.NameServer
71: 	SearchDomains     []string
72: }
73: 
74: // FallbackFilter config
75: type FallbackFilter struct {
76: 	GeoIP     bool         `yaml:"geoip"`
77: 	GeoIPCode string       `yaml:"geoip-code"`
78: 	IPCIDR    []*net.IPNet `yaml:"ipcidr"`
79: 	Domain    []string     `yaml:"domain"`
80: }
81: 
82: // Profile config
83: type Profile struct {
84: 	StoreSelected bool `yaml:"store-selected"`
85: 	StoreFakeIP   bool `yaml:"store-fake-ip"`
86: }
87: 
88: // Experimental config
89: type Experimental struct {
90: 	UDPFallbackMatch bool `yaml:"udp-fallback-match"`
91: }
92: 
93: // Config is clash config manager
94: type Config struct {
95: 	General      *General
96: 	DNS          *DNS
97: 	Experimental *Experimental
98: 	Hosts        *trie.DomainTrie
99: 	Profile      *Profile
100: 	Inbounds     []C.Inbound
101: 	Rules        []C.Rule
102: 	Users        []auth.AuthUser
103: 	Proxies      map[string]C.Proxy
104: 	Providers    map[string]providerTypes.ProxyProvider
105: 	Tunnels      []Tunnel
106: }
107: 
108: type RawDNS struct {
109: 	Enable            bool              `yaml:"enable"`
110: 	IPv6              *bool             `yaml:"ipv6"`
111: 	UseHosts          bool              `yaml:"use-hosts"`
112: 	NameServer        []string          `yaml:"nameserver"`
113: 	Fallback          []string          `yaml:"fallback"`
114: 	FallbackFilter    RawFallbackFilter `yaml:"fallback-filter"`
115: 	Listen            string            `yaml:"listen"`
116: 	EnhancedMode      C.DNSMode         `yaml:"enhanced-mode"`
117: 	FakeIPRange       string            `yaml:"fake-ip-range"`
118: 	FakeIPFilter      []string          `yaml:"fake-ip-filter"`
119: 	DefaultNameserver []string          `yaml:"default-nameserver"`
120: 	NameServerPolicy  map[string]string `yaml:"nameserver-policy"`
121: 	SearchDomains     []string          `yaml:"search-domains"`
122: }
123: 
124: type RawFallbackFilter struct {
125: 	GeoIP     bool     `yaml:"geoip"`
126: 	GeoIPCode string   `yaml:"geoip-code"`
127: 	IPCIDR    []string `yaml:"ipcidr"`
128: 	Domain    []string `yaml:"domain"`
129: }
130: 
131: type tunnel struct {
132: 	Network []string `yaml:"network"`
133: 	Address string   `yaml:"address"`
134: 	Target  string   `yaml:"target"`
135: 	Proxy   string   `yaml:"proxy"`
136: }
137: 
138: type Tunnel tunnel
139: 
140: // UnmarshalYAML implements yaml.Unmarshaler
141: func (t *Tunnel) UnmarshalYAML(unmarshal func(any) error) error {
142: 	var tp string
143: 	if err := unmarshal(&tp); err != nil {
144: 		var inner tunnel
145: 		if err := unmarshal(&inner); err != nil {
146: 			return err
147: 		}
148: 
149: 		*t = Tunnel(inner)
150: 		return nil
151: 	}
152: 
153: 	// parse udp/tcp,address,target,proxy
154: 	parts := lo.Map(strings.Split(tp, ","), func(s string, _ int) string {
155: 		return strings.TrimSpace(s)
156: 	})
157: 	if len(parts) != 4 {
158: 		return fmt.Errorf("invalid tunnel config %s", tp)
159: 	}
160: 	network := strings.Split(parts[0], "/")
161: 
162: 	// validate network
163: 	for _, n := range network {
164: 		switch n {
165: 		case "tcp", "udp":
166: 		default:
167: 			return fmt.Errorf("invalid tunnel network %s", n)
168: 		}
169: 	}
170: 
171: 	// validate address and target
172: 	address := parts[1]
173: 	target := parts[2]
174: 	for _, addr := range []string{address, target} {
175: 		if _, _, err := net.SplitHostPort(addr); err != nil {
176: 			return fmt.Errorf("invalid tunnel target or address %s", addr)
177: 		}
178: 	}
179: 
180: 	*t = Tunnel(tunnel{
181: 		Network: network,
182: 		Address: address,
183: 		Target:  target,
184: 		Proxy:   parts[3],
185: 	})
186: 	return nil
187: }
188: 
189: type RawConfig struct {
190: 	Port               int          `yaml:"port"`
191: 	SocksPort          int          `yaml:"socks-port"`
192: 	RedirPort          int          `yaml:"redir-port"`
193: 	TProxyPort         int          `yaml:"tproxy-port"`
194: 	MixedPort          int          `yaml:"mixed-port"`
195: 	Authentication     []string     `yaml:"authentication"`
196: 	AllowLan           bool         `yaml:"allow-lan"`
197: 	BindAddress        string       `yaml:"bind-address"`
198: 	Mode               T.TunnelMode `yaml:"mode"`
199: 	LogLevel           log.LogLevel `yaml:"log-level"`
200: 	IPv6               bool         `yaml:"ipv6"`
201: 	ExternalController string       `yaml:"external-controller"`
202: 	ExternalUI         string       `yaml:"external-ui"`
203: 	Secret             string       `yaml:"secret"`
204: 	Interface          string       `yaml:"interface-name"`
205: 	RoutingMark        int          `yaml:"routing-mark"`
206: 	Tunnels            []Tunnel     `yaml:"tunnels"`
207: 
208: 	ProxyProvider map[string]map[string]any `yaml:"proxy-providers"`
209: 	Hosts         map[string]string         `yaml:"hosts"`
210: 	Inbounds      []C.Inbound               `yaml:"inbounds"`
211: 	DNS           RawDNS                    `yaml:"dns"`
212: 	Experimental  Experimental              `yaml:"experimental"`
213: 	Profile       Profile                   `yaml:"profile"`
214: 	Proxy         []map[string]any          `yaml:"proxies"`
215: 	ProxyGroup    []map[string]any          `yaml:"proxy-groups"`
216: 	Rule          []string                  `yaml:"rules"`
217: }
218: 
219: // Parse config
220: func Parse(buf []byte) (*Config, error) {
221: 	rawCfg, err := UnmarshalRawConfig(buf)
222: 	if err != nil {
223: 		return nil, err
224: 	}
225: 
226: 	return ParseRawConfig(rawCfg)
227: }
228: 
229: func UnmarshalRawConfig(buf []byte) (*RawConfig, error) {
230: 	// config with default value
231: 	rawCfg := &RawConfig{
232: 		AllowLan:       false,
233: 		BindAddress:    "*",
234: 		Mode:           T.Rule,
235: 		Authentication: []string{},
236: 		LogLevel:       log.INFO,
237: 		Hosts:          map[string]string{},
238: 		Rule:           []string{},
239: 		Proxy:          []map[string]any{},
240: 		ProxyGroup:     []map[string]any{},
241: 		DNS: RawDNS{
242: 			Enable:      false,
243: 			UseHosts:    true,
244: 			FakeIPRange: "198.18.0.1/16",
245: 			FallbackFilter: RawFallbackFilter{
246: 				GeoIP:     true,
247: 				GeoIPCode: "CN",
248: 				IPCIDR:    []string{},
249: 			},
250: 			DefaultNameserver: []string{
251: 				"114.114.114.114",
252: 				"8.8.8.8",
253: 			},
254: 		},
255: 		Profile: Profile{
256: 			StoreSelected: true,
257: 		},
258: 	}
259: 
260: 	if err := yaml.Unmarshal(buf, rawCfg); err != nil {
261: 		return nil, err
262: 	}
263: 
264: 	return rawCfg, nil
265: }
266: 
267: func ParseRawConfig(rawCfg *RawConfig) (*Config, error) {
268: 	config := &Config{}
269: 
270: 	config.Experimental = &rawCfg.Experimental
271: 	config.Profile = &rawCfg.Profile
272: 
273: 	general, err := parseGeneral(rawCfg)
274: 	if err != nil {
275: 		return nil, err
276: 	}
277: 	config.General = general
278: 
279: 	config.Inbounds = rawCfg.Inbounds
280: 
281: 	proxies, providers, err := parseProxies(rawCfg)
282: 	if err != nil {
283: 		return nil, err
284: 	}
285: 	config.Proxies = proxies
286: 	config.Providers = providers
287: 
288: 	rules, err := parseRules(rawCfg, proxies)
289: 	if err != nil {
290: 		return nil, err
291: 	}
292: 	config.Rules = rules
293: 
294: 	hosts, err := parseHosts(rawCfg)
295: 	if err != nil {
296: 		return nil, err
297: 	}
298: 	config.Hosts = hosts
299: 
300: 	dnsCfg, err := parseDNS(rawCfg, hosts)
301: 	if err != nil {
302: 		return nil, err
303: 	}
304: 	config.DNS = dnsCfg
305: 
306: 	config.Users = parseAuthentication(rawCfg.Authentication)
307: 
308: 	config.Tunnels = rawCfg.Tunnels
309: 	// verify tunnels
310: 	for _, t := range config.Tunnels {
311: 		if _, ok := config.Proxies[t.Proxy]; !ok {
312: 			return nil, fmt.Errorf("tunnel proxy %s not found", t.Proxy)
313: 		}
314: 	}
315: 
316: 	return config, nil
317: }
318: 
319: func parseGeneral(cfg *RawConfig) (*General, error) {
320: 	externalUI := cfg.ExternalUI
321: 
322: 	// checkout externalUI exist
323: 	if externalUI != "" {
324: 		externalUI = C.Path.Resolve(externalUI)
325: 
326: 		if _, err := os.Stat(externalUI); os.IsNotExist(err) {
327: 			return nil, fmt.Errorf("external-ui: %s not exist", externalUI)
328: 		}
329: 	}
330: 
331: 	return &General{
332: 		LegacyInbound: LegacyInbound{
333: 			Port:        cfg.Port,
334: 			SocksPort:   cfg.SocksPort,
335: 			RedirPort:   cfg.RedirPort,
336: 			TProxyPort:  cfg.TProxyPort,
337: 			MixedPort:   cfg.MixedPort,
338: 			AllowLan:    cfg.AllowLan,
339: 			BindAddress: cfg.BindAddress,
340: 		},
341: 		Controller: Controller{
342: 			ExternalController: cfg.ExternalController,
343: 			ExternalUI:         cfg.ExternalUI,
344: 			Secret:             cfg.Secret,
345: 		},
346: 		Mode:        cfg.Mode,
347: 		LogLevel:    cfg.LogLevel,
348: 		IPv6:        cfg.IPv6,
349: 		Interface:   cfg.Interface,
350: 		RoutingMark: cfg.RoutingMark,
351: 	}, nil
352: }
353: 
354: func parseProxies(cfg *RawConfig) (proxies map[string]C.Proxy, providersMap map[string]providerTypes.ProxyProvider, err error) {
355: 	proxies = make(map[string]C.Proxy)
356: 	providersMap = make(map[string]providerTypes.ProxyProvider)
357: 	proxyList := []string{}
358: 	proxiesConfig := cfg.Proxy
359: 	groupsConfig := cfg.ProxyGroup
360: 	providersConfig := cfg.ProxyProvider
361: 
362: 	proxies["DIRECT"] = adapter.NewProxy(outbound.NewDirect())
363: 	proxies["REJECT"] = adapter.NewProxy(outbound.NewReject())
364: 	proxyList = append(proxyList, "DIRECT", "REJECT")
365: 
366: 	// parse proxy
367: 	for idx, mapping := range proxiesConfig {
368: 		proxy, err := adapter.ParseProxy(mapping)
369: 		if err != nil {
370: 			return nil, nil, fmt.Errorf("proxy %d: %w", idx, err)
371: 		}
372: 
373: 		if _, exist := proxies[proxy.Name()]; exist {
374: 			return nil, nil, fmt.Errorf("proxy %s is the duplicate name", proxy.Name())
375: 		}
376: 		proxies[proxy.Name()] = proxy
377: 		proxyList = append(proxyList, proxy.Name())
378: 	}
379: 
380: 	// keep the original order of ProxyGroups in config file
381: 	for idx, mapping := range groupsConfig {
382: 		groupName, existName := mapping["name"].(string)
383: 		if !existName {
384: 			return nil, nil, fmt.Errorf("proxy group %d: missing name", idx)
385: 		}
386: 		proxyList = append(proxyList, groupName)
387: 	}
388: 
389: 	// check if any loop exists and sort the ProxyGroups
390: 	if err := proxyGroupsDagSort(groupsConfig); err != nil {
391: 		return nil, nil, err
392: 	}
393: 
394: 	// parse and initial providers
395: 	for name, mapping := range providersConfig {
396: 		if name == provider.ReservedName {
397: 			return nil, nil, fmt.Errorf("can not defined a provider called `%s`", provider.ReservedName)
398: 		}
399: 
400: 		pd, err := provider.ParseProxyProvider(name, mapping)
401: 		if err != nil {
402: 			return nil, nil, fmt.Errorf("parse proxy provider %s error: %w", name, err)
403: 		}
404: 
405: 		providersMap[name] = pd
406: 	}
407: 
408: 	for _, provider := range providersMap {
409: 		log.Infoln("Start initial provider %s", provider.Name())
410: 		if err := provider.Initial(); err != nil {
411: 			return nil, nil, fmt.Errorf("initial proxy provider %s error: %w", provider.Name(), err)
412: 		}
413: 	}
414: 
415: 	// parse proxy group
416: 	for idx, mapping := range groupsConfig {
417: 		group, err := outboundgroup.ParseProxyGroup(mapping, proxies, providersMap)
418: 		if err != nil {
419: 			return nil, nil, fmt.Errorf("proxy group[%d]: %w", idx, err)
420: 		}
421: 
422: 		groupName := group.Name()
423: 		if _, exist := proxies[groupName]; exist {
424: 			return nil, nil, fmt.Errorf("proxy group %s: the duplicate name", groupName)
425: 		}
426: 
427: 		proxies[groupName] = adapter.NewProxy(group)
428: 	}
429: 
430: 	// initial compatible provider
431: 	for _, pd := range providersMap {
432: 		if pd.VehicleType() != providerTypes.Compatible {
433: 			continue
434: 		}
435: 
436: 		log.Infoln("Start initial compatible provider %s", pd.Name())
437: 		if err := pd.Initial(); err != nil {
438: 			return nil, nil, err
439: 		}
440: 	}
441: 
442: 	ps := []C.Proxy{}
443: 	for _, v := range proxyList {
444: 		ps = append(ps, proxies[v])
445: 	}
446: 	hc := provider.NewHealthCheck(ps, "", 0, true)
447: 	pd, _ := provider.NewCompatibleProvider(provider.ReservedName, ps, hc)
448: 	providersMap[provider.ReservedName] = pd
449: 
450: 	global := outboundgroup.NewSelector(
451: 		&outboundgroup.GroupCommonOption{
452: 			Name: "GLOBAL",
453: 		},
454: 		[]providerTypes.ProxyProvider{pd},
455: 	)
456: 	proxies["GLOBAL"] = adapter.NewProxy(global)
457: 	return proxies, providersMap, nil
458: }
459: 
460: func parseRules(cfg *RawConfig, proxies map[string]C.Proxy) ([]C.Rule, error) {
461: 	rules := []C.Rule{}
462: 	rulesConfig := cfg.Rule
463: 
464: 	// parse rules
465: 	for idx, line := range rulesConfig {
466: 		rule := trimArr(strings.Split(line, ","))
467: 		var (
468: 			payload string
469: 			target  string
470: 			params  = []string{}
471: 		)
472: 
473: 		switch l := len(rule); {
474: 		case l == 2:
475: 			target = rule[1]
476: 		case l == 3:
477: 			payload = rule[1]
478: 			target = rule[2]
479: 		case l >= 4:
480: 			payload = rule[1]
481: 			target = rule[2]
482: 			params = rule[3:]
483: 		default:
484: 			return nil, fmt.Errorf("rules[%d] [%s] error: format invalid", idx, line)
485: 		}
486: 
487: 		if _, ok := proxies[target]; !ok {
488: 			return nil, fmt.Errorf("rules[%d] [%s] error: proxy [%s] not found", idx, line, target)
489: 		}
490: 
491: 		rule = trimArr(rule)
492: 		params = trimArr(params)
493: 
494: 		parsed, parseErr := R.ParseRule(rule[0], payload, target, params)
495: 		if parseErr != nil {
496: 			return nil, fmt.Errorf("rules[%d] [%s] error: %s", idx, line, parseErr.Error())
497: 		}
498: 
499: 		rules = append(rules, parsed)
500: 	}
501: 
502: 	return rules, nil
503: }
504: 
505: func parseHosts(cfg *RawConfig) (*trie.DomainTrie, error) {
506: 	tree := trie.New()
507: 
508: 	// add default hosts
509: 	if err := tree.Insert("localhost", net.IP{127, 0, 0, 1}); err != nil {
510: 		log.Errorln("insert localhost to host error: %s", err.Error())
511: 	}
512: 
513: 	if len(cfg.Hosts) != 0 {
514: 		for domain, ipStr := range cfg.Hosts {
515: 			ip := net.ParseIP(ipStr)
516: 			if ip == nil {
517: 				return nil, fmt.Errorf("%s is not a valid IP", ipStr)
518: 			}
519: 			tree.Insert(domain, ip)
520: 		}
521: 	}
522: 
523: 	return tree, nil
524: }
525: 
526: func hostWithDefaultPort(host string, defPort string) (string, error) {
527: 	if !strings.Contains(host, ":") {
528: 		host += ":"
529: 	}
530: 
531: 	hostname, port, err := net.SplitHostPort(host)
532: 	if err != nil {
533: 		return "", err
534: 	}
535: 
536: 	if port == "" {
537: 		port = defPort
538: 	}
539: 
540: 	return net.JoinHostPort(hostname, port), nil
541: }
542: 
543: func parseNameServer(servers []string) ([]dns.NameServer, error) {
544: 	nameservers := []dns.NameServer{}
545: 
546: 	for idx, server := range servers {
547: 		// parse without scheme .e.g 8.8.8.8:53
548: 		if !strings.Contains(server, "://") {
549: 			server = "udp://" + server
550: 		}
551: 		u, err := url.Parse(server)
552: 		if err != nil {
553: 			return nil, fmt.Errorf("DNS NameServer[%d] format error: %s", idx, err.Error())
554: 		}
555: 
556: 		// parse with specific interface
557: 		// .e.g 10.0.0.1#en0
558: 		interfaceName := u.Fragment
559: 
560: 		var addr, dnsNetType string
561: 		switch u.Scheme {
562: 		case "udp":
563: 			addr, err = hostWithDefaultPort(u.Host, "53")
564: 			dnsNetType = "" // UDP
565: 		case "tcp":
566: 			addr, err = hostWithDefaultPort(u.Host, "53")
567: 			dnsNetType = "tcp" // TCP
568: 		case "tls":
569: 			addr, err = hostWithDefaultPort(u.Host, "853")
570: 			dnsNetType = "tcp-tls" // DNS over TLS
571: 		case "https":
572: 			clearURL := url.URL{Scheme: "https", Host: u.Host, Path: u.Path, User: u.User}
573: 			addr = clearURL.String()
574: 			dnsNetType = "https" // DNS over HTTPS
575: 		case "dhcp":
576: 			addr = u.Host
577: 			dnsNetType = "dhcp" // UDP from DHCP
578: 		default:
579: 			return nil, fmt.Errorf("DNS NameServer[%d] unsupport scheme: %s", idx, u.Scheme)
580: 		}
581: 
582: 		if err != nil {
583: 			return nil, fmt.Errorf("DNS NameServer[%d] format error: %s", idx, err.Error())
584: 		}
585: 
586: 		nameservers = append(
587: 			nameservers,
588: 			dns.NameServer{
589: 				Net:       dnsNetType,
590: 				Addr:      addr,
591: 				Interface: interfaceName,
592: 			},
593: 		)
594: 	}
595: 	return nameservers, nil
596: }
597: 
598: func parseNameServerPolicy(nsPolicy map[string]string) (map[string]dns.NameServer, error) {
599: 	policy := map[string]dns.NameServer{}
600: 
601: 	for domain, server := range nsPolicy {
602: 		nameservers, err := parseNameServer([]string{server})
603: 		if err != nil {
604: 			return nil, err
605: 		}
606: 		if _, valid := trie.ValidAndSplitDomain(domain); !valid {
607: 			return nil, fmt.Errorf("DNS ResoverRule invalid domain: %s", domain)
608: 		}
609: 		policy[domain] = nameservers[0]
610: 	}
611: 
612: 	return policy, nil
613: }
614: 
615: func parseFallbackIPCIDR(ips []string) ([]*net.IPNet, error) {
616: 	ipNets := []*net.IPNet{}
617: 
618: 	for idx, ip := range ips {
619: 		_, ipnet, err := net.ParseCIDR(ip)
620: 		if err != nil {
621: 			return nil, fmt.Errorf("DNS FallbackIP[%d] format error: %s", idx, err.Error())
622: 		}
623: 		ipNets = append(ipNets, ipnet)
624: 	}
625: 
626: 	return ipNets, nil
627: }
628: 
629: func parseDNS(rawCfg *RawConfig, hosts *trie.DomainTrie) (*DNS, error) {
630: 	cfg := rawCfg.DNS
631: 	if cfg.Enable && len(cfg.NameServer) == 0 {
632: 		return nil, fmt.Errorf("if DNS configuration is turned on, NameServer cannot be empty")
633: 	}
634: 
635: 	dnsCfg := &DNS{
636: 		Enable:       cfg.Enable,
637: 		Listen:       cfg.Listen,
638: 		IPv6:         lo.FromPtrOr(cfg.IPv6, rawCfg.IPv6),
639: 		EnhancedMode: cfg.EnhancedMode,
640: 		FallbackFilter: FallbackFilter{
641: 			IPCIDR: []*net.IPNet{},
642: 		},
643: 	}
644: 	var err error
645: 	if dnsCfg.NameServer, err = parseNameServer(cfg.NameServer); err != nil {
646: 		return nil, err
647: 	}
648: 
649: 	if dnsCfg.Fallback, err = parseNameServer(cfg.Fallback); err != nil {
650: 		return nil, err
651: 	}
652: 
653: 	if dnsCfg.NameServerPolicy, err = parseNameServerPolicy(cfg.NameServerPolicy); err != nil {
654: 		return nil, err
655: 	}
656: 
657: 	if len(cfg.DefaultNameserver) == 0 {
658: 		return nil, errors.New("default nameserver should have at least one nameserver")
659: 	}
660: 	if dnsCfg.DefaultNameserver, err = parseNameServer(cfg.DefaultNameserver); err != nil {
661: 		return nil, err
662: 	}
663: 	// check default nameserver is pure ip addr
664: 	for _, ns := range dnsCfg.DefaultNameserver {
665: 		host, _, err := net.SplitHostPort(ns.Addr)
666: 		if err != nil || net.ParseIP(host) == nil {
667: 			return nil, errors.New("default nameserver should be pure IP")
668: 		}
669: 	}
670: 
671: 	if cfg.EnhancedMode == C.DNSFakeIP {
672: 		_, ipnet, err := net.ParseCIDR(cfg.FakeIPRange)
673: 		if err != nil {
674: 			return nil, err
675: 		}
676: 
677: 		var host *trie.DomainTrie
678: 		// fake ip skip host filter
679: 		if len(cfg.FakeIPFilter) != 0 {
680: 			host = trie.New()
681: 			for _, domain := range cfg.FakeIPFilter {
682: 				host.Insert(domain, true)
683: 			}
684: 		}
685: 
686: 		pool, err := fakeip.New(fakeip.Options{
687: 			IPNet:       ipnet,
688: 			Size:        1000,
689: 			Host:        host,
690: 			Persistence: rawCfg.Profile.StoreFakeIP,
691: 		})
692: 		if err != nil {
693: 			return nil, err
694: 		}
695: 
696: 		dnsCfg.FakeIPRange = pool
697: 	}
698: 
699: 	dnsCfg.FallbackFilter.GeoIP = cfg.FallbackFilter.GeoIP
700: 	dnsCfg.FallbackFilter.GeoIPCode = cfg.FallbackFilter.GeoIPCode
701: 	if fallbackip, err := parseFallbackIPCIDR(cfg.FallbackFilter.IPCIDR); err == nil {
702: 		dnsCfg.FallbackFilter.IPCIDR = fallbackip
703: 	}
704: 	dnsCfg.FallbackFilter.Domain = cfg.FallbackFilter.Domain
705: 
706: 	if cfg.UseHosts {
707: 		dnsCfg.Hosts = hosts
708: 	}
709: 
710: 	if len(cfg.SearchDomains) != 0 {
711: 		for _, domain := range cfg.SearchDomains {
712: 			if strings.HasPrefix(domain, ".") || strings.HasSuffix(domain, ".") {
713: 				return nil, errors.New("search domains should not start or end with '.'")
714: 			}
715: 			if strings.Contains(domain, ":") {
716: 				return nil, errors.New("search domains are for ipv4 only and should not contain ports")
717: 			}
718: 		}
719: 		dnsCfg.SearchDomains = cfg.SearchDomains
720: 	}
721: 
722: 	return dnsCfg, nil
723: }
724: 
725: func parseAuthentication(rawRecords []string) []auth.AuthUser {
726: 	users := []auth.AuthUser{}
727: 	for _, line := range rawRecords {
728: 		if user, pass, found := strings.Cut(line, ":"); found {
729: 			users = append(users, auth.AuthUser{User: user, Pass: pass})
730: 		}
731: 	}
732: 	return users
733: }


./config\initial.go
1: package config
2: 
3: import (
4: 	"fmt"
5: 	"io"
6: 	"net/http"
7: 	"os"
8: 
9: 	"github.com/Dreamacro/clash/component/mmdb"
10: 	C "github.com/Dreamacro/clash/constant"
11: 	"github.com/Dreamacro/clash/log"
12: )
13: 
14: func downloadMMDB(path string) (err error) {
15: 	resp, err := http.Get("https://cdn.jsdelivr.net/gh/Dreamacro/maxmind-geoip@release/Country.mmdb")
16: 	if err != nil {
17: 		return
18: 	}
19: 	defer resp.Body.Close()
20: 
21: 	f, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, 0o644)
22: 	if err != nil {
23: 		return err
24: 	}
25: 	defer f.Close()
26: 	_, err = io.Copy(f, resp.Body)
27: 
28: 	return err
29: }
30: 
31: func initMMDB() error {
32: 	if _, err := os.Stat(C.Path.MMDB()); os.IsNotExist(err) {
33: 		log.Infoln("Can't find MMDB, start download")
34: 		if err := downloadMMDB(C.Path.MMDB()); err != nil {
35: 			return fmt.Errorf("can't download MMDB: %s", err.Error())
36: 		}
37: 	}
38: 
39: 	if !mmdb.Verify() {
40: 		log.Warnln("MMDB invalid, remove and download")
41: 		if err := os.Remove(C.Path.MMDB()); err != nil {
42: 			return fmt.Errorf("can't remove invalid MMDB: %s", err.Error())
43: 		}
44: 
45: 		if err := downloadMMDB(C.Path.MMDB()); err != nil {
46: 			return fmt.Errorf("can't download MMDB: %s", err.Error())
47: 		}
48: 	}
49: 
50: 	return nil
51: }
52: 
53: // Init prepare necessary files
54: func Init(dir string) error {
55: 	// initial homedir
56: 	if _, err := os.Stat(dir); os.IsNotExist(err) {
57: 		if err := os.MkdirAll(dir, 0o777); err != nil {
58: 			return fmt.Errorf("can't create config directory %s: %s", dir, err.Error())
59: 		}
60: 	}
61: 
62: 	// initial config.yaml
63: 	if _, err := os.Stat(C.Path.Config()); os.IsNotExist(err) {
64: 		log.Infoln("Can't find config, create a initial config file")
65: 		f, err := os.OpenFile(C.Path.Config(), os.O_CREATE|os.O_WRONLY, 0o644)
66: 		if err != nil {
67: 			return fmt.Errorf("can't create file %s: %s", C.Path.Config(), err.Error())
68: 		}
69: 		f.Write([]byte(`mixed-port: 7890`))
70: 		f.Close()
71: 	}
72: 
73: 	// initial mmdb
74: 	if err := initMMDB(); err != nil {
75: 		return fmt.Errorf("can't initial MMDB: %w", err)
76: 	}
77: 	return nil
78: }


./config\utils.go
1: package config
2: 
3: import (
4: 	"fmt"
5: 	"strings"
6: 
7: 	"github.com/Dreamacro/clash/adapter/outboundgroup"
8: 	"github.com/Dreamacro/clash/common/structure"
9: )
10: 
11: func trimArr(arr []string) (r []string) {
12: 	for _, e := range arr {
13: 		r = append(r, strings.Trim(e, " "))
14: 	}
15: 	return
16: }
17: 
18: // Check if ProxyGroups form DAG(Directed Acyclic Graph), and sort all ProxyGroups by dependency order.
19: // Meanwhile, record the original index in the config file.
20: // If loop is detected, return an error with location of loop.
21: func proxyGroupsDagSort(groupsConfig []map[string]any) error {
22: 	type graphNode struct {
23: 		indegree int
24: 		// topological order
25: 		topo int
26: 		// the original data in `groupsConfig`
27: 		data map[string]any
28: 		// `outdegree` and `from` are used in loop locating
29: 		outdegree int
30: 		option    *outboundgroup.GroupCommonOption
31: 		from      []string
32: 	}
33: 
34: 	decoder := structure.NewDecoder(structure.Option{TagName: "group", WeaklyTypedInput: true})
35: 	graph := make(map[string]*graphNode)
36: 
37: 	// Step 1.1 build dependency graph
38: 	for _, mapping := range groupsConfig {
39: 		option := &outboundgroup.GroupCommonOption{}
40: 		if err := decoder.Decode(mapping, option); err != nil {
41: 			return fmt.Errorf("ProxyGroup %s: %s", option.Name, err.Error())
42: 		}
43: 
44: 		groupName := option.Name
45: 		if node, ok := graph[groupName]; ok {
46: 			if node.data != nil {
47: 				return fmt.Errorf("ProxyGroup %s: duplicate group name", groupName)
48: 			}
49: 			node.data = mapping
50: 			node.option = option
51: 		} else {
52: 			graph[groupName] = &graphNode{0, -1, mapping, 0, option, nil}
53: 		}
54: 
55: 		for _, proxy := range option.Proxies {
56: 			if node, ex := graph[proxy]; ex {
57: 				node.indegree++
58: 			} else {
59: 				graph[proxy] = &graphNode{1, -1, nil, 0, nil, nil}
60: 			}
61: 		}
62: 	}
63: 	// Step 1.2 Topological Sort
64: 	// topological index of **ProxyGroup**
65: 	index := 0
66: 	queue := make([]string, 0)
67: 	for name, node := range graph {
68: 		// in the beginning, put nodes that have `node.indegree == 0` into queue.
69: 		if node.indegree == 0 {
70: 			queue = append(queue, name)
71: 		}
72: 	}
73: 	// every element in queue have indegree == 0
74: 	for ; len(queue) > 0; queue = queue[1:] {
75: 		name := queue[0]
76: 		node := graph[name]
77: 		if node.option != nil {
78: 			index++
79: 			groupsConfig[len(groupsConfig)-index] = node.data
80: 			if len(node.option.Proxies) == 0 {
81: 				delete(graph, name)
82: 				continue
83: 			}
84: 
85: 			for _, proxy := range node.option.Proxies {
86: 				child := graph[proxy]
87: 				child.indegree--
88: 				if child.indegree == 0 {
89: 					queue = append(queue, proxy)
90: 				}
91: 			}
92: 		}
93: 		delete(graph, name)
94: 	}
95: 
96: 	// no loop is detected, return sorted ProxyGroup
97: 	if len(graph) == 0 {
98: 		return nil
99: 	}
100: 
101: 	// if loop is detected, locate the loop and throw an error
102: 	// Step 2.1 rebuild the graph, fill `outdegree` and `from` filed
103: 	for name, node := range graph {
104: 		if node.option == nil {
105: 			continue
106: 		}
107: 
108: 		if len(node.option.Proxies) == 0 {
109: 			continue
110: 		}
111: 
112: 		for _, proxy := range node.option.Proxies {
113: 			node.outdegree++
114: 			child := graph[proxy]
115: 			if child.from == nil {
116: 				child.from = make([]string, 0, child.indegree)
117: 			}
118: 			child.from = append(child.from, name)
119: 		}
120: 	}
121: 	// Step 2.2 remove nodes outside the loop. so that we have only the loops remain in `graph`
122: 	queue = make([]string, 0)
123: 	// initialize queue with node have outdegree == 0
124: 	for name, node := range graph {
125: 		if node.outdegree == 0 {
126: 			queue = append(queue, name)
127: 		}
128: 	}
129: 	// every element in queue have outdegree == 0
130: 	for ; len(queue) > 0; queue = queue[1:] {
131: 		name := queue[0]
132: 		node := graph[name]
133: 		for _, f := range node.from {
134: 			graph[f].outdegree--
135: 			if graph[f].outdegree == 0 {
136: 				queue = append(queue, f)
137: 			}
138: 		}
139: 		delete(graph, name)
140: 	}
141: 	// Step 2.3 report the elements in loop
142: 	loopElements := make([]string, 0, len(graph))
143: 	for name := range graph {
144: 		loopElements = append(loopElements, name)
145: 		delete(graph, name)
146: 	}
147: 	return fmt.Errorf("loop is detected in ProxyGroup, please check following ProxyGroups: %v", loopElements)
148: }


./constant\adapters.go
1: package constant
2: 
3: import (
4: 	"context"
5: 	"fmt"
6: 	"net"
7: 	"time"
8: 
9: 	"github.com/Dreamacro/clash/component/dialer"
10: )
11: 
12: // Adapter Type
13: const (
14: 	Direct AdapterType = iota
15: 	Reject
16: 
17: 	Shadowsocks
18: 	ShadowsocksR
19: 	Snell
20: 	Socks5
21: 	Http
22: 	Vless
23: 	Vmess
24: 	Trojan
25: 
26: 	Relay
27: 	Selector
28: 	Fallback
29: 	URLTest
30: 	LoadBalance
31: )
32: 
33: const (
34: 	DefaultTCPTimeout = 5 * time.Second
35: 	DefaultUDPTimeout = DefaultTCPTimeout
36: 	DefaultTLSTimeout = DefaultTCPTimeout
37: )
38: 
39: type Connection interface {
40: 	Chains() Chain
41: 	AppendToChains(adapter ProxyAdapter)
42: }
43: 
44: type Chain []string
45: 
46: func (c Chain) String() string {
47: 	switch len(c) {
48: 	case 0:
49: 		return ""
50: 	case 1:
51: 		return c[0]
52: 	default:
53: 		return fmt.Sprintf("%s[%s]", c[len(c)-1], c[0])
54: 	}
55: }
56: 
57: func (c Chain) Last() string {
58: 	switch len(c) {
59: 	case 0:
60: 		return ""
61: 	default:
62: 		return c[0]
63: 	}
64: }
65: 
66: type Conn interface {
67: 	net.Conn
68: 	Connection
69: }
70: 
71: type PacketConn interface {
72: 	net.PacketConn
73: 	Connection
74: 	// Deprecate WriteWithMetadata because of remote resolve DNS cause TURN failed
75: 	// WriteWithMetadata(p []byte, metadata *Metadata) (n int, err error)
76: }
77: 
78: type ProxyAdapter interface {
79: 	Name() string
80: 	Type() AdapterType
81: 	Addr() string
82: 	SupportUDP() bool
83: 	MarshalJSON() ([]byte, error)
84: 
85: 	// StreamConn wraps a protocol around net.Conn with Metadata.
86: 	//
87: 	// Examples:
88: 	//	conn, _ := net.DialContext(context.Background(), "tcp", "host:port")
89: 	//	conn, _ = adapter.StreamConn(conn, metadata)
90: 	//
91: 	// It returns a C.Conn with protocol which start with
92: 	// a new session (if any)
93: 	StreamConn(c net.Conn, metadata *Metadata) (net.Conn, error)
94: 
95: 	// DialContext return a C.Conn with protocol which
96: 	// contains multiplexing-related reuse logic (if any)
97: 	DialContext(ctx context.Context, metadata *Metadata, opts ...dialer.Option) (Conn, error)
98: 	ListenPacketContext(ctx context.Context, metadata *Metadata, opts ...dialer.Option) (PacketConn, error)
99: 
100: 	// Unwrap extracts the proxy from a proxy-group. It returns nil when nothing to extract.
101: 	Unwrap(metadata *Metadata) Proxy
102: }
103: 
104: type DelayHistory struct {
105: 	Time      time.Time `json:"time"`
106: 	Delay     uint16    `json:"delay"`
107: 	MeanDelay uint16    `json:"meanDelay"`
108: }
109: 
110: type Proxy interface {
111: 	ProxyAdapter
112: 	Alive() bool
113: 	DelayHistory() []DelayHistory
114: 	LastDelay() uint16
115: 	URLTest(ctx context.Context, url string) (uint16, uint16, error)
116: 
117: 	// Deprecated: use DialContext instead.
118: 	Dial(metadata *Metadata) (Conn, error)
119: 
120: 	// Deprecated: use DialPacketConn instead.
121: 	DialUDP(metadata *Metadata) (PacketConn, error)
122: }
123: 
124: // AdapterType is enum of adapter type
125: type AdapterType int
126: 
127: func (at AdapterType) String() string {
128: 	switch at {
129: 	case Direct:
130: 		return "Direct"
131: 	case Reject:
132: 		return "Reject"
133: 
134: 	case Shadowsocks:
135: 		return "Shadowsocks"
136: 	case ShadowsocksR:
137: 		return "ShadowsocksR"
138: 	case Snell:
139: 		return "Snell"
140: 	case Socks5:
141: 		return "Socks5"
142: 	case Http:
143: 		return "Http"
144: 	case Vless:
145: 		return "Vless"
146: 	case Vmess:
147: 		return "Vmess"
148: 	case Trojan:
149: 		return "Trojan"
150: 
151: 	case Relay:
152: 		return "Relay"
153: 	case Selector:
154: 		return "Selector"
155: 	case Fallback:
156: 		return "Fallback"
157: 	case URLTest:
158: 		return "URLTest"
159: 	case LoadBalance:
160: 		return "LoadBalance"
161: 
162: 	default:
163: 		return "Unknown"
164: 	}
165: }
166: 
167: // UDPPacket contains the data of UDP packet, and offers control/info of UDP packet's source
168: type UDPPacket interface {
169: 	// Data get the payload of UDP Packet
170: 	Data() []byte
171: 
172: 	// WriteBack writes the payload with source IP/Port equals addr
173: 	// - variable source IP/Port is important to STUN
174: 	// - if addr is not provided, WriteBack will write out UDP packet with SourceIP/Port equals to original Target,
175: 	//   this is important when using Fake-IP.
176: 	WriteBack(b []byte, addr net.Addr) (n int, err error)
177: 
178: 	// Drop call after packet is used, could recycle buffer in this function.
179: 	Drop()
180: 
181: 	// LocalAddr returns the source IP/Port of packet
182: 	LocalAddr() net.Addr
183: }


./constant\context.go
1: package constant
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/gofrs/uuid/v5"
7: )
8: 
9: type PlainContext interface {
10: 	ID() uuid.UUID
11: }
12: 
13: type ConnContext interface {
14: 	PlainContext
15: 	Metadata() *Metadata
16: 	Conn() net.Conn
17: }
18: 
19: type PacketConnContext interface {
20: 	PlainContext
21: 	Metadata() *Metadata
22: 	PacketConn() net.PacketConn
23: }


./constant\dns.go
1: package constant
2: 
3: import (
4: 	"encoding/json"
5: 	"errors"
6: 	"fmt"
7: )
8: 
9: // DNSModeMapping is a mapping for EnhancedMode enum
10: var DNSModeMapping = map[string]DNSMode{
11: 	DNSNormal.String(): DNSNormal,
12: 	DNSFakeIP.String(): DNSFakeIP,
13: }
14: 
15: const (
16: 	DNSNormal DNSMode = iota
17: 	DNSFakeIP
18: 	DNSMapping
19: )
20: 
21: type DNSMode int
22: 
23: // UnmarshalYAML unserialize EnhancedMode with yaml
24: func (e *DNSMode) UnmarshalYAML(unmarshal func(any) error) error {
25: 	var tp string
26: 	if err := unmarshal(&tp); err != nil {
27: 		return err
28: 	}
29: 	mode, exist := DNSModeMapping[tp]
30: 	if !exist {
31: 		return fmt.Errorf("invalid mode: %s", tp)
32: 	}
33: 	*e = mode
34: 	return nil
35: }
36: 
37: // MarshalYAML serialize EnhancedMode with yaml
38: func (e DNSMode) MarshalYAML() (any, error) {
39: 	return e.String(), nil
40: }
41: 
42: // UnmarshalJSON unserialize EnhancedMode with json
43: func (e *DNSMode) UnmarshalJSON(data []byte) error {
44: 	var tp string
45: 	json.Unmarshal(data, &tp)
46: 	mode, exist := DNSModeMapping[tp]
47: 	if !exist {
48: 		return errors.New("invalid mode")
49: 	}
50: 	*e = mode
51: 	return nil
52: }
53: 
54: // MarshalJSON serialize EnhancedMode with json
55: func (e DNSMode) MarshalJSON() ([]byte, error) {
56: 	return json.Marshal(e.String())
57: }
58: 
59: func (e DNSMode) String() string {
60: 	switch e {
61: 	case DNSNormal:
62: 		return "normal"
63: 	case DNSFakeIP:
64: 		return "fake-ip"
65: 	case DNSMapping:
66: 		return "redir-host"
67: 	default:
68: 		return "unknown"
69: 	}
70: }


./constant\listener.go
1: package constant
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 	"net/url"
7: 	"strconv"
8: )
9: 
10: type Listener interface {
11: 	RawAddress() string
12: 	Address() string
13: 	Close() error
14: }
15: 
16: type InboundType string
17: 
18: const (
19: 	InboundTypeSocks  InboundType = "socks"
20: 	InboundTypeRedir  InboundType = "redir"
21: 	InboundTypeTproxy InboundType = "tproxy"
22: 	InboundTypeHTTP   InboundType = "http"
23: 	InboundTypeMixed  InboundType = "mixed"
24: )
25: 
26: var supportInboundTypes = map[InboundType]bool{
27: 	InboundTypeSocks:  true,
28: 	InboundTypeRedir:  true,
29: 	InboundTypeTproxy: true,
30: 	InboundTypeHTTP:   true,
31: 	InboundTypeMixed:  true,
32: }
33: 
34: type inbound struct {
35: 	Type          InboundType `json:"type" yaml:"type"`
36: 	BindAddress   string      `json:"bind-address" yaml:"bind-address"`
37: 	IsFromPortCfg bool        `json:"-" yaml:"-"`
38: }
39: 
40: // Inbound
41: type Inbound inbound
42: 
43: // UnmarshalYAML implements yaml.Unmarshaler
44: func (i *Inbound) UnmarshalYAML(unmarshal func(any) error) error {
45: 	var tp string
46: 	if err := unmarshal(&tp); err != nil {
47: 		var inner inbound
48: 		if err := unmarshal(&inner); err != nil {
49: 			return err
50: 		}
51: 
52: 		*i = Inbound(inner)
53: 	} else {
54: 		inner, err := parseInbound(tp)
55: 		if err != nil {
56: 			return err
57: 		}
58: 
59: 		*i = Inbound(*inner)
60: 	}
61: 
62: 	if !supportInboundTypes[i.Type] {
63: 		return fmt.Errorf("not support inbound type: %s", i.Type)
64: 	}
65: 	_, portStr, err := net.SplitHostPort(i.BindAddress)
66: 	if err != nil {
67: 		return fmt.Errorf("bind address parse error. addr: %s, err: %w", i.BindAddress, err)
68: 	}
69: 	port, err := strconv.ParseUint(portStr, 10, 16)
70: 	if err != nil || port == 0 {
71: 		return fmt.Errorf("invalid bind port. addr: %s", i.BindAddress)
72: 	}
73: 	return nil
74: }
75: 
76: func parseInbound(alias string) (*inbound, error) {
77: 	u, err := url.Parse(alias)
78: 	if err != nil {
79: 		return nil, err
80: 	}
81: 	listenerType := InboundType(u.Scheme)
82: 	return &inbound{
83: 		Type:        listenerType,
84: 		BindAddress: u.Host,
85: 	}, nil
86: }
87: 
88: func (i *Inbound) ToAlias() string {
89: 	return string(i.Type) + "://" + i.BindAddress
90: }


./constant\metadata.go
1: package constant
2: 
3: import (
4: 	"encoding/json"
5: 	"net"
6: 	"net/netip"
7: 	"strconv"
8: 
9: 	"github.com/Dreamacro/clash/transport/socks5"
10: )
11: 
12: // Socks addr type
13: const (
14: 	TCP NetWork = iota
15: 	UDP
16: 
17: 	HTTP Type = iota
18: 	HTTPCONNECT
19: 	SOCKS4
20: 	SOCKS5
21: 	REDIR
22: 	TPROXY
23: 	TUNNEL
24: )
25: 
26: type NetWork int
27: 
28: func (n NetWork) String() string {
29: 	if n == TCP {
30: 		return "tcp"
31: 	}
32: 	return "udp"
33: }
34: 
35: func (n NetWork) MarshalJSON() ([]byte, error) {
36: 	return json.Marshal(n.String())
37: }
38: 
39: type Type int
40: 
41: func (t Type) String() string {
42: 	switch t {
43: 	case HTTP:
44: 		return "HTTP"
45: 	case HTTPCONNECT:
46: 		return "HTTP Connect"
47: 	case SOCKS4:
48: 		return "Socks4"
49: 	case SOCKS5:
50: 		return "Socks5"
51: 	case REDIR:
52: 		return "Redir"
53: 	case TPROXY:
54: 		return "TProxy"
55: 	case TUNNEL:
56: 		return "Tunnel"
57: 	default:
58: 		return "Unknown"
59: 	}
60: }
61: 
62: func (t Type) MarshalJSON() ([]byte, error) {
63: 	return json.Marshal(t.String())
64: }
65: 
66: // Metadata is used to store connection address
67: type Metadata struct {
68: 	NetWork      NetWork `json:"network"`
69: 	Type         Type    `json:"type"`
70: 	SrcIP        net.IP  `json:"sourceIP"`
71: 	DstIP        net.IP  `json:"destinationIP"`
72: 	SrcPort      Port    `json:"sourcePort"`
73: 	DstPort      Port    `json:"destinationPort"`
74: 	Host         string  `json:"host"`
75: 	DNSMode      DNSMode `json:"dnsMode"`
76: 	ProcessPath  string  `json:"processPath"`
77: 	SpecialProxy string  `json:"specialProxy"`
78: 
79: 	OriginDst netip.AddrPort `json:"-"`
80: }
81: 
82: func (m *Metadata) RemoteAddress() string {
83: 	return net.JoinHostPort(m.String(), m.DstPort.String())
84: }
85: 
86: func (m *Metadata) SourceAddress() string {
87: 	return net.JoinHostPort(m.SrcIP.String(), m.SrcPort.String())
88: }
89: 
90: func (m *Metadata) AddrType() int {
91: 	switch true {
92: 	case m.Host != "" || m.DstIP == nil:
93: 		return socks5.AtypDomainName
94: 	case m.DstIP.To4() != nil:
95: 		return socks5.AtypIPv4
96: 	default:
97: 		return socks5.AtypIPv6
98: 	}
99: }
100: 
101: func (m *Metadata) Resolved() bool {
102: 	return m.DstIP != nil
103: }
104: 
105: // Pure is used to solve unexpected behavior
106: // when dialing proxy connection in DNSMapping mode.
107: func (m *Metadata) Pure() *Metadata {
108: 	if m.DNSMode == DNSMapping && m.DstIP != nil {
109: 		copy := *m
110: 		copy.Host = ""
111: 		return &copy
112: 	}
113: 
114: 	return m
115: }
116: 
117: func (m *Metadata) UDPAddr() *net.UDPAddr {
118: 	if m.NetWork != UDP || m.DstIP == nil {
119: 		return nil
120: 	}
121: 	return &net.UDPAddr{
122: 		IP:   m.DstIP,
123: 		Port: int(m.DstPort),
124: 	}
125: }
126: 
127: func (m *Metadata) String() string {
128: 	if m.Host != "" {
129: 		return m.Host
130: 	} else if m.DstIP != nil {
131: 		return m.DstIP.String()
132: 	} else {
133: 		return "<nil>"
134: 	}
135: }
136: 
137: func (m *Metadata) Valid() bool {
138: 	return m.Host != "" || m.DstIP != nil
139: }
140: 
141: // Port is used to compatible with old version
142: type Port uint16
143: 
144: func (n Port) MarshalJSON() ([]byte, error) {
145: 	return json.Marshal(n.String())
146: }
147: 
148: func (n Port) String() string {
149: 	return strconv.FormatUint(uint64(n), 10)
150: }


./constant\path.go
1: package constant
2: 
3: import (
4: 	"os"
5: 	P "path"
6: 	"path/filepath"
7: 	"strings"
8: )
9: 
10: const Name = "clash"
11: 
12: // Path is used to get the configuration path
13: //
14: // on Unix systems, `$HOME/.config/clash`.
15: // on Windows, `%USERPROFILE%/.config/clash`.
16: var Path = func() *path {
17: 	homeDir, err := os.UserHomeDir()
18: 	if err != nil {
19: 		homeDir, _ = os.Getwd()
20: 	}
21: 
22: 	homeDir = P.Join(homeDir, ".config", Name)
23: 
24: 	if _, err = os.Stat(homeDir); err != nil {
25: 		if configHome, ok := os.LookupEnv("XDG_CONFIG_HOME"); ok {
26: 			homeDir = P.Join(configHome, Name)
27: 		}
28: 	}
29: 	return &path{homeDir: homeDir, configFile: "config.yaml"}
30: }()
31: 
32: type path struct {
33: 	homeDir    string
34: 	configFile string
35: }
36: 
37: // SetHomeDir is used to set the configuration path
38: func SetHomeDir(root string) {
39: 	Path.homeDir = root
40: }
41: 
42: // SetConfig is used to set the configuration file
43: func SetConfig(file string) {
44: 	Path.configFile = file
45: }
46: 
47: func (p *path) HomeDir() string {
48: 	return p.homeDir
49: }
50: 
51: func (p *path) Config() string {
52: 	return p.configFile
53: }
54: 
55: // Resolve return a absolute path or a relative path with homedir
56: func (p *path) Resolve(path string) string {
57: 	if !filepath.IsAbs(path) {
58: 		return filepath.Join(p.HomeDir(), path)
59: 	}
60: 
61: 	return path
62: }
63: 
64: // IsSubPath return true if path is a subpath of homedir
65: func (p *path) IsSubPath(path string) bool {
66: 	homedir := p.HomeDir()
67: 	path = p.Resolve(path)
68: 	rel, err := filepath.Rel(homedir, path)
69: 	if err != nil {
70: 		return false
71: 	}
72: 
73: 	return !strings.Contains(rel, "..")
74: }
75: 
76: func (p *path) MMDB() string {
77: 	return P.Join(p.homeDir, "Country.mmdb")
78: }
79: 
80: func (p *path) OldCache() string {
81: 	return P.Join(p.homeDir, ".cache")
82: }
83: 
84: func (p *path) Cache() string {
85: 	return P.Join(p.homeDir, "cache.db")
86: }


./constant\rule.go
1: package constant
2: 
3: const (
4: 	RuleConfigDomain        RuleConfig = "DOMAIN"
5: 	RuleConfigDomainSuffix  RuleConfig = "DOMAIN-SUFFIX"
6: 	RuleConfigDomainKeyword RuleConfig = "DOMAIN-KEYWORD"
7: 	RuleConfigGeoIP         RuleConfig = "GEOIP"
8: 	RuleConfigIPCIDR        RuleConfig = "IP-CIDR"
9: 	RuleConfigIPCIDR6       RuleConfig = "IP-CIDR6"
10: 	RuleConfigSrcIPCIDR     RuleConfig = "SRC-IP-CIDR"
11: 	RuleConfigSrcPort       RuleConfig = "SRC-PORT"
12: 	RuleConfigDstPort       RuleConfig = "DST-PORT"
13: 	RuleConfigInboundPort   RuleConfig = "INBOUND-PORT"
14: 	RuleConfigProcessName   RuleConfig = "PROCESS-NAME"
15: 	RuleConfigProcessPath   RuleConfig = "PROCESS-PATH"
16: 	RuleConfigIPSet         RuleConfig = "IPSET"
17: 	RuleConfigRuleSet       RuleConfig = "RULE-SET"
18: 	RuleConfigScript        RuleConfig = "SCRIPT"
19: 	RuleConfigMatch         RuleConfig = "MATCH"
20: )
21: 
22: // Rule Config Type String represents a rule type in configuration files.
23: type RuleConfig string
24: 
25: // Rule Type
26: const (
27: 	Domain RuleType = iota
28: 	DomainSuffix
29: 	DomainKeyword
30: 	GEOIP
31: 	IPCIDR
32: 	SrcIPCIDR
33: 	SrcPort
34: 	DstPort
35: 	InboundPort
36: 	Process
37: 	ProcessPath
38: 	IPSet
39: 	MATCH
40: )
41: 
42: type RuleType int
43: 
44: func (rt RuleType) String() string {
45: 	switch rt {
46: 	case Domain:
47: 		return "Domain"
48: 	case DomainSuffix:
49: 		return "DomainSuffix"
50: 	case DomainKeyword:
51: 		return "DomainKeyword"
52: 	case GEOIP:
53: 		return "GeoIP"
54: 	case IPCIDR:
55: 		return "IPCIDR"
56: 	case SrcIPCIDR:
57: 		return "SrcIPCIDR"
58: 	case SrcPort:
59: 		return "SrcPort"
60: 	case DstPort:
61: 		return "DstPort"
62: 	case InboundPort:
63: 		return "InboundPort"
64: 	case Process:
65: 		return "Process"
66: 	case ProcessPath:
67: 		return "ProcessPath"
68: 	case IPSet:
69: 		return "IPSet"
70: 	case MATCH:
71: 		return "Match"
72: 	default:
73: 		return "Unknown"
74: 	}
75: }
76: 
77: type Rule interface {
78: 	RuleType() RuleType
79: 	Match(metadata *Metadata) bool
80: 	Adapter() string
81: 	Payload() string
82: 	ShouldResolveIP() bool
83: 	ShouldFindProcess() bool
84: }


./constant\version.go
1: package constant
2: 
3: var (
4: 	Version   = "unknown version"
5: 	BuildTime = "unknown time"
6: )


./constant\provider\interface.go
1: package provider
2: 
3: import (
4: 	"github.com/Dreamacro/clash/constant"
5: )
6: 
7: // Vehicle Type
8: const (
9: 	File VehicleType = iota
10: 	HTTP
11: 	Compatible
12: )
13: 
14: // VehicleType defined
15: type VehicleType int
16: 
17: func (v VehicleType) String() string {
18: 	switch v {
19: 	case File:
20: 		return "File"
21: 	case HTTP:
22: 		return "HTTP"
23: 	case Compatible:
24: 		return "Compatible"
25: 	default:
26: 		return "Unknown"
27: 	}
28: }
29: 
30: type Vehicle interface {
31: 	Read() ([]byte, error)
32: 	Path() string
33: 	Type() VehicleType
34: }
35: 
36: // Provider Type
37: const (
38: 	Proxy ProviderType = iota
39: 	Rule
40: )
41: 
42: // ProviderType defined
43: type ProviderType int
44: 
45: func (pt ProviderType) String() string {
46: 	switch pt {
47: 	case Proxy:
48: 		return "Proxy"
49: 	case Rule:
50: 		return "Rule"
51: 	default:
52: 		return "Unknown"
53: 	}
54: }
55: 
56: // Provider interface
57: type Provider interface {
58: 	Name() string
59: 	VehicleType() VehicleType
60: 	Type() ProviderType
61: 	Initial() error
62: 	Update() error
63: }
64: 
65: // ProxyProvider interface
66: type ProxyProvider interface {
67: 	Provider
68: 	Proxies() []constant.Proxy
69: 	// Touch is used to inform the provider that the proxy is actually being used while getting the list of proxies.
70: 	// Commonly used in DialContext and DialPacketConn
71: 	Touch()
72: 	HealthCheck()
73: }
74: 
75: // Rule Type
76: const (
77: 	Domain RuleType = iota
78: 	IPCIDR
79: 	Classical
80: )
81: 
82: // RuleType defined
83: type RuleType int
84: 
85: func (rt RuleType) String() string {
86: 	switch rt {
87: 	case Domain:
88: 		return "Domain"
89: 	case IPCIDR:
90: 		return "IPCIDR"
91: 	case Classical:
92: 		return "Classical"
93: 	default:
94: 		return "Unknown"
95: 	}
96: }
97: 
98: // RuleProvider interface
99: type RuleProvider interface {
100: 	Provider
101: 	Behavior() RuleType
102: 	Match(*constant.Metadata) bool
103: 	ShouldResolveIP() bool
104: 	AsRule(adaptor string) constant.Rule
105: }


./context\conn.go
1: package context
2: 
3: import (
4: 	"net"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: 
8: 	"github.com/gofrs/uuid/v5"
9: )
10: 
11: type ConnContext struct {
12: 	id       uuid.UUID
13: 	metadata *C.Metadata
14: 	conn     net.Conn
15: }
16: 
17: func NewConnContext(conn net.Conn, metadata *C.Metadata) *ConnContext {
18: 	id, _ := uuid.NewV4()
19: 	return &ConnContext{
20: 		id:       id,
21: 		metadata: metadata,
22: 		conn:     conn,
23: 	}
24: }
25: 
26: // ID implement C.ConnContext ID
27: func (c *ConnContext) ID() uuid.UUID {
28: 	return c.id
29: }
30: 
31: // Metadata implement C.ConnContext Metadata
32: func (c *ConnContext) Metadata() *C.Metadata {
33: 	return c.metadata
34: }
35: 
36: // Conn implement C.ConnContext Conn
37: func (c *ConnContext) Conn() net.Conn {
38: 	return c.conn
39: }


./context\dns.go
1: package context
2: 
3: import (
4: 	"github.com/gofrs/uuid/v5"
5: 	"github.com/miekg/dns"
6: )
7: 
8: const (
9: 	DNSTypeHost   = "host"
10: 	DNSTypeFakeIP = "fakeip"
11: 	DNSTypeRaw    = "raw"
12: )
13: 
14: type DNSContext struct {
15: 	id  uuid.UUID
16: 	msg *dns.Msg
17: 	tp  string
18: }
19: 
20: func NewDNSContext(msg *dns.Msg) *DNSContext {
21: 	id, _ := uuid.NewV4()
22: 	return &DNSContext{
23: 		id:  id,
24: 		msg: msg,
25: 	}
26: }
27: 
28: // ID implement C.PlainContext ID
29: func (c *DNSContext) ID() uuid.UUID {
30: 	return c.id
31: }
32: 
33: // SetType set type of response
34: func (c *DNSContext) SetType(tp string) {
35: 	c.tp = tp
36: }
37: 
38: // Type return type of response
39: func (c *DNSContext) Type() string {
40: 	return c.tp
41: }


./context\packetconn.go
1: package context
2: 
3: import (
4: 	"net"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: 
8: 	"github.com/gofrs/uuid/v5"
9: )
10: 
11: type PacketConnContext struct {
12: 	id         uuid.UUID
13: 	metadata   *C.Metadata
14: 	packetConn net.PacketConn
15: }
16: 
17: func NewPacketConnContext(metadata *C.Metadata) *PacketConnContext {
18: 	id, _ := uuid.NewV4()
19: 	return &PacketConnContext{
20: 		id:       id,
21: 		metadata: metadata,
22: 	}
23: }
24: 
25: // ID implement C.PacketConnContext ID
26: func (pc *PacketConnContext) ID() uuid.UUID {
27: 	return pc.id
28: }
29: 
30: // Metadata implement C.PacketConnContext Metadata
31: func (pc *PacketConnContext) Metadata() *C.Metadata {
32: 	return pc.metadata
33: }
34: 
35: // PacketConn implement C.PacketConnContext PacketConn
36: func (pc *PacketConnContext) PacketConn() net.PacketConn {
37: 	return pc.packetConn
38: }
39: 
40: // InjectPacketConn injectPacketConn manually
41: func (pc *PacketConnContext) InjectPacketConn(pconn C.PacketConn) {
42: 	pc.packetConn = pconn
43: }


./dns\client.go
1: package dns
2: 
3: import (
4: 	"context"
5: 	"crypto/tls"
6: 	"fmt"
7: 	"math/rand"
8: 	"net"
9: 	"strings"
10: 
11: 	"github.com/Dreamacro/clash/component/dialer"
12: 	"github.com/Dreamacro/clash/component/resolver"
13: 
14: 	D "github.com/miekg/dns"
15: )
16: 
17: type client struct {
18: 	*D.Client
19: 	r     *Resolver
20: 	port  string
21: 	host  string
22: 	iface string
23: }
24: 
25: func (c *client) Exchange(m *D.Msg) (*D.Msg, error) {
26: 	return c.ExchangeContext(context.Background(), m)
27: }
28: 
29: func (c *client) ExchangeContext(ctx context.Context, m *D.Msg) (*D.Msg, error) {
30: 	var (
31: 		ip  net.IP
32: 		err error
33: 	)
34: 	if c.r == nil {
35: 		// a default ip dns
36: 		if ip = net.ParseIP(c.host); ip == nil {
37: 			return nil, fmt.Errorf("dns %s not a valid ip", c.host)
38: 		}
39: 	} else {
40: 		ips, err := resolver.LookupIPWithResolver(ctx, c.host, c.r)
41: 		if err != nil {
42: 			return nil, fmt.Errorf("use default dns resolve failed: %w", err)
43: 		} else if len(ips) == 0 {
44: 			return nil, fmt.Errorf("%w: %s", resolver.ErrIPNotFound, c.host)
45: 		}
46: 		ip = ips[rand.Intn(len(ips))]
47: 	}
48: 
49: 	network := "udp"
50: 	if strings.HasPrefix(c.Client.Net, "tcp") {
51: 		network = "tcp"
52: 	}
53: 
54: 	options := []dialer.Option{}
55: 	if c.iface != "" {
56: 		options = append(options, dialer.WithInterface(c.iface))
57: 	}
58: 	conn, err := dialer.DialContext(ctx, network, net.JoinHostPort(ip.String(), c.port), options...)
59: 	if err != nil {
60: 		return nil, err
61: 	}
62: 	defer conn.Close()
63: 
64: 	// miekg/dns ExchangeContext doesn't respond to context cancel.
65: 	// this is a workaround
66: 	type result struct {
67: 		msg *D.Msg
68: 		err error
69: 	}
70: 	ch := make(chan result, 1)
71: 	go func() {
72: 		if strings.HasSuffix(c.Client.Net, "tls") {
73: 			conn = tls.Client(conn, c.Client.TLSConfig)
74: 		}
75: 
76: 		msg, _, err := c.Client.ExchangeWithConn(m, &D.Conn{
77: 			Conn:         conn,
78: 			UDPSize:      c.Client.UDPSize,
79: 			TsigSecret:   c.Client.TsigSecret,
80: 			TsigProvider: c.Client.TsigProvider,
81: 		})
82: 
83: 		ch <- result{msg, err}
84: 	}()
85: 
86: 	select {
87: 	case <-ctx.Done():
88: 		return nil, ctx.Err()
89: 	case ret := <-ch:
90: 		return ret.msg, ret.err
91: 	}
92: }


./dns\dhcp.go
1: package dns
2: 
3: import (
4: 	"bytes"
5: 	"context"
6: 	"net"
7: 	"sync"
8: 	"time"
9: 
10: 	"github.com/Dreamacro/clash/component/dhcp"
11: 	"github.com/Dreamacro/clash/component/iface"
12: 	"github.com/Dreamacro/clash/component/resolver"
13: 
14: 	D "github.com/miekg/dns"
15: )
16: 
17: const (
18: 	IfaceTTL    = time.Second * 20
19: 	DHCPTTL     = time.Hour
20: 	DHCPTimeout = time.Minute
21: )
22: 
23: type dhcpClient struct {
24: 	ifaceName string
25: 
26: 	lock            sync.Mutex
27: 	ifaceInvalidate time.Time
28: 	dnsInvalidate   time.Time
29: 
30: 	ifaceAddr *net.IPNet
31: 	done      chan struct{}
32: 	clients   []dnsClient
33: 	err       error
34: }
35: 
36: func (d *dhcpClient) Exchange(m *D.Msg) (msg *D.Msg, err error) {
37: 	ctx, cancel := context.WithTimeout(context.Background(), resolver.DefaultDNSTimeout)
38: 	defer cancel()
39: 
40: 	return d.ExchangeContext(ctx, m)
41: }
42: 
43: func (d *dhcpClient) ExchangeContext(ctx context.Context, m *D.Msg) (msg *D.Msg, err error) {
44: 	clients, err := d.resolve(ctx)
45: 	if err != nil {
46: 		return nil, err
47: 	}
48: 
49: 	return batchExchange(ctx, clients, m)
50: }
51: 
52: func (d *dhcpClient) resolve(ctx context.Context) ([]dnsClient, error) {
53: 	d.lock.Lock()
54: 
55: 	invalidated, err := d.invalidate()
56: 	if err != nil {
57: 		d.err = err
58: 	} else if invalidated {
59: 		done := make(chan struct{})
60: 
61: 		d.done = done
62: 
63: 		go func() {
64: 			ctx, cancel := context.WithTimeout(context.Background(), DHCPTimeout)
65: 			defer cancel()
66: 
67: 			var res []dnsClient
68: 			dns, err := dhcp.ResolveDNSFromDHCP(ctx, d.ifaceName)
69: 			// dns never empty if err is nil
70: 			if err == nil {
71: 				nameserver := make([]NameServer, 0, len(dns))
72: 				for _, item := range dns {
73: 					nameserver = append(nameserver, NameServer{
74: 						Addr:      net.JoinHostPort(item.String(), "53"),
75: 						Interface: d.ifaceName,
76: 					})
77: 				}
78: 
79: 				res = transform(nameserver, nil)
80: 			}
81: 
82: 			d.lock.Lock()
83: 			defer d.lock.Unlock()
84: 
85: 			close(done)
86: 
87: 			d.done = nil
88: 			d.clients = res
89: 			d.err = err
90: 		}()
91: 	}
92: 
93: 	d.lock.Unlock()
94: 
95: 	for {
96: 		d.lock.Lock()
97: 
98: 		res, err, done := d.clients, d.err, d.done
99: 
100: 		d.lock.Unlock()
101: 
102: 		// initializing
103: 		if res == nil && err == nil {
104: 			select {
105: 			case <-done:
106: 				continue
107: 			case <-ctx.Done():
108: 				return nil, ctx.Err()
109: 			}
110: 		}
111: 
112: 		// dirty return
113: 		return res, err
114: 	}
115: }
116: 
117: func (d *dhcpClient) invalidate() (bool, error) {
118: 	if time.Now().Before(d.ifaceInvalidate) {
119: 		return false, nil
120: 	}
121: 
122: 	d.ifaceInvalidate = time.Now().Add(IfaceTTL)
123: 
124: 	ifaceObj, err := iface.ResolveInterface(d.ifaceName)
125: 	if err != nil {
126: 		return false, err
127: 	}
128: 
129: 	addr, err := ifaceObj.PickIPv4Addr(nil)
130: 	if err != nil {
131: 		return false, err
132: 	}
133: 
134: 	if time.Now().Before(d.dnsInvalidate) && d.ifaceAddr.IP.Equal(addr.IP) && bytes.Equal(d.ifaceAddr.Mask, addr.Mask) {
135: 		return false, nil
136: 	}
137: 
138: 	d.dnsInvalidate = time.Now().Add(DHCPTTL)
139: 	d.ifaceAddr = addr
140: 
141: 	return d.done == nil, nil
142: }
143: 
144: func newDHCPClient(ifaceName string) *dhcpClient {
145: 	return &dhcpClient{ifaceName: ifaceName}
146: }


./dns\doh.go
1: package dns
2: 
3: import (
4: 	"bytes"
5: 	"context"
6: 	"crypto/tls"
7: 	"fmt"
8: 	"io"
9: 	"math/rand"
10: 	"net"
11: 	"net/http"
12: 
13: 	"github.com/Dreamacro/clash/component/dialer"
14: 	"github.com/Dreamacro/clash/component/resolver"
15: 
16: 	D "github.com/miekg/dns"
17: )
18: 
19: const (
20: 	// dotMimeType is the DoH mimetype that should be used.
21: 	dotMimeType = "application/dns-message"
22: )
23: 
24: type dohClient struct {
25: 	url       string
26: 	transport *http.Transport
27: }
28: 
29: func (dc *dohClient) Exchange(m *D.Msg) (msg *D.Msg, err error) {
30: 	return dc.ExchangeContext(context.Background(), m)
31: }
32: 
33: func (dc *dohClient) ExchangeContext(ctx context.Context, m *D.Msg) (msg *D.Msg, err error) {
34: 	// https://datatracker.ietf.org/doc/html/rfc8484#section-4.1
35: 	// In order to maximize cache friendliness, SHOULD use a DNS ID of 0 in every DNS request.
36: 	newM := *m
37: 	newM.Id = 0
38: 	req, err := dc.newRequest(&newM)
39: 	if err != nil {
40: 		return nil, err
41: 	}
42: 
43: 	req = req.WithContext(ctx)
44: 	msg, err = dc.doRequest(req)
45: 	if err == nil {
46: 		msg.Id = m.Id
47: 	}
48: 	return
49: }
50: 
51: // newRequest returns a new DoH request given a dns.Msg.
52: func (dc *dohClient) newRequest(m *D.Msg) (*http.Request, error) {
53: 	buf, err := m.Pack()
54: 	if err != nil {
55: 		return nil, err
56: 	}
57: 
58: 	req, err := http.NewRequest(http.MethodPost, dc.url, bytes.NewReader(buf))
59: 	if err != nil {
60: 		return req, err
61: 	}
62: 
63: 	req.Header.Set("content-type", dotMimeType)
64: 	req.Header.Set("accept", dotMimeType)
65: 	return req, nil
66: }
67: 
68: func (dc *dohClient) doRequest(req *http.Request) (msg *D.Msg, err error) {
69: 	client := &http.Client{Transport: dc.transport}
70: 	resp, err := client.Do(req)
71: 	if err != nil {
72: 		return nil, err
73: 	}
74: 	defer resp.Body.Close()
75: 
76: 	buf, err := io.ReadAll(resp.Body)
77: 	if err != nil {
78: 		return nil, err
79: 	}
80: 	msg = &D.Msg{}
81: 	err = msg.Unpack(buf)
82: 	return msg, err
83: }
84: 
85: func newDoHClient(url, iface string, r *Resolver) *dohClient {
86: 	return &dohClient{
87: 		url: url,
88: 		transport: &http.Transport{
89: 			ForceAttemptHTTP2: true,
90: 			DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
91: 				host, port, err := net.SplitHostPort(addr)
92: 				if err != nil {
93: 					return nil, err
94: 				}
95: 
96: 				ips, err := resolver.LookupIPWithResolver(ctx, host, r)
97: 				if err != nil {
98: 					return nil, err
99: 				} else if len(ips) == 0 {
100: 					return nil, fmt.Errorf("%w: %s", resolver.ErrIPNotFound, host)
101: 				}
102: 				ip := ips[rand.Intn(len(ips))]
103: 
104: 				options := []dialer.Option{}
105: 				if iface != "" {
106: 					options = append(options, dialer.WithInterface(iface))
107: 				}
108: 
109: 				return dialer.DialContext(ctx, "tcp", net.JoinHostPort(ip.String(), port), options...)
110: 			},
111: 			TLSClientConfig: &tls.Config{
112: 				// alpn identifier, see https://tools.ietf.org/html/draft-hoffman-dprive-dns-tls-alpn-00#page-6
113: 				NextProtos: []string{"dns"},
114: 			},
115: 		},
116: 	}
117: }


./dns\enhancer.go
1: package dns
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/common/cache"
7: 	"github.com/Dreamacro/clash/component/fakeip"
8: 	C "github.com/Dreamacro/clash/constant"
9: )
10: 
11: type ResolverEnhancer struct {
12: 	mode     C.DNSMode
13: 	fakePool *fakeip.Pool
14: 	mapping  *cache.LruCache
15: }
16: 
17: func (h *ResolverEnhancer) FakeIPEnabled() bool {
18: 	return h.mode == C.DNSFakeIP
19: }
20: 
21: func (h *ResolverEnhancer) MappingEnabled() bool {
22: 	return h.mode == C.DNSFakeIP || h.mode == C.DNSMapping
23: }
24: 
25: func (h *ResolverEnhancer) IsExistFakeIP(ip net.IP) bool {
26: 	if !h.FakeIPEnabled() {
27: 		return false
28: 	}
29: 
30: 	if pool := h.fakePool; pool != nil {
31: 		return pool.Exist(ip)
32: 	}
33: 
34: 	return false
35: }
36: 
37: func (h *ResolverEnhancer) IsFakeIP(ip net.IP) bool {
38: 	if !h.FakeIPEnabled() {
39: 		return false
40: 	}
41: 
42: 	if pool := h.fakePool; pool != nil {
43: 		return pool.IPNet().Contains(ip) && !pool.Gateway().Equal(ip)
44: 	}
45: 
46: 	return false
47: }
48: 
49: func (h *ResolverEnhancer) FindHostByIP(ip net.IP) (string, bool) {
50: 	if pool := h.fakePool; pool != nil {
51: 		if host, existed := pool.LookBack(ip); existed {
52: 			return host, true
53: 		}
54: 	}
55: 
56: 	if mapping := h.mapping; mapping != nil {
57: 		if host, existed := h.mapping.Get(ip.String()); existed {
58: 			return host.(string), true
59: 		}
60: 	}
61: 
62: 	return "", false
63: }
64: 
65: func (h *ResolverEnhancer) PatchFrom(o *ResolverEnhancer) {
66: 	if h.mapping != nil && o.mapping != nil {
67: 		o.mapping.CloneTo(h.mapping)
68: 	}
69: 
70: 	if h.fakePool != nil && o.fakePool != nil {
71: 		h.fakePool.CloneFrom(o.fakePool)
72: 	}
73: }
74: 
75: func NewEnhancer(cfg Config) *ResolverEnhancer {
76: 	var fakePool *fakeip.Pool
77: 	var mapping *cache.LruCache
78: 
79: 	if cfg.EnhancedMode != C.DNSNormal {
80: 		fakePool = cfg.Pool
81: 		mapping = cache.New(cache.WithSize(4096))
82: 	}
83: 
84: 	return &ResolverEnhancer{
85: 		mode:     cfg.EnhancedMode,
86: 		fakePool: fakePool,
87: 		mapping:  mapping,
88: 	}
89: }


./dns\filters.go
1: package dns
2: 
3: import (
4: 	"net"
5: 	"strings"
6: 
7: 	"github.com/Dreamacro/clash/component/mmdb"
8: 	"github.com/Dreamacro/clash/component/trie"
9: )
10: 
11: type fallbackIPFilter interface {
12: 	Match(net.IP) bool
13: }
14: 
15: type geoipFilter struct {
16: 	code string
17: }
18: 
19: func (gf *geoipFilter) Match(ip net.IP) bool {
20: 	record, _ := mmdb.Instance().Country(ip)
21: 	return !strings.EqualFold(record.Country.IsoCode, gf.code) && !ip.IsPrivate()
22: }
23: 
24: type ipnetFilter struct {
25: 	ipnet *net.IPNet
26: }
27: 
28: func (inf *ipnetFilter) Match(ip net.IP) bool {
29: 	return inf.ipnet.Contains(ip)
30: }
31: 
32: type fallbackDomainFilter interface {
33: 	Match(domain string) bool
34: }
35: 
36: type domainFilter struct {
37: 	tree *trie.DomainTrie
38: }
39: 
40: func NewDomainFilter(domains []string) *domainFilter {
41: 	df := domainFilter{tree: trie.New()}
42: 	for _, domain := range domains {
43: 		df.tree.Insert(domain, "")
44: 	}
45: 	return &df
46: }
47: 
48: func (df *domainFilter) Match(domain string) bool {
49: 	return df.tree.Search(domain) != nil
50: }


./dns\middleware.go
1: package dns
2: 
3: import (
4: 	"net"
5: 	"strings"
6: 	"time"
7: 
8: 	"github.com/Dreamacro/clash/common/cache"
9: 	"github.com/Dreamacro/clash/component/fakeip"
10: 	"github.com/Dreamacro/clash/component/trie"
11: 	C "github.com/Dreamacro/clash/constant"
12: 	"github.com/Dreamacro/clash/context"
13: 	"github.com/Dreamacro/clash/log"
14: 
15: 	D "github.com/miekg/dns"
16: )
17: 
18: type (
19: 	handler    func(ctx *context.DNSContext, r *D.Msg) (*D.Msg, error)
20: 	middleware func(next handler) handler
21: )
22: 
23: func withHosts(hosts *trie.DomainTrie) middleware {
24: 	return func(next handler) handler {
25: 		return func(ctx *context.DNSContext, r *D.Msg) (*D.Msg, error) {
26: 			q := r.Question[0]
27: 
28: 			if !isIPRequest(q) {
29: 				return next(ctx, r)
30: 			}
31: 
32: 			record := hosts.Search(strings.TrimRight(q.Name, "."))
33: 			if record == nil {
34: 				return next(ctx, r)
35: 			}
36: 
37: 			ip := record.Data.(net.IP)
38: 			msg := r.Copy()
39: 
40: 			if v4 := ip.To4(); v4 != nil && q.Qtype == D.TypeA {
41: 				rr := &D.A{}
42: 				rr.Hdr = D.RR_Header{Name: q.Name, Rrtype: D.TypeA, Class: D.ClassINET, Ttl: dnsDefaultTTL}
43: 				rr.A = v4
44: 
45: 				msg.Answer = []D.RR{rr}
46: 			} else if v6 := ip.To16(); v6 != nil && q.Qtype == D.TypeAAAA {
47: 				rr := &D.AAAA{}
48: 				rr.Hdr = D.RR_Header{Name: q.Name, Rrtype: D.TypeAAAA, Class: D.ClassINET, Ttl: dnsDefaultTTL}
49: 				rr.AAAA = v6
50: 
51: 				msg.Answer = []D.RR{rr}
52: 			} else {
53: 				return next(ctx, r)
54: 			}
55: 
56: 			ctx.SetType(context.DNSTypeHost)
57: 			msg.SetRcode(r, D.RcodeSuccess)
58: 			msg.Authoritative = true
59: 			msg.RecursionAvailable = true
60: 
61: 			return msg, nil
62: 		}
63: 	}
64: }
65: 
66: func withMapping(mapping *cache.LruCache) middleware {
67: 	return func(next handler) handler {
68: 		return func(ctx *context.DNSContext, r *D.Msg) (*D.Msg, error) {
69: 			q := r.Question[0]
70: 
71: 			if !isIPRequest(q) {
72: 				return next(ctx, r)
73: 			}
74: 
75: 			msg, err := next(ctx, r)
76: 			if err != nil {
77: 				return nil, err
78: 			}
79: 
80: 			host := strings.TrimRight(q.Name, ".")
81: 
82: 			for _, ans := range msg.Answer {
83: 				var ip net.IP
84: 				var ttl uint32
85: 
86: 				switch a := ans.(type) {
87: 				case *D.A:
88: 					ip = a.A
89: 					ttl = a.Hdr.Ttl
90: 					if !ip.IsGlobalUnicast() {
91: 						continue
92: 					}
93: 				case *D.AAAA:
94: 					ip = a.AAAA
95: 					ttl = a.Hdr.Ttl
96: 					if !ip.IsGlobalUnicast() {
97: 						continue
98: 					}
99: 				default:
100: 					continue
101: 				}
102: 
103: 				if ttl < 1 {
104: 					ttl = 1
105: 				}
106: 				mapping.SetWithExpire(ip.String(), host, time.Now().Add(time.Second*time.Duration(ttl)))
107: 			}
108: 
109: 			return msg, nil
110: 		}
111: 	}
112: }
113: 
114: func withFakeIP(fakePool *fakeip.Pool) middleware {
115: 	return func(next handler) handler {
116: 		return func(ctx *context.DNSContext, r *D.Msg) (*D.Msg, error) {
117: 			q := r.Question[0]
118: 
119: 			host := strings.TrimRight(q.Name, ".")
120: 			if fakePool.ShouldSkipped(host) {
121: 				return next(ctx, r)
122: 			}
123: 
124: 			switch q.Qtype {
125: 			case D.TypeAAAA, D.TypeSVCB, D.TypeHTTPS:
126: 				return handleMsgWithEmptyAnswer(r), nil
127: 			}
128: 
129: 			if q.Qtype != D.TypeA {
130: 				return next(ctx, r)
131: 			}
132: 
133: 			rr := &D.A{}
134: 			rr.Hdr = D.RR_Header{Name: q.Name, Rrtype: D.TypeA, Class: D.ClassINET, Ttl: dnsDefaultTTL}
135: 			ip := fakePool.Lookup(host)
136: 			rr.A = ip
137: 			msg := r.Copy()
138: 			msg.Answer = []D.RR{rr}
139: 
140: 			ctx.SetType(context.DNSTypeFakeIP)
141: 			setMsgTTL(msg, 1)
142: 			msg.SetRcode(r, D.RcodeSuccess)
143: 			msg.Authoritative = true
144: 			msg.RecursionAvailable = true
145: 
146: 			return msg, nil
147: 		}
148: 	}
149: }
150: 
151: func withResolver(resolver *Resolver) handler {
152: 	return func(ctx *context.DNSContext, r *D.Msg) (*D.Msg, error) {
153: 		ctx.SetType(context.DNSTypeRaw)
154: 		q := r.Question[0]
155: 
156: 		// return a empty AAAA msg when ipv6 disabled
157: 		if !resolver.ipv6 && q.Qtype == D.TypeAAAA {
158: 			return handleMsgWithEmptyAnswer(r), nil
159: 		}
160: 
161: 		msg, err := resolver.Exchange(r)
162: 		if err != nil {
163: 			log.Debugln("[DNS Server] Exchange %s failed: %v", q.String(), err)
164: 			return msg, err
165: 		}
166: 		msg.SetRcode(r, msg.Rcode)
167: 		msg.Authoritative = true
168: 
169: 		return msg, nil
170: 	}
171: }
172: 
173: func compose(middlewares []middleware, endpoint handler) handler {
174: 	length := len(middlewares)
175: 	h := endpoint
176: 	for i := length - 1; i >= 0; i-- {
177: 		middleware := middlewares[i]
178: 		h = middleware(h)
179: 	}
180: 
181: 	return h
182: }
183: 
184: func newHandler(resolver *Resolver, mapper *ResolverEnhancer) handler {
185: 	middlewares := []middleware{}
186: 
187: 	if resolver.hosts != nil {
188: 		middlewares = append(middlewares, withHosts(resolver.hosts))
189: 	}
190: 
191: 	if mapper.mode == C.DNSFakeIP {
192: 		middlewares = append(middlewares, withFakeIP(mapper.fakePool))
193: 		middlewares = append(middlewares, withMapping(mapper.mapping))
194: 	}
195: 
196: 	return compose(middlewares, withResolver(resolver))
197: }


./dns\resolver.go
1: package dns
2: 
3: import (
4: 	"context"
5: 	"errors"
6: 	"fmt"
7: 	"math/rand"
8: 	"net"
9: 	"strings"
10: 	"time"
11: 
12: 	"github.com/Dreamacro/clash/common/cache"
13: 	"github.com/Dreamacro/clash/component/fakeip"
14: 	"github.com/Dreamacro/clash/component/resolver"
15: 	"github.com/Dreamacro/clash/component/trie"
16: 	C "github.com/Dreamacro/clash/constant"
17: 
18: 	D "github.com/miekg/dns"
19: 	"github.com/samber/lo"
20: 	"golang.org/x/sync/singleflight"
21: )
22: 
23: type dnsClient interface {
24: 	Exchange(m *D.Msg) (msg *D.Msg, err error)
25: 	ExchangeContext(ctx context.Context, m *D.Msg) (msg *D.Msg, err error)
26: }
27: 
28: type result struct {
29: 	Msg   *D.Msg
30: 	Error error
31: }
32: 
33: type Resolver struct {
34: 	ipv6                  bool
35: 	hosts                 *trie.DomainTrie
36: 	main                  []dnsClient
37: 	fallback              []dnsClient
38: 	fallbackDomainFilters []fallbackDomainFilter
39: 	fallbackIPFilters     []fallbackIPFilter
40: 	group                 singleflight.Group
41: 	lruCache              *cache.LruCache
42: 	policy                *trie.DomainTrie
43: 	searchDomains         []string
44: }
45: 
46: // LookupIP request with TypeA and TypeAAAA, priority return TypeA
47: func (r *Resolver) LookupIP(ctx context.Context, host string) (ip []net.IP, err error) {
48: 	ctx, cancel := context.WithCancel(ctx)
49: 	defer cancel()
50: 
51: 	ch := make(chan []net.IP, 1)
52: 
53: 	go func() {
54: 		defer close(ch)
55: 		ip, err := r.lookupIP(ctx, host, D.TypeAAAA)
56: 		if err != nil {
57: 			return
58: 		}
59: 		ch <- ip
60: 	}()
61: 
62: 	ip, err = r.lookupIP(ctx, host, D.TypeA)
63: 	if err == nil {
64: 		return
65: 	}
66: 
67: 	ip, open := <-ch
68: 	if !open {
69: 		return nil, resolver.ErrIPNotFound
70: 	}
71: 
72: 	return ip, nil
73: }
74: 
75: // ResolveIP request with TypeA and TypeAAAA, priority return TypeA
76: func (r *Resolver) ResolveIP(host string) (ip net.IP, err error) {
77: 	ips, err := r.LookupIP(context.Background(), host)
78: 	if err != nil {
79: 		return nil, err
80: 	} else if len(ips) == 0 {
81: 		return nil, fmt.Errorf("%w: %s", resolver.ErrIPNotFound, host)
82: 	}
83: 	return ips[rand.Intn(len(ips))], nil
84: }
85: 
86: // LookupIPv4 request with TypeA
87: func (r *Resolver) LookupIPv4(ctx context.Context, host string) ([]net.IP, error) {
88: 	return r.lookupIP(ctx, host, D.TypeA)
89: }
90: 
91: // ResolveIPv4 request with TypeA
92: func (r *Resolver) ResolveIPv4(host string) (ip net.IP, err error) {
93: 	ips, err := r.lookupIP(context.Background(), host, D.TypeA)
94: 	if err != nil {
95: 		return nil, err
96: 	} else if len(ips) == 0 {
97: 		return nil, fmt.Errorf("%w: %s", resolver.ErrIPNotFound, host)
98: 	}
99: 	return ips[rand.Intn(len(ips))], nil
100: }
101: 
102: // LookupIPv6 request with TypeAAAA
103: func (r *Resolver) LookupIPv6(ctx context.Context, host string) ([]net.IP, error) {
104: 	return r.lookupIP(ctx, host, D.TypeAAAA)
105: }
106: 
107: // ResolveIPv6 request with TypeAAAA
108: func (r *Resolver) ResolveIPv6(host string) (ip net.IP, err error) {
109: 	ips, err := r.lookupIP(context.Background(), host, D.TypeAAAA)
110: 	if err != nil {
111: 		return nil, err
112: 	} else if len(ips) == 0 {
113: 		return nil, fmt.Errorf("%w: %s", resolver.ErrIPNotFound, host)
114: 	}
115: 	return ips[rand.Intn(len(ips))], nil
116: }
117: 
118: func (r *Resolver) shouldIPFallback(ip net.IP) bool {
119: 	for _, filter := range r.fallbackIPFilters {
120: 		if filter.Match(ip) {
121: 			return true
122: 		}
123: 	}
124: 	return false
125: }
126: 
127: // Exchange a batch of dns request, and it use cache
128: func (r *Resolver) Exchange(m *D.Msg) (msg *D.Msg, err error) {
129: 	return r.ExchangeContext(context.Background(), m)
130: }
131: 
132: // ExchangeContext a batch of dns request with context.Context, and it use cache
133: func (r *Resolver) ExchangeContext(ctx context.Context, m *D.Msg) (msg *D.Msg, err error) {
134: 	if len(m.Question) == 0 {
135: 		return nil, errors.New("should have one question at least")
136: 	}
137: 
138: 	q := m.Question[0]
139: 	cache, expireTime, hit := r.lruCache.GetWithExpire(q.String())
140: 	if hit {
141: 		now := time.Now()
142: 		msg = cache.(*D.Msg).Copy()
143: 		if expireTime.Before(now) {
144: 			setMsgTTL(msg, uint32(1)) // Continue fetch
145: 			go func() {
146: 				ctx, cancel := context.WithTimeout(context.Background(), resolver.DefaultDNSTimeout)
147: 				r.exchangeWithoutCache(ctx, m)
148: 				cancel()
149: 			}()
150: 		} else {
151: 			// updating TTL by subtracting common delta time from each DNS record
152: 			updateMsgTTL(msg, uint32(time.Until(expireTime).Seconds()))
153: 		}
154: 		return
155: 	}
156: 	return r.exchangeWithoutCache(ctx, m)
157: }
158: 
159: // ExchangeWithoutCache a batch of dns request, and it do NOT GET from cache
160: func (r *Resolver) exchangeWithoutCache(ctx context.Context, m *D.Msg) (msg *D.Msg, err error) {
161: 	q := m.Question[0]
162: 
163: 	ret, err, shared := r.group.Do(q.String(), func() (result any, err error) {
164: 		defer func() {
165: 			if err != nil {
166: 				return
167: 			}
168: 
169: 			msg := result.(*D.Msg)
170: 			// OPT RRs MUST NOT be cached, forwarded, or stored in or loaded from master files.
171: 			msg.Extra = lo.Filter(msg.Extra, func(rr D.RR, index int) bool {
172: 				return rr.Header().Rrtype != D.TypeOPT
173: 			})
174: 			putMsgToCache(r.lruCache, q.String(), q, msg)
175: 		}()
176: 
177: 		isIPReq := isIPRequest(q)
178: 		if isIPReq {
179: 			return r.ipExchange(ctx, m)
180: 		}
181: 
182: 		if matched := r.matchPolicy(m); len(matched) != 0 {
183: 			return r.batchExchange(ctx, matched, m)
184: 		}
185: 		return r.batchExchange(ctx, r.main, m)
186: 	})
187: 
188: 	if err == nil {
189: 		msg = ret.(*D.Msg)
190: 		if shared {
191: 			msg = msg.Copy()
192: 		}
193: 	}
194: 
195: 	return
196: }
197: 
198: func (r *Resolver) batchExchange(ctx context.Context, clients []dnsClient, m *D.Msg) (msg *D.Msg, err error) {
199: 	ctx, cancel := context.WithTimeout(ctx, resolver.DefaultDNSTimeout)
200: 	defer cancel()
201: 
202: 	return batchExchange(ctx, clients, m)
203: }
204: 
205: func (r *Resolver) matchPolicy(m *D.Msg) []dnsClient {
206: 	if r.policy == nil {
207: 		return nil
208: 	}
209: 
210: 	domain := r.msgToDomain(m)
211: 	if domain == "" {
212: 		return nil
213: 	}
214: 
215: 	record := r.policy.Search(domain)
216: 	if record == nil {
217: 		return nil
218: 	}
219: 
220: 	return record.Data.([]dnsClient)
221: }
222: 
223: func (r *Resolver) shouldOnlyQueryFallback(m *D.Msg) bool {
224: 	if r.fallback == nil || len(r.fallbackDomainFilters) == 0 {
225: 		return false
226: 	}
227: 
228: 	domain := r.msgToDomain(m)
229: 
230: 	if domain == "" {
231: 		return false
232: 	}
233: 
234: 	for _, df := range r.fallbackDomainFilters {
235: 		if df.Match(domain) {
236: 			return true
237: 		}
238: 	}
239: 
240: 	return false
241: }
242: 
243: func (r *Resolver) ipExchange(ctx context.Context, m *D.Msg) (msg *D.Msg, err error) {
244: 	if matched := r.matchPolicy(m); len(matched) != 0 {
245: 		res := <-r.asyncExchange(ctx, matched, m)
246: 		return res.Msg, res.Error
247: 	}
248: 
249: 	onlyFallback := r.shouldOnlyQueryFallback(m)
250: 
251: 	if onlyFallback {
252: 		res := <-r.asyncExchange(ctx, r.fallback, m)
253: 		return res.Msg, res.Error
254: 	}
255: 
256: 	msgCh := r.asyncExchange(ctx, r.main, m)
257: 
258: 	if r.fallback == nil { // directly return if no fallback servers are available
259: 		res := <-msgCh
260: 		msg, err = res.Msg, res.Error
261: 		return
262: 	}
263: 
264: 	fallbackMsg := r.asyncExchange(ctx, r.fallback, m)
265: 	res := <-msgCh
266: 	if res.Error == nil {
267: 		if ips := msgToIP(res.Msg); len(ips) != 0 {
268: 			shouldNotFallback := lo.EveryBy(ips, func(ip net.IP) bool {
269: 				return !r.shouldIPFallback(ip)
270: 			})
271: 			if shouldNotFallback {
272: 				msg = res.Msg // no need to wait for fallback result
273: 				err = res.Error
274: 				return msg, err
275: 			}
276: 		}
277: 	}
278: 
279: 	res = <-fallbackMsg
280: 	msg, err = res.Msg, res.Error
281: 	return
282: }
283: 
284: func (r *Resolver) lookupIP(ctx context.Context, host string, dnsType uint16) ([]net.IP, error) {
285: 	ip := net.ParseIP(host)
286: 	if ip != nil {
287: 		ip4 := ip.To4()
288: 		isIPv4 := ip4 != nil
289: 		if dnsType == D.TypeAAAA && !isIPv4 {
290: 			return []net.IP{ip}, nil
291: 		} else if dnsType == D.TypeA && isIPv4 {
292: 			return []net.IP{ip4}, nil
293: 		} else {
294: 			return nil, resolver.ErrIPVersion
295: 		}
296: 	}
297: 
298: 	query := &D.Msg{}
299: 	query.SetQuestion(D.Fqdn(host), dnsType)
300: 
301: 	msg, err := r.ExchangeContext(ctx, query)
302: 	if err != nil {
303: 		return nil, err
304: 	}
305: 
306: 	ips := msgToIP(msg)
307: 	if len(ips) != 0 {
308: 		return ips, nil
309: 	} else if len(r.searchDomains) == 0 {
310: 		return nil, resolver.ErrIPNotFound
311: 	}
312: 
313: 	// query provided search domains serially
314: 	for _, domain := range r.searchDomains {
315: 		q := &D.Msg{}
316: 		q.SetQuestion(D.Fqdn(fmt.Sprintf("%s.%s", host, domain)), dnsType)
317: 		msg, err := r.ExchangeContext(ctx, q)
318: 		if err != nil {
319: 			return nil, err
320: 		}
321: 		ips := msgToIP(msg)
322: 		if len(ips) != 0 {
323: 			return ips, nil
324: 		}
325: 	}
326: 
327: 	return nil, resolver.ErrIPNotFound
328: }
329: 
330: func (r *Resolver) msgToDomain(msg *D.Msg) string {
331: 	if len(msg.Question) > 0 {
332: 		return strings.TrimRight(msg.Question[0].Name, ".")
333: 	}
334: 
335: 	return ""
336: }
337: 
338: func (r *Resolver) asyncExchange(ctx context.Context, client []dnsClient, msg *D.Msg) <-chan *result {
339: 	ch := make(chan *result, 1)
340: 	go func() {
341: 		res, err := r.batchExchange(ctx, client, msg)
342: 		ch <- &result{Msg: res, Error: err}
343: 	}()
344: 	return ch
345: }
346: 
347: type NameServer struct {
348: 	Net       string
349: 	Addr      string
350: 	Interface string
351: }
352: 
353: type FallbackFilter struct {
354: 	GeoIP     bool
355: 	GeoIPCode string
356: 	IPCIDR    []*net.IPNet
357: 	Domain    []string
358: }
359: 
360: type Config struct {
361: 	Main, Fallback []NameServer
362: 	Default        []NameServer
363: 	IPv6           bool
364: 	EnhancedMode   C.DNSMode
365: 	FallbackFilter FallbackFilter
366: 	Pool           *fakeip.Pool
367: 	Hosts          *trie.DomainTrie
368: 	Policy         map[string]NameServer
369: 	SearchDomains  []string
370: }
371: 
372: func NewResolver(config Config) *Resolver {
373: 	defaultResolver := &Resolver{
374: 		main:     transform(config.Default, nil),
375: 		lruCache: cache.New(cache.WithSize(4096), cache.WithStale(true)),
376: 	}
377: 
378: 	r := &Resolver{
379: 		ipv6:          config.IPv6,
380: 		main:          transform(config.Main, defaultResolver),
381: 		lruCache:      cache.New(cache.WithSize(4096), cache.WithStale(true)),
382: 		hosts:         config.Hosts,
383: 		searchDomains: config.SearchDomains,
384: 	}
385: 
386: 	if len(config.Fallback) != 0 {
387: 		r.fallback = transform(config.Fallback, defaultResolver)
388: 	}
389: 
390: 	if len(config.Policy) != 0 {
391: 		r.policy = trie.New()
392: 		for domain, nameserver := range config.Policy {
393: 			r.policy.Insert(domain, transform([]NameServer{nameserver}, defaultResolver))
394: 		}
395: 	}
396: 
397: 	fallbackIPFilters := []fallbackIPFilter{}
398: 	if config.FallbackFilter.GeoIP {
399: 		fallbackIPFilters = append(fallbackIPFilters, &geoipFilter{
400: 			code: config.FallbackFilter.GeoIPCode,
401: 		})
402: 	}
403: 	for _, ipnet := range config.FallbackFilter.IPCIDR {
404: 		fallbackIPFilters = append(fallbackIPFilters, &ipnetFilter{ipnet: ipnet})
405: 	}
406: 	r.fallbackIPFilters = fallbackIPFilters
407: 
408: 	if len(config.FallbackFilter.Domain) != 0 {
409: 		fallbackDomainFilters := []fallbackDomainFilter{NewDomainFilter(config.FallbackFilter.Domain)}
410: 		r.fallbackDomainFilters = fallbackDomainFilters
411: 	}
412: 
413: 	return r
414: }


./dns\server.go
1: package dns
2: 
3: import (
4: 	"errors"
5: 	"net"
6: 
7: 	"github.com/Dreamacro/clash/common/sockopt"
8: 	"github.com/Dreamacro/clash/context"
9: 	"github.com/Dreamacro/clash/log"
10: 
11: 	D "github.com/miekg/dns"
12: )
13: 
14: var (
15: 	address string
16: 	server  = &Server{}
17: 
18: 	dnsDefaultTTL uint32 = 600
19: )
20: 
21: type Server struct {
22: 	*D.Server
23: 	handler handler
24: }
25: 
26: // ServeDNS implement D.Handler ServeDNS
27: func (s *Server) ServeDNS(w D.ResponseWriter, r *D.Msg) {
28: 	msg, err := handlerWithContext(s.handler, r)
29: 	if err != nil {
30: 		D.HandleFailed(w, r)
31: 		return
32: 	}
33: 	msg.Compress = true
34: 	w.WriteMsg(msg)
35: }
36: 
37: func handlerWithContext(handler handler, msg *D.Msg) (*D.Msg, error) {
38: 	if len(msg.Question) == 0 {
39: 		return nil, errors.New("at least one question is required")
40: 	}
41: 
42: 	ctx := context.NewDNSContext(msg)
43: 	return handler(ctx, msg)
44: }
45: 
46: func (s *Server) setHandler(handler handler) {
47: 	s.handler = handler
48: }
49: 
50: func ReCreateServer(addr string, resolver *Resolver, mapper *ResolverEnhancer) {
51: 	if addr == address && resolver != nil {
52: 		handler := newHandler(resolver, mapper)
53: 		server.setHandler(handler)
54: 		return
55: 	}
56: 
57: 	if server.Server != nil {
58: 		server.Shutdown()
59: 		server = &Server{}
60: 		address = ""
61: 	}
62: 
63: 	if addr == "" {
64: 		return
65: 	}
66: 
67: 	var err error
68: 	defer func() {
69: 		if err != nil {
70: 			log.Errorln("Start DNS server error: %s", err.Error())
71: 		}
72: 	}()
73: 
74: 	_, port, err := net.SplitHostPort(addr)
75: 	if port == "0" || port == "" || err != nil {
76: 		return
77: 	}
78: 
79: 	udpAddr, err := net.ResolveUDPAddr("udp", addr)
80: 	if err != nil {
81: 		return
82: 	}
83: 
84: 	p, err := net.ListenUDP("udp", udpAddr)
85: 	if err != nil {
86: 		return
87: 	}
88: 
89: 	err = sockopt.UDPReuseaddr(p)
90: 	if err != nil {
91: 		log.Warnln("Failed to Reuse UDP Address: %s", err)
92: 
93: 		err = nil
94: 	}
95: 
96: 	address = addr
97: 	handler := newHandler(resolver, mapper)
98: 	server = &Server{handler: handler}
99: 	server.Server = &D.Server{Addr: addr, PacketConn: p, Handler: server}
100: 
101: 	go func() {
102: 		server.ActivateAndServe()
103: 	}()
104: 
105: 	log.Infoln("DNS server listening at: %s", p.LocalAddr().String())
106: }


./dns\util.go
1: package dns
2: 
3: import (
4: 	"context"
5: 	"crypto/tls"
6: 	"errors"
7: 	"fmt"
8: 	"net"
9: 	"strings"
10: 	"time"
11: 
12: 	"github.com/Dreamacro/clash/common/cache"
13: 	"github.com/Dreamacro/clash/common/picker"
14: 	"github.com/Dreamacro/clash/log"
15: 
16: 	D "github.com/miekg/dns"
17: 	"github.com/samber/lo"
18: )
19: 
20: const serverFailureCacheTTL uint32 = 5
21: 
22: func minimalTTL(records []D.RR) uint32 {
23: 	rr := lo.MinBy(records, func(r1 D.RR, r2 D.RR) bool {
24: 		return r1.Header().Ttl < r2.Header().Ttl
25: 	})
26: 	if rr == nil {
27: 		return 0
28: 	}
29: 	return rr.Header().Ttl
30: }
31: 
32: func updateTTL(records []D.RR, ttl uint32) {
33: 	if len(records) == 0 {
34: 		return
35: 	}
36: 	delta := minimalTTL(records) - ttl
37: 	for i := range records {
38: 		records[i].Header().Ttl = lo.Clamp(records[i].Header().Ttl-delta, 1, records[i].Header().Ttl)
39: 	}
40: }
41: 
42: func putMsgToCache(c *cache.LruCache, key string, q D.Question, msg *D.Msg) {
43: 	// skip dns cache for acme challenge
44: 	if q.Qtype == D.TypeTXT && strings.HasPrefix(q.Name, "_acme-challenge.") {
45: 		log.Debugln("[DNS] dns cache ignored because of acme challenge for: %s", q.Name)
46: 		return
47: 	}
48: 
49: 	var ttl uint32
50: 	if msg.Rcode == D.RcodeServerFailure {
51: 		// [...] a resolver MAY cache a server failure response.
52: 		// If it does so it MUST NOT cache it for longer than five (5) minutes [...]
53: 		ttl = serverFailureCacheTTL
54: 	} else {
55: 		ttl = minimalTTL(append(append(msg.Answer, msg.Ns...), msg.Extra...))
56: 	}
57: 	if ttl == 0 {
58: 		return
59: 	}
60: 	c.SetWithExpire(key, msg.Copy(), time.Now().Add(time.Duration(ttl)*time.Second))
61: }
62: 
63: func setMsgTTL(msg *D.Msg, ttl uint32) {
64: 	for _, answer := range msg.Answer {
65: 		answer.Header().Ttl = ttl
66: 	}
67: 
68: 	for _, ns := range msg.Ns {
69: 		ns.Header().Ttl = ttl
70: 	}
71: 
72: 	for _, extra := range msg.Extra {
73: 		extra.Header().Ttl = ttl
74: 	}
75: }
76: 
77: func updateMsgTTL(msg *D.Msg, ttl uint32) {
78: 	updateTTL(msg.Answer, ttl)
79: 	updateTTL(msg.Ns, ttl)
80: 	updateTTL(msg.Extra, ttl)
81: }
82: 
83: func isIPRequest(q D.Question) bool {
84: 	return q.Qclass == D.ClassINET && (q.Qtype == D.TypeA || q.Qtype == D.TypeAAAA)
85: }
86: 
87: func transform(servers []NameServer, resolver *Resolver) []dnsClient {
88: 	ret := []dnsClient{}
89: 	for _, s := range servers {
90: 		switch s.Net {
91: 		case "https":
92: 			ret = append(ret, newDoHClient(s.Addr, s.Interface, resolver))
93: 			continue
94: 		case "dhcp":
95: 			ret = append(ret, newDHCPClient(s.Addr))
96: 			continue
97: 		}
98: 
99: 		host, port, _ := net.SplitHostPort(s.Addr)
100: 		ret = append(ret, &client{
101: 			Client: &D.Client{
102: 				Net: s.Net,
103: 				TLSConfig: &tls.Config{
104: 					ServerName: host,
105: 				},
106: 				UDPSize: 4096,
107: 				Timeout: 5 * time.Second,
108: 			},
109: 			port:  port,
110: 			host:  host,
111: 			iface: s.Interface,
112: 			r:     resolver,
113: 		})
114: 	}
115: 	return ret
116: }
117: 
118: func handleMsgWithEmptyAnswer(r *D.Msg) *D.Msg {
119: 	msg := &D.Msg{}
120: 	msg.Answer = []D.RR{}
121: 
122: 	msg.SetRcode(r, D.RcodeSuccess)
123: 	msg.Authoritative = true
124: 	msg.RecursionAvailable = true
125: 
126: 	return msg
127: }
128: 
129: func msgToIP(msg *D.Msg) []net.IP {
130: 	ips := []net.IP{}
131: 
132: 	for _, answer := range msg.Answer {
133: 		switch ans := answer.(type) {
134: 		case *D.AAAA:
135: 			ips = append(ips, ans.AAAA)
136: 		case *D.A:
137: 			ips = append(ips, ans.A)
138: 		}
139: 	}
140: 
141: 	return ips
142: }
143: 
144: func batchExchange(ctx context.Context, clients []dnsClient, m *D.Msg) (msg *D.Msg, err error) {
145: 	fast, ctx := picker.WithContext(ctx)
146: 	for _, client := range clients {
147: 		r := client
148: 		fast.Go(func() (any, error) {
149: 			m, err := r.ExchangeContext(ctx, m)
150: 			if err != nil {
151: 				return nil, err
152: 			} else if m.Rcode == D.RcodeServerFailure || m.Rcode == D.RcodeRefused {
153: 				return nil, errors.New("server failure")
154: 			}
155: 			return m, nil
156: 		})
157: 	}
158: 
159: 	elm := fast.Wait()
160: 	if elm == nil {
161: 		err := errors.New("all DNS requests failed")
162: 		if fErr := fast.Error(); fErr != nil {
163: 			err = fmt.Errorf("%w, first error: %s", err, fErr.Error())
164: 		}
165: 		return nil, err
166: 	}
167: 
168: 	msg = elm.(*D.Msg)
169: 	return
170: }


./docs\index.md
1: <!-- This is the index page, linked by the dummy sidebar item at Introduction/_dummy-index.md -->
2: # What is Clash?
3: 
4: Welcome to the official knowledge base of the Clash core project ("Clash").
5: 
6: Clash is a cross-platform rule-based proxy utility that runs on the network and application layer, supporting various proxy and anti-censorship protocols out-of-the-box.
7: 
8: It has been adopted widely by the Internet users in some countries and regions where the Internet is heavily censored or blocked. Either way, Clash can be used by anyone who wants to improve their Internet experience.
9: 
10: There are currently two editions of Clash:
11: 
12: - [Clash](https://github.com/Dreamacro/clash): the open-source version released at [github.com/Dreamacro/clash](https://github.com/Dreamacro/clash)
13: - [Clash Premium](https://github.com/Dreamacro/clash/releases/tag/premium): proprietary core with [TUN support and more](/premium/introduction) (free of charge)
14: 
15: While this wiki covers both, however, the use of Clash could be challenging for the average users. Those might want to consider using a GUI client instead, and we do have some recommendations:
16: 
17: - [Clash for Windows](https://github.com/Fndroid/clash_for_windows_pkg/releases) (Windows and macOS)
18: - [Clash for Android](https://github.com/Kr328/ClashForAndroid)
19: - [ClashX](https://github.com/yichengchen/clashX) or [ClashX Pro](https://install.appcenter.ms/users/clashx/apps/clashx-pro/distribution_groups/public) (macOS)
20: 
21: ## Feature Overview
22: 
23: - Inbound: HTTP, HTTPS, SOCKS5 server, TUN device*
24: - Outbound: Shadowsocks(R), VMess, Trojan, Snell, SOCKS5, HTTP(S), Wireguard*
25: - Rule-based Routing: dynamic scripting, domain, IP addresses, process name and more*
26: - Fake-IP DNS: minimises impact on DNS pollution and improves network performance
27: - Transparent Proxy: Redirect TCP and TProxy TCP/UDP with automatic route table/rule management*
28: - Proxy Groups: automatic fallback, load balancing or latency testing
29: - Remote Providers: load remote proxy lists dynamically
30: - RESTful API: update configuration in-place via a comprehensive API
31: 
32: <!-- markdownlint-disable MD033 -->
33: <small>\*: Only available in the free-of-charge Premium edition.</small>
34: <!-- markdownlint-enable MD033 -->
35: 
36: ## License
37: 
38: Clash is released under the [GPL-3.0](https://github.com/Dreamacro/clash/blob/master/LICENSE) open-source license. Prior to [v0.16.0](https://github.com/Dreamacro/clash/releases/tag/v0.16.0) or commit [e5284c](https://github.com/Dreamacro/clash/commit/e5284cf647717a8087a185d88d15a01096274bc2), it was licensed under the MIT license.


./docs\package.json
1: {
2:   "type": "module",
3:   "scripts": {
4:     "docs:dev": "vitepress dev",
5:     "docs:build": "vitepress build",
6:     "docs:preview": "vitepress preview"
7:   },
8:   "devDependencies": {
9:     "@types/node": "^20.5.0",
10:     "directory-tree": "^3.5.1",
11:     "markdown-yaml-metadata-parser": "^3.0.0",
12:     "vitepress": "1.0.0-rc.4"
13:   }
14: }


./docs\.vitepress\config.ts
1: import { defineConfig } from 'vitepress'
2: import locales from './locales'
3: 
4: // https://vitepress.dev/reference/site-config
5: export default defineConfig({
6:   title: 'Clash',
7: 
8:   base: '/clash/',
9: 
10:   head: [
11:     [
12:       'link',
13:       { rel: 'icon', type: "image/x-icon", href: '/clash/logo.png' }
14:     ],
15:   ],
16: 
17:   locales: locales.locales,
18: 
19:   lastUpdated: true,
20: 
21:   themeConfig: {
22:     search: {
23:       provider: 'local',
24:       options: {
25:         locales: {
26:           zh_CN: {
27:             translations: {
28:               button: {
29:                 buttonText: '搜索文档',
30:                 buttonAriaLabel: '搜索文档'
31:               },
32:               modal: {
33:                 noResultsText: '无法找到相关结果',
34:                 resetButtonTitle: '清除查询条件',
35:                 footer: {
36:                   selectText: '选择',
37:                   navigateText: '切换'
38:                 }
39:               }
40:             }
41:           }
42:         },
43: 
44:       }
45:     }
46:   },
47: })


./docs\.vitepress\locales\en_US.ts
1: import { createRequire } from 'module'
2: import { defineConfig } from 'vitepress'
3: import { generateSidebarChapter } from './side_bar.js'
4: 
5: const require = createRequire(import.meta.url)
6: 
7: const chapters = generateSidebarChapter('en_US', new Map([
8:   ['introduction', 'Introduction'],
9:   ['configuration', 'Configuration'],
10:   ['premium', 'Premium'],
11:   ['runtime', 'Runtime'],
12:   ['advanced-usages', 'Advanced Usages'],
13: ]))
14: 
15: export default defineConfig({
16:   lang: 'en-US',
17: 
18:   description: 'A rule-based tunnel in Go.',
19: 
20:   themeConfig: {
21:     nav: nav(),
22: 
23:     logo: '/logo.png',
24: 
25:     lastUpdatedText: 'Last updated at',
26: 
27:     sidebar: chapters,
28: 
29:     socialLinks: [
30:       { icon: 'github', link: 'https://github.com/Dreamacro/clash' },
31:     ],
32: 
33:     editLink: {
34:       pattern: 'https://github.com/Dreamacro/clash/edit/master/docs/:path',
35:       text: 'Edit this page on GitHub'
36:     },
37: 
38:     outline: {
39:       level: 'deep',
40:       label: 'On this page',
41:     },
42: 
43:   }
44: })
45: 
46: function nav() {
47:   return [
48:     { text: 'Home', link: '/' },
49:     { text: 'Configuration', link: '/configuration/configuration-reference' },
50:     {
51:       text: 'Download',
52:       items: [
53:         { text: 'Open-source Edition', link: 'https://github.com/Dreamacro/clash/releases/' },
54:         { text: 'Premium Edition', link: 'https://github.com/Dreamacro/clash/releases/tag/premium' },
55:       ]
56:     }
57:   ]
58: }
59: 
60: 


./docs\.vitepress\locales\index.ts
1: import { defineConfig } from 'vitepress'
2: import en_US from './en_US'
3: import zh_CN from './zh_CN'
4: 
5: export default defineConfig({
6:   locales: {
7:     root: {
8:       label: 'English',
9:       lang: en_US.lang,
10:       themeConfig: en_US.themeConfig,
11:       description: en_US.description
12:     },
13:     zh_CN: {
14:       label: '简体中文',
15:       lang: zh_CN.lang,
16:       themeConfig: zh_CN.themeConfig,
17:       description: zh_CN.description
18:     }
19:   }
20: })

./docs\.vitepress\locales\side_bar.ts
1: import directoryTree from 'directory-tree'
2: import fs from 'fs'
3: import metadataParser from 'markdown-yaml-metadata-parser'
4: 
5: function getMetadataFromDoc(path: string): { sidebarTitle?: string, sidebarOrder?: number } {
6:   const fileContents = fs.readFileSync(path, 'utf8')
7: 
8:   return metadataParser(fileContents).metadata
9: }
10: 
11: export function generateSidebarChapter(locale:string, chapterDirName: Map<string,string>): any[] {
12:   if (chapterDirName.size < 1) {
13:     console.error(chapterDirName)
14:     throw new Error(`Could not genereate sidebar: chapterDirName is empty`)
15:   }
16: 
17:   var chapterPath = ''
18:   var sidebar: any[] = []
19: 
20:   for (const chapterDirKey of chapterDirName.keys()) {
21:     if (locale !== 'en_US') {
22:       chapterPath = `./${locale}/${chapterDirKey}`
23:     } else {
24:       chapterPath = `./${chapterDirKey}`
25:     }
26: 
27:     const tree = directoryTree(chapterPath)
28: 
29:     if (!tree || !tree.children) {
30:       console.error(tree)
31:       throw new Error(`Could not genereate sidebar: invalid chapter at ${chapterPath}`)
32:     }
33: 
34:     let items: { sidebarOrder: number, text: string, link: string }[] = []
35: 
36:     // Look into files in the chapter
37:     for (const doc of tree.children) {
38:       // make sure it's a .md file
39:       if (doc.children || !doc.name.endsWith('.md'))
40:         continue
41: 
42:       const { sidebarOrder, sidebarTitle } = getMetadataFromDoc(doc.path)
43: 
44:       if (!sidebarOrder)
45:         throw new Error('Cannot find sidebarOrder in doc metadata: ' + doc.path)
46: 
47:       if (!sidebarTitle)
48:         throw new Error('Cannot find sidebarTitle in doc metadata: ' + doc.path)
49: 
50:       if (chapterDirKey === 'introduction' && doc.name === '_dummy-index.md') {
51:         // Override index page link
52:         items.push({
53:           sidebarOrder,
54:           text: sidebarTitle,
55:           link: '/' + (locale === 'en_US' ? '' : locale + '/') 
56:         })
57:       } else {
58:         items.push({
59:           sidebarOrder,
60:           text: sidebarTitle,
61:           link: "/" + doc.path
62:         })
63:       }
64:     }
65: 
66:     items = items.sort((a, b) => a.sidebarOrder - b.sidebarOrder)
67: 
68:     // remove dash and capitalize first character of each word as chapter title
69:     const text = chapterDirName.get(chapterDirKey) || chapterDirKey.split('-').join(' ').replace(/\b\w/g, l => l.toUpperCase())
70:     sidebar.push({
71:       text,
72:       collapsed: false,
73:       items,
74:     })
75:   }
76: 
77:   return sidebar
78: }

./docs\.vitepress\locales\zh_CN.ts
1: import { createRequire } from 'module'
2: import { defineConfig } from 'vitepress'
3: import { generateSidebarChapter } from './side_bar.js'
4: 
5: const require = createRequire(import.meta.url)
6: 
7: const chapters = generateSidebarChapter('zh_CN', new Map([
8:   ['introduction', '简介'],
9:   ['configuration', '配置'],
10:   ['premium', 'Premium 版本'],
11:   ['runtime', '运行时'],
12:   ['advanced-usages', '高级用法'],
13: ]))
14: 
15: export default defineConfig({
16:   lang: 'zh-CN',
17: 
18:   description: '基于规则的 Go 网络隧道. ',
19: 
20:   themeConfig: {
21:     nav: nav(),
22: 
23:     logo: '/logo.png',
24: 
25:     lastUpdatedText: '最后更新于',
26: 
27:     sidebar: chapters,
28: 
29:     socialLinks: [
30:       { icon: 'github', link: 'https://github.com/Dreamacro/clash' },
31:     ],
32: 
33:     editLink: {
34:       pattern: 'https://github.com/Dreamacro/clash/edit/master/docs/:path',
35:       text: '在 GitHub 中编辑此页面'
36:     },
37: 
38:     docFooter: { prev: '上一篇', next: '下一篇' },
39: 
40:     outline: {
41:       level: 'deep',
42:       label: '页面导航',
43:     },
44: 
45:   }
46: })
47: 
48: function nav() {
49:   return [
50:     { text: '主页', link: '/zh_CN/' },
51:     { text: '配置', link: '/zh_CN/configuration/configuration-reference' },
52:     {
53:       text: '下载',
54:       items: [
55:         { text: 'GitHub 开源版', link: 'https://github.com/Dreamacro/clash/releases/' },
56:         { text: 'Premium 版本', link: 'https://github.com/Dreamacro/clash/releases/tag/premium' },
57:       ]
58:     }
59:   ]
60: }


./docs\advanced-usages\golang-api.md
1: ---
2: sidebarTitle: Integrating Clash in Golang Programs
3: sidebarOrder: 3
4: ---
5: 
6: # Integrating Clash in Golang Programs
7: 
8: If clash does not fit your own usage, you can use Clash in your own Golang code.
9: 
10: There is already basic support:
11: 
12: ```go
13: package main
14: 
15: import (
16: 	"context"
17: 	"fmt"
18: 	"io"
19: 	"net"
20: 
21: 	"github.com/Dreamacro/clash/adapter/outbound"
22: 	"github.com/Dreamacro/clash/constant"
23: 	"github.com/Dreamacro/clash/listener/socks"
24: )
25: 
26: func main() {
27: 	in := make(chan constant.ConnContext, 100)
28: 	defer close(in)
29: 
30: 	l, err := socks.New("127.0.0.1:10000", in)
31: 	if err != nil {
32: 		panic(err)
33: 	}
34: 	defer l.Close()
35: 
36: 	println("listen at:", l.Address())
37: 
38: 	direct := outbound.NewDirect()
39: 
40: 	for c := range in {
41: 		conn := c
42: 		metadata := conn.Metadata()
43: 		fmt.Printf("request incoming from %s to %s\n", metadata.SourceAddress(), metadata.RemoteAddress())
44: 		go func () {
45: 			remote, err := direct.DialContext(context.Background(), metadata)
46: 			if err != nil {
47: 				fmt.Printf("dial error: %s\n", err.Error())
48: 				return
49: 			}
50: 			relay(remote, conn.Conn())
51: 		}()
52: 	}
53: }
54: 
55: func relay(l, r net.Conn) {
56: 	go io.Copy(l, r)
57: 	io.Copy(r, l)
58: }
59: ```


./docs\advanced-usages\openconnect.md
1: ---
2: sidebarTitle: Rule-based OpenConnect
3: sidebarOrder: 2
4: ---
5: 
6: # Rule-based OpenConnect
7: 
8: OpenConnect supports Cisco AnyConnect SSL VPN, Juniper Network Connect, Palo Alto Networks (PAN) GlobalProtect SSL VPN, Pulse Connect Secure SSL VPN, F5 BIG-IP SSL VPN, FortiGate SSL VPN and Array Networks SSL VPN.
9: 
10: For example, there would be a use case where your company uses Cisco AnyConnect for internal network access. Here I'll show you how you can use OpenConnect with policy routing powered by Clash.
11: 
12: First, [install vpn-slice](https://github.com/dlenski/vpn-slice#requirements). This tool overrides default routing table behaviour of OpenConnect. Simply saying, it stops the VPN from overriding your default routes.
13: 
14: Next you would have a script (let's say `tun0.sh`) similar to this:
15: 
16: ```sh
17: #!/bin/bash
18: ANYCONNECT_HOST="vpn.example.com"
19: ANYCONNECT_USER="john"
20: ANYCONNECT_PASSWORD="foobar"
21: ROUTING_TABLE_ID="6667"
22: TUN_INTERFACE="tun0"
23: 
24: # Add --no-dtls if the server is in mainland China. UDP in China is choppy.
25: echo "$ANYCONNECT_PASSWORD" | \
26:   openconnect \
27:     --non-inter \
28:     --passwd-on-stdin \
29:     --protocol=anyconnect \
30:     --interface $TUN_INTERFACE \
31:     --script "vpn-slice
32: if [ \"\$reason\" = 'connect' ]; then
33:   ip rule add from \$INTERNAL_IP4_ADDRESS table $ROUTING_TABLE_ID
34:   ip route add default dev \$TUNDEV scope link table $ROUTING_TABLE_ID
35: elif [ \"\$reason\" = 'disconnect' ]; then
36:   ip rule del from \$INTERNAL_IP4_ADDRESS table $ROUTING_TABLE_ID
37:   ip route del default dev \$TUNDEV scope link table $ROUTING_TABLE_ID
38: fi" \
39:     --user $ANYCONNECT_USER \
40:     https://$ANYCONNECT_HOST
41: ```
42: 
43: After that, we configure it as a systemd service. Create `/etc/systemd/system/tun0.service`:
44: 
45: ```ini
46: [Unit]
47: Description=Cisco AnyConnect VPN
48: After=network-online.target
49: Conflicts=shutdown.target sleep.target
50: 
51: [Service]
52: Type=simple
53: ExecStart=/path/to/tun0.sh
54: KillSignal=SIGINT
55: Restart=always
56: RestartSec=3
57: StartLimitIntervalSec=0
58: 
59: [Install]
60: WantedBy=multi-user.target
61: ```
62: 
63: Then we enable & start the service.
64: 
65: ```shell
66: chmod +x /path/to/tun0.sh
67: systemctl daemon-reload
68: systemctl enable tun0
69: systemctl start tun0
70: ```
71: 
72: From here you can look at the logs to see if it's running properly. Simple way is to look at if `tun0` interface has been created.
73: 
74: Similar to the Wireguard one, having an outbound to a TUN device is simple as adding a proxy group:
75: 
76: ```yaml
77: proxy-groups:
78:   - name: Cisco AnyConnect VPN
79:     type: select
80:     interface-name: tun0
81:     proxies:
82:       - DIRECT
83: ```
84: 
85: ... and it's ready to use! Add the desired rules:
86: 
87: ```yaml
88: rules:
89:   - DOMAIN-SUFFIX,internal.company.com,Cisco AnyConnect VPN
90: ```
91: 
92: You should look at the debug level logs when something does not seem right.
93: 


./docs\advanced-usages\wireguard.md
1: ---
2: sidebarTitle: Rule-based Wireguard
3: sidebarOrder: 1
4: ---
5: 
6: # Rule-based Wireguard
7: 
8: Suppose your kernel supports Wireguard and you have it enabled. The `Table` option stops _wg-quick_ from overriding default routes.
9: 
10: Example `wg0.conf`:
11: 
12: ```ini
13: [Interface]
14: PrivateKey = ...
15: Address = 172.16.0.1/32
16: MTU = ...
17: Table = off
18: PostUp = ip rule add from 172.16.0.1/32 table 6666
19: 
20: [Peer]
21: AllowedIPs = 0.0.0.0/0
22: AllowedIPs = ::/0
23: PublicKey = ...
24: Endpoint = ...
25: ```
26: 
27: Then in Clash you would only need to have a DIRECT proxy group that has a specific outbound interface:
28: 
29: ```yaml
30: proxy-groups:
31:   - name: Wireguard
32:     type: select
33:     interface-name: wg0
34:     proxies:
35:       - DIRECT
36: rules:
37:   - DOMAIN,google.com,Wireguard
38: ```
39: 
40: This should perform better than whereas if Clash implemented its own userspace Wireguard client. Wireguard is supported in the kernel.


./docs\configuration\configuration-reference.md
1: ---
2: sidebarTitle: Configuration Reference
3: sidebarOrder: 7
4: ---
5: 
6: # Configuration Reference
7: 
8: ```yaml
9: # Port of HTTP(S) proxy server on the local end
10: port: 7890
11: 
12: # Port of SOCKS5 proxy server on the local end
13: socks-port: 7891
14: 
15: # Transparent proxy server port for Linux and macOS (Redirect TCP and TProxy UDP)
16: # redir-port: 7892
17: 
18: # Transparent proxy server port for Linux (TProxy TCP and TProxy UDP)
19: # tproxy-port: 7893
20: 
21: # HTTP(S) and SOCKS4(A)/SOCKS5 server on the same port
22: # mixed-port: 7890
23: 
24: # authentication of local SOCKS5/HTTP(S) server
25: # authentication:
26: #  - "user1:pass1"
27: #  - "user2:pass2"
28: 
29: # Set to true to allow connections to the local-end server from
30: # other LAN IP addresses
31: # allow-lan: false
32: 
33: # This is only applicable when `allow-lan` is `true`
34: # '*': bind all IP addresses
35: # 192.168.122.11: bind a single IPv4 address
36: # "[aaaa::a8aa:ff:fe09:57d8]": bind a single IPv6 address
37: # bind-address: '*'
38: 
39: # Clash router working mode
40: # rule: rule-based packet routing
41: # global: all packets will be forwarded to a single endpoint
42: # direct: directly forward the packets to the Internet
43: mode: rule
44: 
45: # Clash by default prints logs to STDOUT
46: # info / warning / error / debug / silent
47: # log-level: info
48: 
49: # When set to false, resolver won't translate hostnames to IPv6 addresses
50: # ipv6: false
51: 
52: # RESTful web API listening address
53: external-controller: 127.0.0.1:9090
54: 
55: # A relative path to the configuration directory or an absolute path to a
56: # directory in which you put some static web resource. Clash core will then
57: # serve it at `http://{{external-controller}}/ui`.
58: # external-ui: folder
59: 
60: # Secret for the RESTful API (optional)
61: # Authenticate by spedifying HTTP header `Authorization: Bearer ${secret}`
62: # ALWAYS set a secret if RESTful API is listening on 0.0.0.0
63: # secret: ""
64: 
65: # Outbound interface name
66: # interface-name: en0
67: 
68: # fwmark on Linux only
69: # routing-mark: 6666
70: 
71: # Static hosts for DNS server and connection establishment (like /etc/hosts)
72: #
73: # Wildcard hostnames are supported (e.g. *.clash.dev, *.foo.*.example.com)
74: # Non-wildcard domain names have a higher priority than wildcard domain names
75: # e.g. foo.example.com > *.example.com > .example.com
76: # P.S. +.foo.com equals to .foo.com and foo.com
77: # hosts:
78:   # '*.clash.dev': 127.0.0.1
79:   # '.dev': 127.0.0.1
80:   # 'alpha.clash.dev': '::1'
81: 
82: # profile:
83:   # Store the `select` results in $HOME/.config/clash/.cache
84:   # set false If you don't want this behavior
85:   # when two different configurations have groups with the same name, the selected values are shared
86:   # store-selected: true
87: 
88:   # persistence fakeip
89:   # store-fake-ip: false
90: 
91: # DNS server settings
92: # This section is optional. When not present, the DNS server will be disabled.
93: dns:
94:   enable: false
95:   listen: 0.0.0.0:53
96:   # ipv6: false # when the false, response to AAAA questions will be empty
97: 
98:   # These nameservers are used to resolve the DNS nameserver hostnames below.
99:   # Specify IP addresses only
100:   default-nameserver:
101:     - 114.114.114.114
102:     - 8.8.8.8
103:   # enhanced-mode: fake-ip
104:   fake-ip-range: 198.18.0.1/16 # Fake IP addresses pool CIDR
105:   # use-hosts: true # lookup hosts and return IP record
106: 
107:   # search-domains: [local] # search domains for A/AAAA record
108: 
109:   # Hostnames in this list will not be resolved with fake IPs
110:   # i.e. questions to these domain names will always be answered with their
111:   # real IP addresses
112:   # fake-ip-filter:
113:   #   - '*.lan'
114:   #   - localhost.ptlogin2.qq.com
115: 
116:   # Supports UDP, TCP, DoT, DoH. You can specify the port to connect to.
117:   # All DNS questions are sent directly to the nameserver, without proxies
118:   # involved. Clash answers the DNS question with the first result gathered.
119:   nameserver:
120:     - 114.114.114.114 # default value
121:     - 8.8.8.8 # default value
122:     - tls://dns.rubyfish.cn:853 # DNS over TLS
123:     - https://1.1.1.1/dns-query # DNS over HTTPS
124:     - dhcp://en0 # dns from dhcp
125:     # - '8.8.8.8#en0'
126: 
127:   # When `fallback` is present, the DNS server will send concurrent requests
128:   # to the servers in this section along with servers in `nameservers`.
129:   # The answers from fallback servers are used when the GEOIP country
130:   # is not `CN`.
131:   # fallback:
132:   #   - tcp://1.1.1.1
133:   #   - 'tcp://1.1.1.1#en0'
134: 
135:   # If IP addresses resolved with servers in `nameservers` are in the specified
136:   # subnets below, they are considered invalid and results from `fallback`
137:   # servers are used instead.
138:   #
139:   # IP address resolved with servers in `nameserver` is used when
140:   # `fallback-filter.geoip` is true and when GEOIP of the IP address is `CN`.
141:   #
142:   # If `fallback-filter.geoip` is false, results from `nameserver` nameservers
143:   # are always used if not match `fallback-filter.ipcidr`.
144:   #
145:   # This is a countermeasure against DNS pollution attacks.
146:   # fallback-filter:
147:   #   geoip: true
148:   #   geoip-code: CN
149:   #   ipcidr:
150:   #     - 240.0.0.0/4
151:   #   domain:
152:   #     - '+.google.com'
153:   #     - '+.facebook.com'
154:   #     - '+.youtube.com'
155: 
156:   # Lookup domains via specific nameservers
157:   # nameserver-policy:
158:   #   'www.baidu.com': '114.114.114.114'
159:   #   '+.internal.crop.com': '10.0.0.1'
160: 
161: proxies:
162:   # Shadowsocks
163:   # The supported ciphers (encryption methods):
164:   #   aes-128-gcm aes-192-gcm aes-256-gcm
165:   #   aes-128-cfb aes-192-cfb aes-256-cfb
166:   #   aes-128-ctr aes-192-ctr aes-256-ctr
167:   #   rc4-md5 chacha20-ietf xchacha20
168:   #   chacha20-ietf-poly1305 xchacha20-ietf-poly1305
169:   - name: "ss1"
170:     type: ss
171:     server: server
172:     port: 443
173:     cipher: chacha20-ietf-poly1305
174:     password: "password"
175:     # udp: true
176: 
177:   - name: "ss2"
178:     type: ss
179:     server: server
180:     port: 443
181:     cipher: chacha20-ietf-poly1305
182:     password: "password"
183:     plugin: obfs
184:     plugin-opts:
185:       mode: tls # or http
186:       # host: bing.com
187: 
188:   - name: "ss3"
189:     type: ss
190:     server: server
191:     port: 443
192:     cipher: chacha20-ietf-poly1305
193:     password: "password"
194:     plugin: v2ray-plugin
195:     plugin-opts:
196:       mode: websocket # no QUIC now
197:       # tls: true # wss
198:       # skip-cert-verify: true
199:       # host: bing.com
200:       # path: "/"
201:       # mux: true
202:       # headers:
203:       #   custom: value
204: 
205:   # vmess
206:   # cipher support auto/aes-128-gcm/chacha20-poly1305/none
207:   - name: "vmess"
208:     type: vmess
209:     server: server
210:     port: 443
211:     uuid: uuid
212:     alterId: 32
213:     cipher: auto
214:     # udp: true
215:     # tls: true
216:     # skip-cert-verify: true
217:     # servername: example.com # priority over wss host
218:     # network: ws
219:     # ws-opts:
220:     #   path: /path
221:     #   headers:
222:     #     Host: v2ray.com
223:     #   max-early-data: 2048
224:     #   early-data-header-name: Sec-WebSocket-Protocol
225: 
226:   - name: "vmess-h2"
227:     type: vmess
228:     server: server
229:     port: 443
230:     uuid: uuid
231:     alterId: 32
232:     cipher: auto
233:     network: h2
234:     tls: true
235:     h2-opts:
236:       host:
237:         - http.example.com
238:         - http-alt.example.com
239:       path: /
240: 
241:   - name: "vmess-http"
242:     type: vmess
243:     server: server
244:     port: 443
245:     uuid: uuid
246:     alterId: 32
247:     cipher: auto
248:     # udp: true
249:     # network: http
250:     # http-opts:
251:     #   # method: "GET"
252:     #   # path:
253:     #   #   - '/'
254:     #   #   - '/video'
255:     #   # headers:
256:     #   #   Connection:
257:     #   #     - keep-alive
258: 
259:   - name: vmess-grpc
260:     server: server
261:     port: 443
262:     type: vmess
263:     uuid: uuid
264:     alterId: 32
265:     cipher: auto
266:     network: grpc
267:     tls: true
268:     servername: example.com
269:     # skip-cert-verify: true
270:     grpc-opts:
271:       grpc-service-name: "example"
272: 
273:   # socks5
274:   - name: "socks"
275:     type: socks5
276:     server: server
277:     port: 443
278:     # username: username
279:     # password: password
280:     # tls: true
281:     # skip-cert-verify: true
282:     # udp: true
283: 
284:   # http
285:   - name: "http"
286:     type: http
287:     server: server
288:     port: 443
289:     # username: username
290:     # password: password
291:     # tls: true # https
292:     # skip-cert-verify: true
293:     # sni: custom.com
294: 
295:   # Snell
296:   # Beware that there's currently no UDP support yet
297:   - name: "snell"
298:     type: snell
299:     server: server
300:     port: 44046
301:     psk: yourpsk
302:     # version: 2
303:     # obfs-opts:
304:       # mode: http # or tls
305:       # host: bing.com
306: 
307:   # Trojan
308:   - name: "trojan"
309:     type: trojan
310:     server: server
311:     port: 443
312:     password: yourpsk
313:     # udp: true
314:     # sni: example.com # aka server name
315:     # alpn:
316:     #   - h2
317:     #   - http/1.1
318:     # skip-cert-verify: true
319: 
320:   - name: trojan-grpc
321:     server: server
322:     port: 443
323:     type: trojan
324:     password: "example"
325:     network: grpc
326:     sni: example.com
327:     # skip-cert-verify: true
328:     udp: true
329:     grpc-opts:
330:       grpc-service-name: "example"
331: 
332:   - name: trojan-ws
333:     server: server
334:     port: 443
335:     type: trojan
336:     password: "example"
337:     network: ws
338:     sni: example.com
339:     # skip-cert-verify: true
340:     udp: true
341:     # ws-opts:
342:       # path: /path
343:       # headers:
344:       #   Host: example.com
345: 
346:   # ShadowsocksR
347:   # The supported ciphers (encryption methods): all stream ciphers in ss
348:   # The supported obfses:
349:   #   plain http_simple http_post
350:   #   random_head tls1.2_ticket_auth tls1.2_ticket_fastauth
351:   # The supported supported protocols:
352:   #   origin auth_sha1_v4 auth_aes128_md5
353:   #   auth_aes128_sha1 auth_chain_a auth_chain_b
354:   - name: "ssr"
355:     type: ssr
356:     server: server
357:     port: 443
358:     cipher: chacha20-ietf
359:     password: "password"
360:     obfs: tls1.2_ticket_auth
361:     protocol: auth_sha1_v4
362:     # obfs-param: domain.tld
363:     # protocol-param: "#"
364:     # udp: true
365: 
366: proxy-groups:
367:   # relay chains the proxies. proxies shall not contain a relay. No UDP support.
368:   # Traffic: clash <-> http <-> vmess <-> ss1 <-> ss2 <-> Internet
369:   - name: "relay"
370:     type: relay
371:     proxies:
372:       - http
373:       - vmess
374:       - ss1
375:       - ss2
376: 
377:   # url-test select which proxy will be used by benchmarking speed to a URL.
378:   - name: "auto"
379:     type: url-test
380:     proxies:
381:       - ss1
382:       - ss2
383:       - vmess1
384:     # tolerance: 150
385:     # lazy: true
386:     url: 'http://www.gstatic.com/generate_204'
387:     interval: 300
388: 
389:   # fallback selects an available policy by priority. The availability is tested by accessing an URL, just like an auto url-test group.
390:   - name: "fallback-auto"
391:     type: fallback
392:     proxies:
393:       - ss1
394:       - ss2
395:       - vmess1
396:     url: 'http://www.gstatic.com/generate_204'
397:     interval: 300
398: 
399:   # load-balance: The request of the same eTLD+1 will be dial to the same proxy.
400:   - name: "load-balance"
401:     type: load-balance
402:     proxies:
403:       - ss1
404:       - ss2
405:       - vmess1
406:     url: 'http://www.gstatic.com/generate_204'
407:     interval: 300
408:     # strategy: consistent-hashing # or round-robin
409: 
410:   # select is used for selecting proxy or proxy group
411:   # you can use RESTful API to switch proxy is recommended for use in GUI.
412:   - name: Proxy
413:     type: select
414:     # disable-udp: true
415:     # filter: 'someregex'
416:     proxies:
417:       - ss1
418:       - ss2
419:       - vmess1
420:       - auto
421: 
422:   # direct to another interfacename or fwmark, also supported on proxy
423:   - name: en1
424:     type: select
425:     interface-name: en1
426:     routing-mark: 6667
427:     proxies:
428:       - DIRECT
429: 
430:   - name: UseProvider
431:     type: select
432:     use:
433:       - provider1
434:     proxies:
435:       - Proxy
436:       - DIRECT
437: 
438: proxy-providers:
439:   provider1:
440:     type: http
441:     url: "url"
442:     interval: 3600
443:     path: ./provider1.yaml
444:     health-check:
445:       enable: true
446:       interval: 600
447:       # lazy: true
448:       url: http://www.gstatic.com/generate_204
449:   test:
450:     type: file
451:     path: /test.yaml
452:     health-check:
453:       enable: true
454:       interval: 36000
455:       url: http://www.gstatic.com/generate_204
456: 
457: tunnels:
458:   # one line config
459:   - tcp/udp,127.0.0.1:6553,114.114.114.114:53,proxy
460:   - tcp,127.0.0.1:6666,rds.mysql.com:3306,vpn
461:   # full yaml config
462:   - network: [tcp, udp]
463:     address: 127.0.0.1:7777
464:     target: target.com
465:     proxy: proxy
466: 
467: rules:
468:   - DOMAIN-SUFFIX,google.com,auto
469:   - DOMAIN-KEYWORD,google,auto
470:   - DOMAIN,google.com,auto
471:   - DOMAIN-SUFFIX,ad.com,REJECT
472:   - SRC-IP-CIDR,192.168.1.201/32,DIRECT
473:   # optional param "no-resolve" for IP rules (GEOIP, IP-CIDR, IP-CIDR6)
474:   - IP-CIDR,127.0.0.0/8,DIRECT
475:   - GEOIP,CN,DIRECT
476:   - DST-PORT,80,DIRECT
477:   - SRC-PORT,7777,DIRECT
478:   - RULE-SET,apple,REJECT # Premium only
479:   - MATCH,auto
480: ```


./docs\configuration\dns.md
1: ---
2: sidebarTitle: Clash DNS
3: sidebarOrder: 6
4: ---
5: 
6: # Clash DNS
7: 
8: Since some parts of Clash run on the Layer 3 (Network Layer), they would've been impossible to obtain domain names of the packets for rule-based routing.
9: 
10: *Enter fake-ip*. It enables rule-based routing, minimises the impact of DNS pollution attack and improves network performance, sometimes drastically.
11: 
12: ## fake-ip
13: 
14: The concept of "fake IP" addresses is originated from [RFC 3089](https://tools.ietf.org/rfc/rfc3089):
15: 
16: > A "fake IP" address is used as a key to look up the corresponding "FQDN" information.
17: 
18: The default CIDR for the fake-ip pool is `198.18.0.1/16`, a reserved IPv4 address space, which can be changed in `dns.fake-ip-range`.
19: 
20: When a DNS request is sent to the Clash DNS, the core allocates a *free* fake-ip address from the pool, by managing an internal mapping of domain names and their fake-ip addresses.
21: 
22: Take an example of accessing `http://google.com` with your browser.
23: 
24: 1. The browser asks Clash DNS for the IP address of `google.com`
25: 2. Clash checks the internal mapping and returned `198.18.1.5`
26: 3. The browser sends an HTTP request to `198.18.1.5` on `80/tcp`
27: 4. When receiving the inbound packet for `198.18.1.5`, Clash looks up the internal mapping and realises the client is actually sending a packet to `google.com`
28: 5. Depending on the rules:
29: 
30:     1. Clash may just send the domain name to an outbound proxy like SOCKS5 or shadowsocks and establish the connection with the proxy server
31: 
32:     2. or Clash might look for the real IP address of `google.com`, in the case of encountering a `SCRIPT`, `GEOIP`, `IP-CIDR` rule, or the case of DIRECT outbound
33: 
34: Being a confusing concept, I'll take another example of accessing `http://google.com` with the cURL utility:
35: 
36: ```txt{2,3,5,6,8,9}
37: $ curl -v http://google.com
38: <---- cURL asks your system DNS (Clash) about the IP address of google.com
39: ----> Clash decided 198.18.1.70 should be used as google.com and remembers it
40: *   Trying 198.18.1.70:80...
41: <---- cURL connects to 198.18.1.70 tcp/80
42: ----> Clash will accept the connection immediately, and..
43: * Connected to google.com (198.18.1.70) port 80 (#0)
44: ----> Clash looks up in its memory and found 198.18.1.70 being google.com
45: ----> Clash looks up in the rules and sends the packet via the matching outbound
46: > GET / HTTP/1.1
47: > Host: google.com
48: > User-Agent: curl/8.0.1
49: > Accept: */*
50: > 
51: < HTTP/1.1 301 Moved Permanently
52: < Location: http://www.google.com/
53: < Content-Type: text/html; charset=UTF-8
54: < Content-Security-Policy-Report-Only: object-src 'none';base-uri 'self';script-src 'nonce-ahELFt78xOoxhySY2lQ34A' 'strict-dynamic' 'report-sample' 'unsafe-eval' 'unsafe-inline' https: http:;report-uri https://csp.withgoogle.com/csp/gws/other-hp
55: < Date: Thu, 11 May 2023 06:52:19 GMT
56: < Expires: Sat, 10 Jun 2023 06:52:19 GMT
57: < Cache-Control: public, max-age=2592000
58: < Server: gws
59: < Content-Length: 219
60: < X-XSS-Protection: 0
61: < X-Frame-Options: SAMEORIGIN
62: < 
63: <HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
64: <TITLE>301 Moved</TITLE></HEAD><BODY>
65: <H1>301 Moved</H1>
66: The document has moved
67: <A HREF="http://www.google.com/">here</A>.
68: </BODY></HTML>
69: * Connection #0 to host google.com left intact
70: ```
71: 
72: <!-- TODO: nameserver, fallback, fallback-filter, hosts, search-domains, fake-ip-filter, nameserver-policy -->


./docs\configuration\getting-started.md
1: ---
2: sidebarTitle: Getting Started
3: sidebarOrder: 2
4: ---
5: 
6: # Getting Started
7: 
8: It's recommended that you read the [Introduction](/configuration/introduction) before proceeding. After you have a brief understanding of how Clash works, you can start writing your own configuration.
9: 
10: ## Configuration Files
11: 
12: The main configuration file is called `config.yaml`. By default, Clash reads the configuration files at `$HOME/.config/clash`. If it doesn't exist, Clash will generate a minimal configuration file at that location.
13: 
14: If you want to place your configurations elsewhere (e.g. `/etc/clash`), you can use command-line option `-d` to specify a configuration directory:
15: 
16: ```shell
17: clash -d . # current directory
18: clash -d /etc/clash
19: ```
20: 
21: Or, you can use option `-f` to specify a configuration file:
22: 
23: ```shell
24: clash -f ./config.yaml
25: clash -f /etc/clash/config.yaml
26: ```
27: 
28: ## Special Syntaxes
29: 
30: There are some special syntaxes in Clash configuration files, of which you might want to be aware:
31: 
32: ### IPv6 Addresses
33: 
34: You should wrap IPv6 addresses in square brackets, for example:
35: 
36: ```txt
37: [aaaa::a8aa:ff:fe09:57d8]
38: ```
39: 
40: ### DNS Wildcard Domain Matching
41: 
42: In some cases, you will need to match against wildcard domains. For example, when you're setting up [Clash DNS](/configuration/dns), you might want to match against all subdomains of `localdomain`.
43: 
44: Clash do offer support on matching different levels of wildcard domains in the DNS configuration, while the syntaxes defined below:
45: 
46: ::: tip
47: Any domain with these characters should be wrapped with single quotes (`'`). For example, `'*.google.com'`.
48: Static domain has a higher priority than wildcard domain (foo.example.com > *.example.com > .example.com).
49: :::
50: 
51: Use an asterisk (`*`) to match against a single-level wildcard subdomain.
52: 
53: | Expression | Matches | Does Not Match |
54: | ---------- | ------- | -------------- |
55: | `*.google.com` | `www.google.com` | `google.com` |
56: | `*.bar.google.com` | `foo.bar.google.com` | `bar.google.com` |
57: | `*.*.google.com` | `thoughtful.sandbox.google.com` | `one.two.three.google.com` |
58: 
59: Use a dot sign (`.`) to match against multi-level wildcard subdomains.
60: 
61: | Expression | Matches | Does Not Match |
62: | ---------- | ------- | -------------- |
63: | `.google.com` | `www.google.com` | `google.com` |
64: | `.google.com` | `thoughtful.sandbox.google.com` | `google.com` |
65: | `.google.com` | `one.two.three.google.com` | `google.com` |
66: 
67: Use a plus sign (`+`) to match against multi-level wildcard subdomains.
68: 
69: `+` wildcard works like DOMAIN-SUFFIX, you can quickly match multi level at a time.
70: 
71: | Expression | Matches |
72: | ---------- | ------- |
73: | `+.google.com` | `google.com` |
74: | `+.google.com` | `www.google.com` |
75: | `+.google.com` | `thoughtful.sandbox.google.com` |
76: | `+.google.com` | `one.two.three.google.com` |


./docs\configuration\inbound.md
1: ---
2: sidebarTitle: Inbound
3: sidebarOrder: 3
4: ---
5: 
6: # Inbound
7: 
8: Clash supports multiple inbound protocols, including:
9: 
10: - SOCKS5
11: - HTTP(S)
12: - Redirect TCP
13: - TProxy TCP
14: - TProxy UDP
15: - Linux TUN device (Premium only)
16: 
17: Connections to any inbound protocol listed above will be handled by the same internal rule-matching engine. That is to say, Clash does not (currently) support different rule sets for different inbounds.
18: 
19: ## Configuration
20: 
21: ```yaml
22: # Port of HTTP(S) proxy server on the local end
23: # port: 7890
24: 
25: # Port of SOCKS5 proxy server on the local end
26: # socks-port: 7891
27: 
28: # HTTP(S) and SOCKS4(A)/SOCKS5 server on the same port
29: mixed-port: 7890
30: 
31: # Transparent proxy server port for Linux and macOS (Redirect TCP and TProxy UDP)
32: # redir-port: 7892
33: 
34: # Transparent proxy server port for Linux (TProxy TCP and TProxy UDP)
35: # tproxy-port: 7893
36: 
37: # Allow clients other than 127.0.0.1 to connect to the inbounds
38: allow-lan: false
39: ```
40: 
41: ## The Mixed Port
42: 
43: The mixed port is a special port that supports both HTTP(S) and SOCKS5 protocols. You can have any programs that support either HTTP or SOCKS proxy to connect to this port, for example:
44: 
45: ```shell
46: $ curl -x socks5h://127.0.0.1:7890 -v http://connect.rom.miui.com/generate_204
47: *   Trying 127.0.0.1:7890...
48: * SOCKS5 connect to connect.rom.miui.com:80 (remotely resolved)
49: * SOCKS5 request granted.
50: * Connected to (nil) (127.0.0.1) port 7890 (#0)
51: > GET /generate_204 HTTP/1.1
52: > Host: connect.rom.miui.com
53: > User-Agent: curl/7.81.0
54: > Accept: */*
55: > 
56: * Mark bundle as not supporting multiuse
57: < HTTP/1.1 204 No Content
58: < Date: Thu, 11 May 2023 06:18:22 GMT
59: < Connection: keep-alive
60: < Content-Type: text/plain
61: < 
62: * Connection #0 to host (nil) left intact
63: ```
64: 
65: ## Redirect and TProxy
66: 
67: Redirect and TProxy are two different ways of implementing transparent proxying. They are both supported by Clash.
68: 
69: However, you most likely don't need to mess with these two inbounds - we recommend using [Clash Premium](/premium/introduction) if you want to use transparent proxying, as it has built-in support of the automatic management of the route table, rules and nftables.


./docs\configuration\introduction.md
1: ---
2: sidebarTitle: Introduction
3: sidebarOrder: 1
4: ---
5: 
6: # Introduction
7: 
8: In this chapter, we'll cover the common features of Clash and how they should be used and configured.
9: 
10: Clash uses [YAML](https://yaml.org), _YAML Ain't Markup Language_, for configuration files. YAML is designed to be easy to be read, be written, and be interpreted by computers, and is commonly used for exact configuration files.
11: 
12: ## Understanding how Clash works
13: 
14: Before proceeding, it's important to understand how Clash works, in which there are two critical components:
15: 
16: ![](/assets/connection-flow.png)
17: 
18: <!-- https://excalidraw.com/clash-connection-flow#json=OHsOdaqAUPuuN7VPvdZ9Z,NT7rRrtzRgbVIM0tpkPnGA -->
19: 
20: ### Inbound
21: 
22: Inbound is the component that listens on the local end. It works by opening a local port and listening for incoming connections. When a connection comes in, Clash looks up the rules that are configured in the configuration file, and decides which outbound that the connection should go next.
23: 
24: ### Outbound
25: 
26: Outbound is the component that connects to the remote end. Depending on the configuration, it can be a specific network interface, a proxy server, or a [proxy group](./outbound#proxy-groups).
27: 
28: ## Rule-based Routing
29: 
30: Clash supports rule-based routing, which means you can route packets to different outbounds based on the a variety of contraints. The rules can be defined in the `rules` section of the configuration file.
31: 
32: There's a number of available rule types, and each rule type has its own syntax. The general syntax of a rule is:
33: 
34: ```txt
35: TYPE,ARGUMENT,POLICY(,no-resolve)
36: ```
37: 
38: In the upcoming guides, you will learn more about how rules can be configured.


./docs\configuration\outbound.md
1: ---
2: sidebarTitle: Outbound
3: sidebarOrder: 4
4: ---
5: 
6: # Outbound
7: 
8: There are several types of outbound targets in Clash. Each type has its own features and usage scenarios. In this page, we'll cover the common features of each type and how they should be used and configured.
9: 
10: [[toc]]
11: 
12: ## Proxies
13: 
14: Proxies are some outbound targets that you can configure. Like proxy servers, you define destinations for the packets here.
15: 
16: ### Shadowsocks
17: 
18: Clash supports the following ciphers (encryption methods) for Shadowsocks:
19: 
20: | Family | Ciphers |
21: | ------ | ------- |
22: | AEAD | aes-128-gcm, aes-192-gcm, aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305 |
23: | Stream | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |
24: | Block | aes-128-ctr, aes-192-ctr, aes-256-ctr |
25: 
26: In addition, Clash also supports popular Shadowsocks plugins `obfs` and `v2ray-plugin`.
27: 
28: ::: code-group
29: 
30: ```yaml [basic]
31: - name: "ss1"
32:   type: ss
33:   # interface-name: eth0
34:   # routing-mark: 1234
35:   server: server
36:   port: 443
37:   cipher: chacha20-ietf-poly1305
38:   password: "password"
39:   # udp: true
40: ```
41: 
42: ```yaml [obfs]
43: - name: "ss2"
44:   type: ss
45:   # interface-name: eth0
46:   # routing-mark: 1234
47:   server: server
48:   port: 443
49:   cipher: chacha20-ietf-poly1305
50:   password: "password"
51:   plugin: obfs
52:   plugin-opts:
53:     mode: tls # or http
54:     # host: bing.com
55: ```
56: 
57: ```yaml [ws (websocket)]
58: - name: "ss3"
59:   type: ss
60:   # interface-name: eth0
61:   # routing-mark: 1234
62:   server: server
63:   port: 443
64:   cipher: chacha20-ietf-poly1305
65:   password: "password"
66:   plugin: v2ray-plugin
67:   plugin-opts:
68:     mode: websocket # no QUIC now
69:     # tls: true # wss
70:     # skip-cert-verify: true
71:     # host: bing.com
72:     # path: "/"
73:     # mux: true
74:     # headers:
75:     #   custom: value
76: ```
77: 
78: :::
79: 
80: ### ShadowsocksR
81: 
82: Clash supports the infamous anti-censorship protocol ShadowsocksR as well. The supported ciphers:
83: 
84: | Family | Ciphers |
85: | ------ | ------- |
86: | Stream | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |
87: 
88: Supported obfuscation methods:
89: 
90: - plain
91: - http_simple
92: - http_post
93: - random_head
94: - tls1.2_ticket_auth
95: - tls1.2_ticket_fastauth
96: 
97: Supported protocols:
98: 
99: - origin
100: - auth_sha1_v4
101: - auth_aes128_md5
102: - auth_aes128_sha1
103: - auth_chain_a
104: - auth_chain_b
105: 
106: ```yaml
107: - name: "ssr"
108:   type: ssr
109:   # interface-name: eth0
110:   # routing-mark: 1234
111:   server: server
112:   port: 443
113:   cipher: chacha20-ietf
114:   password: "password"
115:   obfs: tls1.2_ticket_auth
116:   protocol: auth_sha1_v4
117:   # obfs-param: domain.tld
118:   # protocol-param: "#"
119:   # udp: true
120: ```
121: 
122: ### Vmess
123: 
124: Clash supports the following ciphers (encryption methods) for Vmess:
125: 
126: - auto
127: - aes-128-gcm
128: - chacha20-poly1305
129: - none
130: 
131: ::: code-group
132: 
133: ```yaml [basic]
134: - name: "vmess"
135:   type: vmess
136:   # interface-name: eth0
137:   # routing-mark: 1234
138:   server: server
139:   port: 443
140:   uuid: uuid
141:   alterId: 32
142:   cipher: auto
143:   # udp: true
144:   # tls: true
145:   # skip-cert-verify: true
146:   # servername: example.com # priority over wss host
147:   # network: ws
148:   # ws-opts:
149:   #   path: /path
150:   #   headers:
151:   #     Host: v2ray.com
152:   #   max-early-data: 2048
153:   #   early-data-header-name: Sec-WebSocket-Protocol
154: ```
155: 
156: ```yaml [HTTP]
157: - name: "vmess-http"
158:   type: vmess
159:   # interface-name: eth0
160:   # routing-mark: 1234
161:   server: server
162:   port: 443
163:   uuid: uuid
164:   alterId: 32
165:   cipher: auto
166:   # udp: true
167:   # network: http
168:   # http-opts:
169:   #   # method: "GET"
170:   #   # path:
171:   #   #   - '/'
172:   #   #   - '/video'
173:   #   # headers:
174:   #   #   Connection:
175:   #   #     - keep-alive
176: ```
177: 
178: ```yaml [HTTP/2]
179: - name: "vmess-h2"
180:   type: vmess
181:   # interface-name: eth0
182:   # routing-mark: 1234
183:   server: server
184:   port: 443
185:   uuid: uuid
186:   alterId: 32
187:   cipher: auto
188:   network: h2
189:   tls: true
190:   h2-opts:
191:     host:
192:       - http.example.com
193:       - http-alt.example.com
194:     path: /
195: ```
196: 
197: ```yaml [gRPC]
198: - name: vmess-grpc
199:   type: vmess
200:   # interface-name: eth0
201:   # routing-mark: 1234
202:   server: server
203:   port: 443
204:   uuid: uuid
205:   alterId: 32
206:   cipher: auto
207:   network: grpc
208:   tls: true
209:   servername: example.com
210:   # skip-cert-verify: true
211:   grpc-opts:
212:     grpc-service-name: "example"
213: ```
214: 
215: :::
216: 
217: ### SOCKS5
218: 
219: In addition, Clash supports SOCKS5 outbound as well:
220: 
221: ```yaml
222: - name: "socks"
223:   type: socks5
224:   # interface-name: eth0
225:   # routing-mark: 1234
226:   server: server
227:   port: 443
228:   # username: username
229:   # password: password
230:   # tls: true
231:   # skip-cert-verify: true
232:   # udp: true
233: ```
234: 
235: ### HTTP
236: 
237: Clash also supports HTTP outbound:
238: 
239: ::: code-group
240: 
241: ```yaml [HTTP]
242: - name: "http"
243:   type: http
244:   # interface-name: eth0
245:   # routing-mark: 1234
246:   server: server
247:   port: 443
248:   # username: username
249:   # password: password
250: ```
251: 
252: ```yaml [HTTPS]
253: - name: "http"
254:   type: http
255:   # interface-name: eth0
256:   # routing-mark: 1234
257:   server: server
258:   port: 443
259:   tls: true
260:   # skip-cert-verify: true
261:   # sni: custom.com
262:   # username: username
263:   # password: password
264: ```
265: 
266: :::
267: 
268: ### Snell
269: 
270: Being an alternative protocol for anti-censorship, Clash has integrated support for Snell as well.
271: 
272: ::: tip
273: Clash does not support Snell v4. ([#2466](https://github.com/Dreamacro/clash/issues/2466))
274: :::
275: 
276: ```yaml
277: # No UDP support yet
278: - name: "snell"
279:   type: snell
280:   # interface-name: eth0
281:   # routing-mark: 1234
282:   server: server
283:   port: 44046
284:   psk: yourpsk
285:   # version: 2
286:   # obfs-opts:
287:     # mode: http # or tls
288:     # host: bing.com
289: ```
290: 
291: ### Trojan
292: 
293: Clash has built support for the popular protocol Trojan:
294: 
295: ::: code-group
296: 
297: ```yaml [basic]
298: - name: "trojan"
299:   type: trojan
300:   # interface-name: eth0
301:   # routing-mark: 1234
302:   server: server
303:   port: 443
304:   password: yourpsk
305:   # udp: true
306:   # sni: example.com # aka server name
307:   # alpn:
308:   #   - h2
309:   #   - http/1.1
310:   # skip-cert-verify: true
311: ```
312: 
313: ```yaml [gRPC]
314: - name: trojan-grpc
315:   type: trojan
316:   # interface-name: eth0
317:   # routing-mark: 1234
318:   server: server
319:   port: 443
320:   password: "example"
321:   network: grpc
322:   sni: example.com
323:   # skip-cert-verify: true
324:   udp: true
325:   grpc-opts:
326:     grpc-service-name: "example"
327: ```
328: 
329: ```yaml  [ws (websocket)]
330: - name: trojan-ws
331:   type: trojan
332:   # interface-name: eth0
333:   # routing-mark: 1234
334:   server: server
335:   port: 443
336:   password: "example"
337:   network: ws
338:   sni: example.com
339:   # skip-cert-verify: true
340:   udp: true
341:   # ws-opts:
342:     # path: /path
343:     # headers:
344:     #   Host: example.com
345: ```
346: 
347: :::
348: 
349: ## Proxy Groups
350: 
351: Proxy Groups are groups of proxies that you can use directly as a rule policy.
352: 
353: ### relay
354: 
355: The request sent to this proxy group will be relayed through the specified proxy servers sequently. There's currently no UDP support on this. The specified proxy servers should not contain another relay.
356: 
357: ### url-test
358: 
359: Clash benchmarks each proxy servers in the list, by sending HTTP HEAD requests to a specified URL through these servers periodically. It's possible to set a maximum tolerance value, benchmarking interval, and the target URL.
360: 
361: ### fallback
362: 
363: Clash periodically tests the availability of servers in the list with the same mechanism of `url-test`. The first available server will be used.
364: 
365: ### load-balance
366: 
367: The request to the same eTLD+1 will be dialed with the same proxy.
368: 
369: ### select
370: 
371: The first server is by default used when Clash starts up. Users can choose the server to use with the RESTful API. In this mode, you can hardcode servers in the config or use [Proxy Providers](#proxy-providers).
372: 
373: Either way, sometimes you might as well just route packets with a direct connection. In this case, you can use the `DIRECT` outbound.
374: 
375: To use a different network interface, you will need to use a Proxy Group that contains a `DIRECT` outbound with the `interface-name` option set.
376: 
377: ```yaml
378: - name: "My Wireguard Outbound"
379:   type: select
380:   interface-name: wg0
381:   proxies: [ 'DIRECT' ]
382: ```
383: 
384: ## Proxy Providers
385: 
386: Proxy Providers give users the power to load proxy server lists dynamically, instead of hardcoding them in the configuration file. There are currently two sources for a proxy provider to load server list from:
387: 
388: - `http`: Clash loads the server list from a specified URL on startup. Clash periodically pulls the server list from remote if the `interval` option is set.
389: - `file`: Clash loads the server list from a specified location on the filesystem on startup.
390: 
391: Health check is available for both modes, and works exactly like `fallback` in Proxy Groups. The configuration format for the server list files is also exactly the same in the main configuration file:
392: 
393: ::: code-group
394: 
395: ```yaml [config.yaml]
396: proxy-providers:
397:   provider1:
398:     type: http
399:     url: "url"
400:     interval: 3600
401:     path: ./provider1.yaml
402:     # filter: 'a|b' # golang regex string
403:     health-check:
404:       enable: true
405:       interval: 600
406:       # lazy: true
407:       url: http://www.gstatic.com/generate_204
408:   test:
409:     type: file
410:     path: /test.yaml
411:     health-check:
412:       enable: true
413:       interval: 36000
414:       url: http://www.gstatic.com/generate_204
415: ```
416: 
417: ```yaml [test.yaml]
418: proxies:
419:   - name: "ss1"
420:     type: ss
421:     server: server
422:     port: 443
423:     cipher: chacha20-ietf-poly1305
424:     password: "password"
425: 
426:   - name: "ss2"
427:     type: ss
428:     server: server
429:     port: 443
430:     cipher: chacha20-ietf-poly1305
431:     password: "password"
432:     plugin: obfs
433:     plugin-opts:
434:       mode: tls
435: ```
436: 
437: :::


./docs\configuration\rules.md
1: ---
2: sidebarTitle: Rules
3: sidebarOrder: 5
4: ---
5: 
6: # Rules
7: 
8: In the Getting Started guide, we covered the basics of rule-based matching in Clash. In this chapter, we'll cover all available rule types in the latest version of Clash.
9: 
10: ```txt
11: TYPE,ARGUMENT,POLICY(,no-resolve)
12: ```
13: 
14: The `no-resolve` option is optional, and it's used to skip DNS resolution for the rule. It's useful when you want to use `GEOIP`, `IP-CIDR`, `IP-CIDR6`, `SCRIPT` rules, but don't want to resolve the domain name to an IP address just yet.
15: 
16: [[toc]]
17: 
18: ## Policy
19: 
20: There are four types of POLICY for now, in which:
21: 
22: - DIRECT: directly connects to the target through `interface-name` (does not lookup system route table)
23: - REJECT: drops the packet
24: - Proxy: routes the packet to the specified proxy server
25: - Proxy Group: routes the packet to the specified proxy group
26: 
27: ## Types of rules
28: 
29: There are a number of rules where one might find useful. The following section covers each rule type and how they should be used.
30: 
31: ### DOMAIN
32: 
33: `DOMAIN,www.google.com,policy` routes only `www.google.com` to `policy`.
34: 
35: ### DOMAIN-SUFFIX
36: 
37: `DOMAIN-SUFFIX,youtube.com,policy` routes any domain names that ends with `youtube.com`.
38: 
39: In this case, `www.youtube.com` and `foo.bar.youtube.com` will be routed to `policy`.
40: 
41: ### DOMAIN-KEYWORD
42: 
43: `DOMAIN-KEYWORD,google,policy` routes any domain names to policy that contains `google`.
44: 
45: In this case, `www.google.com` or `googleapis.com` are routed to `policy`.
46: 
47: ### GEOIP
48: 
49: GEOIP rules are used to route packets based on the **country code** of the target IP address. Clash uses [MaxMind GeoLite2](https://dev.maxmind.com/geoip/geoip2/geolite2/) database for this feature.
50: 
51: ::: warning
52: When encountering this rule, Clash will resolve the domain name to an IP address and then look up the country code of the IP address. If you want to skip the DNS resolution, use `no-resolve` option.
53: :::
54: 
55: `GEOIP,CN,policy` routes any packets destined to a China IP address to `policy`.
56: 
57: ### IP-CIDR
58: 
59: IP-CIDR rules are used to route packets based on the **destination IPv4 address** of the packet.
60: 
61: ::: warning
62: When encountering this rule, Clash will resolve the domain name to an IP address. If you want to skip the DNS resolution, use `no-resolve` option.
63: :::
64: 
65: `IP-CIDR,127.0.0.0/8,DIRECT` routes any packets destined to `127.0.0.0/8` to the `DIRECT` outbound.
66: 
67: ### IP-CIDR6
68: 
69: IP-CIDR6 rules are used to route packets based on the **destination IPv6 address** of the packet.
70: 
71: ::: warning
72: When encountering this rule, Clash will resolve the domain name to an IP address. If you want to skip the DNS resolution, use `no-resolve` option.
73: :::
74: 
75: `IP-CIDR6,2620:0:2d0:200::7/32,policy` routes any packets destined to `2620:0:2d0:200::7/32` to `policy`.
76: 
77: ### SRC-IP-CIDR
78: 
79: SRC-IP-CIDR rules are used to route packets based on the **source IPv4 address** of the packet.
80: 
81: `SRC-IP-CIDR,192.168.1.201/32,DIRECT` routes any packets **from** `192.168.1.201/32` to the `DIRECT` policy.
82: 
83: ### SRC-PORT
84: 
85: SRC-PORT rules are used to route packets based on the **source port** of the packet.
86: 
87: `SRC-PORT,80,policy` routes any packets **from** the port 80 to `policy`.
88: 
89: ### DST-PORT
90: 
91: DST-PORT rules are used to route packets based on the **destination port** of the packet.
92: 
93: `DST-PORT,80,policy` routes any packets **to** the port 80 to `policy`.
94: 
95: ### PROCESS-NAME
96: 
97: PROCESS-NAME rules are used to route packets based on the name of process that is sending the packet.
98: 
99: ::: warning
100: Currently, only macOS, Linux, FreeBSD and Windows are supported.
101: :::
102: 
103: `PROCESS-NAME,nc,DIRECT` routes all packets from the process `nc` to the `DIRECT` outbound.
104: 
105: ### PROCESS-PATH
106: 
107: PROCESS-PATH rules are used to route packets based on the PATH of process that is sending the packet.
108: 
109: ::: warning
110: Currently, only macOS, Linux, FreeBSD and Windows are supported.
111: :::
112: 
113: `PROCESS-PATH,/bin/sh,DIRECT` routes all packets from the process `/bin/sh` to the `DIRECT` outbound.
114: 
115: ### IPSET
116: 
117: IPSET rules are used to match against an IP set and route packets based on the result. According to the [official website of IPSET](https://ipset.netfilter.org/):
118: 
119: > IP sets are a framework inside the Linux kernel, which can be administered by the ipset utility. Depending on the type, an IP set may store IP addresses, networks, (TCP/UDP) port numbers, MAC addresses, interface names or combinations of them in a way, which ensures lightning speed when matching an entry against a set.
120: 
121: Therefore, this feature only works on Linux and requires `ipset` to be installed.
122: 
123: ::: warning
124: When encountering this rule, Clash will resolve the domain name to an IP address. If you want to skip the DNS resolution, use `no-resolve` option.
125: :::
126: 
127: `IPSET,chinaip,DIRECT` routes all packets with destination IPs matching the `chinaip` IPSET to DIRECT outbound.
128: 
129: ### RULE-SET
130: 
131: ::: info
132: This feature is only available in the [Premium](/premium/introduction) edtion.
133: :::
134: 
135: RULE-SET rules are used to route packets based on the result of a [rule provider](/premium/rule-providers). When Clash encounters this rule, it loads the rules from the specified rule provider and then matches the packet against the rules. If the packet matches any of the rules, the packet will be routed to the specified policy, otherwise the rule is skipped.
136: 
137: ::: warning
138: When encountering RULE-SET, Clash will resolve the domain name to an IP address **when the ruleset is of type IPCIDR**. If you want to skip the DNS resolution, use `no-resolve` option for the RULE-SET entry.
139: :::
140: 
141: `RULE-SET,my-rule-provider,DIRECT` loads all rules from `my-rule-provider` and sends the matched packets to the `DIRECT` outbound.
142: 
143: ### SCRIPT
144: 
145: ::: info
146: This feature is only available in the [Premium](/premium/introduction) edtion.
147: :::
148: 
149: SCRIPT rules are special rules that are used to route packets based on the result of a [script shortcut](/premium/script-shortcuts). When Clash encounters this rule, it evaluates the expression. If it returns `true`, the packet will be routed to the specified policy, otherwise the rule is skipped.
150: 
151: ::: warning
152: When encountering this rule, Clash will resolve the domain name to an IP address. If you want to skip the DNS resolution, use `no-resolve` option.
153: :::
154: 
155: `SCRIPT,SHORTCUT-NAME,policy` routes any packets to `policy` if they have the shortcut evaluated `true`.
156: 
157: ### MATCH
158: 
159: `MATCH,policy` routes the rest of the packets to `policy`. This rule is **required** and is usually used as the last rule.


./docs\introduction\faq.md
1: ---
2: sidebarTitle: Frequently Asked Questions
3: sidebarOrder: 4
4: ---
5: 
6: # Frequently Asked Questions
7: 
8: Here we have some common questions people ask. If you have any questions not listed here, feel free to [open an issue](https://github.com/Dreamacro/clash/issues/new/choose).
9: 
10: [[toc]]
11: 
12: ## What is the difference between amd64 and amd64-v3?
13: 
14: Quoting from [golang/go](https://github.com/golang/go/wiki/MinimumRequirements#amd64):
15: 
16: > Until Go 1.17, the Go compiler always generated x86 binaries that could be executed by any 64-bit x86 processor.
17: > 
18: > Go 1.18 introduced [4 architectural levels](https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels) for AMD64.
19: > Each level differs in the set of x86 instructions that the compiler can include in the generated binaries:
20: > 
21: > * GOAMD64=v1 (default): The baseline. Exclusively generates instructions that all 64-bit x86 processors can execute.
22: > * GOAMD64=v2: all v1 instructions, plus CMPXCHG16B, LAHF, SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3.
23: > * GOAMD64=v3: all v2 instructions, plus AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, OSXSAVE.
24: > * GOAMD64=v4: all v3 instructions, plus AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL.
25: > 
26: > Setting, for example, GOAMD64=v3, will allow the Go compiler to use AVX2 instructions in the generated binaries (which may improve performance in some cases); but these binaries will not run on older x86 processors that don't support AVX2.
27: > 
28: > The Go toolchain may also generate newer instructions, but guarded by dynamic checks to ensure they're only executed on capable processors. For example, with GOAMD64=v1, [math/bits.OnesCount](https://pkg.go.dev/math/bits#OnesCount) will still use the [POPCNT](https://www.felixcloutier.com/x86/popcnt) instruction if [CPUID](https://www.felixcloutier.com/x86/cpuid) reports that it's available. Otherwise, it falls back to a generic implementation.
29: > 
30: > The Go toolchain does not currently generate any AVX512 instructions.
31: > 
32: > Note that *processor* is a simplification in this context. In practice, support from the entire system (firmware, hypervisor, kernel) is needed.
33: 
34: ## Which release should I use for my system?
35: 
36: Here are some common systems that people use Clash on, and the recommended release for each of them:
37: 
38: - NETGEAR WNDR3700v2: mips-hardfloat [#846](https://github.com/Dreamacro/clash/issues/846)
39: - NETGEAR WNDR3800: mips-softfloat [#579](https://github.com/Dreamacro/clash/issues/579)
40: - ASUS RT-AC5300: armv5 [#2356](https://github.com/Dreamacro/clash/issues/2356)
41: - MediaTek MT7620A, MT7621A: mipsle-softfloat ([#136](https://github.com/Dreamacro/clash/issues/136))
42: - mips_24kc: [#192](https://github.com/Dreamacro/clash/issues/192)
43: 
44: If your device is not listed here, you can check the CPU architecture of your device with `uname -m` and find the corresponding release in the release page.
45: 
46: ## List of wontfix
47: 
48: The official Clash core project will not implement/fix these things:
49: 
50: - [Snell](https://github.com/Dreamacro/clash/issues/2466)
51: - [Custom CA](https://github.com/Dreamacro/clash/issues/2333)
52: - [VMess Mux](https://github.com/Dreamacro/clash/issues/450)
53: - [VLess](https://github.com/Dreamacro/clash/issues/1185)
54: - [KCP](https://github.com/Dreamacro/clash/issues/16)
55: - [mKCP](https://github.com/Dreamacro/clash/issues/2308)
56: - [TLS Encrypted Client Hello](https://github.com/Dreamacro/clash/issues/2295)
57: - [TCP support for Clash DNS server](https://github.com/Dreamacro/clash/issues/368)
58: - [MITM](https://github.com/Dreamacro/clash/issues/227#issuecomment-508693628)
59: 
60: The following will be considered implementing when the official Go QUIC library releases.
61: 
62: - [TUIC](https://github.com/Dreamacro/clash/issues/2222)
63: - [Hysteria](https://github.com/Dreamacro/clash/issues/1863)
64: 
65: ## Proxies work on my local machine, but not on my router or in a container
66: 
67: Your system might be out of sync in time. Refer to your platform documentations about time synchronisation - things will break if time is not in sync.
68: 
69: ## Time complexity of rule matching
70: 
71: Refer to this discussion: [#422](https://github.com/Dreamacro/clash/issues/422)
72: 
73: ## Clash Premium unable to access Internet
74: 
75: You can refer to these relevant discussions:
76: 
77: - [#432](https://github.com/Dreamacro/clash/issues/432#issuecomment-571634905)
78: - [#2480](https://github.com/Dreamacro/clash/issues/2480)
79: 
80: ## error: unsupported rule type RULE-SET
81: 
82: If you stumbled on this error message:
83: 
84: ```txt
85: FATA[0000] Parse config error: Rules[0] [RULE-SET,apple,REJECT] error: unsupported rule type RULE-SET
86: ```
87: 
88: You're using Clash open-source edition. Rule Providers is currently only available in the [Premium core](https://github.com/Dreamacro/clash/releases/tag/premium). (it's free)
89: 
90: ## DNS Hijack does not work
91: 
92: Since `tun.auto-route` does not intercept LAN traffic, if your system DNS is set to servers in private subnets, DNS hijack will not work. You can either:
93: 
94: 1. Use a non-private DNS server as your system DNS like `1.1.1.1`
95: 2. Or manually set up your system DNS to the Clash DNS (by default, `198.18.0.1`)


./docs\introduction\getting-started.md
1: ---
2: sidebarTitle: Getting Started
3: sidebarOrder: 2
4: ---
5: 
6: # Getting Started
7: 
8: To get started with Clash, you can either build it from source or download pre-built binaries.
9: 
10: ## Using pre-built binaries
11: 
12: You can download Clash core binaries here: [https://github.com/Dreamacro/clash/releases](https://github.com/Dreamacro/clash/releases)
13: 
14: ## Install from source
15: 
16: You can build Clash on your own device with Golang 1.19+:
17: 
18: ```shell
19: $ go install github.com/Dreamacro/clash@latest
20: go: downloading github.com/Dreamacro/clash v1.15.1
21: ```
22: 
23: The binary is built under `$GOPATH/bin`:
24: 
25: ```shell
26: $ $GOPATH/bin/clash -v
27: Clash unknown version darwin arm64 with go1.20.3 unknown time
28: ```
29: 
30: ## Build for a different arch/os
31: 
32: Golang supports cross-compilation, so you can build for a device on a different architecture or operating system. You can use _make_ to build them easily - for example:
33: 
34: ```shell
35: $ git clone --depth 1 https://github.com/Dreamacro/clash
36: Cloning into 'clash'...
37: remote: Enumerating objects: 359, done.
38: remote: Counting objects: 100% (359/359), done.
39: remote: Compressing objects: 100% (325/325), done.
40: remote: Total 359 (delta 25), reused 232 (delta 17), pack-reused 0
41: Receiving objects: 100% (359/359), 248.99 KiB | 1.63 MiB/s, done.
42: Resolving deltas: 100% (25/25), done.
43: $ cd clash && make darwin-arm64
44: fatal: No names found, cannot describe anything.
45: GOARCH=arm64 GOOS=darwin CGO_ENABLED=0 go build -trimpath -ldflags '-X "github.com/Dreamacro/clash/constant.Version=unknown version" -X "github.com/Dreamacro/clash/constant.BuildTime=Mon May  8 16:47:10 UTC 2023" -w -s -buildid=' -o bin/clash-darwin-arm64
46: $ file bin/clash-darwin-arm64
47: bin/clash-darwin-arm64: Mach-O 64-bit executable arm64
48: ```
49: 
50: For other build targets, check out the [Makefile](https://github.com/Dreamacro/clash/blob/master/Makefile).


./docs\introduction\service.md
1: ---
2: sidebarTitle: Clash as a Service
3: sidebarOrder: 3
4: ---
5: 
6: # Clash as a Service
7: 
8: While Clash is meant to be run in the background, there's currently no elegant way to implement daemons with Golang, hence we recommend you to daemonize Clash with third-party tools.
9: 
10: ## systemd
11: 
12: Copy Clash binary to `/usr/local/bin` and configuration files to `/etc/clash`:
13: 
14: ```shell
15: cp clash /usr/local/bin
16: cp config.yaml /etc/clash/
17: cp Country.mmdb /etc/clash/
18: ```
19: 
20: Create the systemd configuration file at `/etc/systemd/system/clash.service`:
21: 
22: ```ini
23: [Unit]
24: Description=Clash daemon, A rule-based proxy in Go.
25: After=network-online.target
26: 
27: [Service]
28: Type=simple
29: Restart=always
30: ExecStart=/usr/local/bin/clash -d /etc/clash
31: 
32: [Install]
33: WantedBy=multi-user.target
34: ```
35: 
36: After that you're supposed to reload systemd:
37: 
38: ```shell
39: systemctl daemon-reload
40: ```
41: 
42: Launch clashd on system startup with:
43: 
44: ```shell
45: systemctl enable clash
46: ```
47: 
48: Launch clashd immediately with:
49: 
50: ```shell
51: systemctl start clash
52: ```
53: 
54: Check the health and logs of Clash with:
55: 
56: ```shell
57: systemctl status clash
58: journalctl -xe
59: ```
60: 
61: Credits to [ktechmidas](https://github.com/ktechmidas) for this guide. ([#754](https://github.com/Dreamacro/clash/issues/754))
62: 
63: ## Docker
64: 
65: We provide pre-built images of Clash and Clash Premium. Therefore you can deploy Clash with [Docker Compose](https://docs.docker.com/compose/) if you're on Linux. However, you should be advised that it's [not recommended](https://github.com/Dreamacro/clash/issues/2249#issuecomment-1203494599) to run **Clash Premium** in a container.
66: 
67: ::: warning
68: This setup will not work on macOS systems due to the lack of [host networking and TUN support](https://github.com/Dreamacro/clash/issues/770#issuecomment-650951876) in Docker for Mac.
69: :::
70: 
71: 
72: ::: code-group
73: 
74: ```yaml [Clash]
75: services:
76:   clash:
77:     image: ghcr.io/dreamacro/clash
78:     restart: always
79:     volumes:
80:       - ./config.yaml:/root/.config/clash/config.yaml:ro
81:       # - ./ui:/ui:ro # dashboard volume
82:     ports:
83:       - "7890:7890"
84:       - "7891:7891"
85:       # - "8080:8080" # The External Controller (RESTful API)
86:     network_mode: "bridge"
87: ```
88: 
89: ```yaml [Clash Premium]
90: services:
91:   clash:
92:     image: ghcr.io/dreamacro/clash-premium
93:     restart: always
94:     volumes:
95:       - ./config.yaml:/root/.config/clash/config.yaml:ro
96:       # - ./ui:/ui:ro # dashboard volume
97:     ports:
98:       - "7890:7890"
99:       - "7891:7891"
100:       # - "8080:8080" # The External Controller (RESTful API)
101:     cap_add:
102:       - NET_ADMIN
103:     devices:
104:       - /dev/net/tun
105:     network_mode: "host"
106: ```
107: 
108: :::
109: 
110: Save as `docker-compose.yaml` and place your `config.yaml` in the same directory.
111: 
112: ::: tip
113: Before proceeding, refer to your platform documentations about time synchronisation - things will break if time is not in sync.
114: :::
115: 
116: When you're ready, run the following commands to bring up Clash:
117: 
118: ```shell
119: docker-compose up -d
120: ```
121: 
122: You can view the logs with:
123: 
124: ```shell
125: docker-compose logs
126: ```
127: 
128: Stop Clash with:
129: 
130: ```shell
131: docker-compose stop
132: ```
133: 
134: ## FreeBSD rc
135: 
136: install clash with `ports(7)` or `pkg(8)`
137: 
138: copy the required files to `/usr/local/etc/clash`
139: 
140: ```shell
141: cp config.yaml /usr/local/etc/clash/
142: cp Country.mmdb /usr/local/etc/clash/
143: ```
144: 
145: Create the rc configuration file at `/usr/local/etc/rc.d/clash`:
146: 
147: ```shell
148: #!/bin/sh
149: 
150: # PROVIDE: clash
151: # REQUIRE: NETWORKING DAEMON
152: # BEFORE: LOGIN
153: # KEYWORD: shutdown
154: 
155: . /etc/rc.subr
156: 
157: name=clash
158: rcvar=clash_enable
159: 
160: : ${clash_enable="NO"}
161: : ${clash_config_dir="/usr/local/etc/clash"}
162: 
163: required_dirs="${clash_config_dir}"
164: required_files="${clash_config_dir}/config.yaml ${clash_config_dir}/Country.mmdb"
165: 
166: command="/usr/sbin/daemon"
167: procname="/usr/local/bin/${name}"
168: pidfile="/var/run/${name}.pid"
169: start_precmd="${name}_prestart"
170: 
171: clash_prestart()
172: {
173: 	rc_flags="-T ${name} -p ${pidfile} ${procname} -d ${clash_config_dir} ${rc_flags}"
174: }
175: 
176: load_rc_config $name
177: run_rc_command "$1"
178: ```
179: 
180: make the script executable:
181: 
182: ```shell
183: chmod +x /usr/local/etc/rc.d/clash
184: ```
185: 
186: Launch clashd on system startup with:
187: 
188: ```shell
189: service clash enable
190: ```
191: 
192: Launch clashd immediately with:
193: 
194: ```shell
195: service clash onestart
196: ```
197: 
198: Check the status of Clash with:
199: 
200: ```shell
201: service clash status
202: ```
203: 
204: You can check log in file `/var/log/daemon.log`
205: 
206: ::: tip
207: If you want to change the default config directory add the following lines to /etc/rc.conf :
208: ```shell
209: clash_enable (bool):        Set it to YES to run clash on startup.
210:                             Default: NO
211: clash_config_dir (string):   clash config directory.
212:                             Default: /usr/loca/etc/clash
213: ```
214: :::


./docs\introduction\_dummy-index.md
1: ---
2: sidebarTitle: What is Clash?
3: sidebarOrder: 1
4: ---
5: 
6: <!-- This file is used as a dummy sidebar item that always links to / -->


./docs\premium\ebpf.md
1: ---
2: sidebarTitle: "Feature: eBPF Redirect to TUN"
3: sidebarOrder: 3
4: ---
5: 
6: # eBPF Redirect to TUN
7: 
8: eBPF redirect to TUN is a feature that intercepts all network traffic on a specific network interface and redirects it to the TUN interface. [Support from your kernel](https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration) is required.
9: 
10: ::: warning
11: This feature conflicts with `tun.auto-route`.
12: :::
13: 
14: While it usually brings better performance compared to `tun.auto-redir` and `tun.auto-route`, it's less tested compared to `auto-route`. Therefore, you should proceed with caution.
15: 
16: ## Configuration
17: 
18: ```yaml
19: ebpf:
20:   redirect-to-tun:
21:     - eth0
22: ```
23: 
24: ## Known Issues
25: 
26: - This feature breaks Tailscaled, so you should use `tun.auto-route` instead.


./docs\premium\experimental-features.md
1: ---
2: sidebarTitle: Experimental Features
3: sidebarOrder: 9
4: ---
5: 
6: # Experimental Features
7: 
8: Occasionally we make new features that would require a fair amount of testing before having it in the main release. These features are marked as experimental and are disabled by default.
9: 
10: ::: warning
11: Some features listed here can be unstable, and might get removed in any future version - we do not recommend using them unless you have a specific reason to do so.
12: :::
13: 
14: ## Sniff TLS SNI
15: 
16: ```yaml
17: experimental:
18:   sniff-tls-sni: true
19: ```


./docs\premium\introduction.md
1: ---
2: sidebarTitle: Introduction
3: sidebarOrder: 1
4: ---
5: 
6: # Introduction
7: 
8: In the past, there was only one open-source version of Clash, until some [improper uses and redistributions](https://github.com/Dreamacro/clash/issues/541#issuecomment-672029110) of Clash arose. From that, we decided to fork Clash and develop the more advanced features in a private GitHub repository.
9: 
10: Don't worry just yet - the Premium core will stay free of charge, and the security is enforced with peer reviews from multiple credible developers.
11: 
12: ## What's the difference?
13: 
14: The Premium core is a fork of the open-source Clash core with the addition of the following features:
15: 
16: - [TUN Device](/premium/tun-device) with the support of `auto-redir` and `auto-route`
17: - [eBPF Redirect to TUN](/premium/ebpf)
18: - [Rule Providers](/premium/rule-providers)
19: - [Script](/premium/script)
20: - [Script Shortcuts](/premium/script-shortcuts)
21: - [Userspace Wireguard](/premium/userspace-wireguard)
22: - [The Profiling Engine](/premium/the-profiling-engine)
23: 
24: ## Obtaining a Copy
25: 
26: You can download the latest Clash Premium binaries from [GitHub Releases](https://github.com/Dreamacro/clash/releases/tag/premium).


./docs\premium\rule-providers.md
1: ---
2: sidebarTitle: "Feature: Rule Providers"
3: sidebarOrder: 4
4: ---
5: 
6: # Rule Providers
7: 
8: Rule Providers are pretty much the same compared to Proxy Providers. It enables users to load rules from external sources and overall cleaner configuration. This feature is currently Premium core only.
9: 
10: To define a Rule Provider, add the `rule-providers` field to the main configuration:
11: 
12: ```yaml
13: rule-providers:
14:   apple:
15:     behavior: "domain" # domain, ipcidr or classical (premium core only)
16:     type: http
17:     url: "url"
18:     # format: 'yaml' # or 'text'
19:     interval: 3600
20:     path: ./apple.yaml
21:   microsoft:
22:     behavior: "domain"
23:     type: file
24:     path: /microsoft.yaml
25: 
26: rules:
27:   - RULE-SET,apple,REJECT
28:   - RULE-SET,microsoft,policy
29: ```
30: 
31: There are three behavior types available:
32: 
33: ## `domain`
34: 
35: yaml:
36: 
37: ```yaml
38: payload:
39:   - '.blogger.com'
40:   - '*.*.microsoft.com'
41:   - 'books.itunes.apple.com'
42: ```
43: 
44: text:
45: 
46: ```txt
47: # comment
48: .blogger.com
49: *.*.microsoft.com
50: books.itunes.apple.com
51: ```
52: 
53: ## `ipcidr`
54: 
55: yaml
56: 
57: ```yaml
58: payload:
59:   - '192.168.1.0/24'
60:   - '10.0.0.0.1/32'
61: ```
62: 
63: text:
64: 
65: ```txt
66: # comment
67: 192.168.1.0/24
68: 10.0.0.0.1/32
69: ```
70: 
71: ## `classical`
72: 
73: yaml:
74: 
75: ```yaml
76: payload:
77:   - DOMAIN-SUFFIX,google.com
78:   - DOMAIN-KEYWORD,google
79:   - DOMAIN,ad.com
80:   - SRC-IP-CIDR,192.168.1.201/32
81:   - IP-CIDR,127.0.0.0/8
82:   - GEOIP,CN
83:   - DST-PORT,80
84:   - SRC-PORT,7777
85:   # MATCH is not necessary here
86: ```
87: 
88: text:
89: 
90: ```txt
91: # comment
92: DOMAIN-SUFFIX,google.com
93: DOMAIN-KEYWORD,google
94: DOMAIN,ad.com
95: SRC-IP-CIDR,192.168.1.201/32
96: IP-CIDR,127.0.0.0/8
97: GEOIP,CN
98: DST-PORT,80
99: SRC-PORT,7777
100: ```


./docs\premium\script-shortcuts.md
1: ---
2: sidebarTitle: "Feature: Script Shortcuts"
3: sidebarOrder: 6
4: ---
5: 
6: # Script Shortcuts
7: 
8: Clash Premium implements the Scripting feature powered by Python3, enableing users to programmatically select policies for the packets with dynamic flexibility.
9: 
10: You can either controll the entire rule-matching engine with a single Python script, or define a number of shortcuts and use them in companion with the regular rules. This page refers to the latter feature. For the former, see [Script](./script.md).
11: 
12: This feature enables the use of script in `rules` mode. By default, DNS resolution takes place for SCRIPT rules. `no-resolve` can be appended to the rule to prevent the resolution. (i.e.: `SCRIPT,quic,DIRECT,no-resolve`)
13: 
14: ```yaml
15: mode: Rule
16: 
17: script:
18:   engine: expr # or starlark (10x to 20x slower)
19:   shortcuts:
20:     quic: network == 'udp' and dst_port == 443
21:     curl: resolve_process_name() == 'curl'
22:     # curl: resolve_process_path() == '/usr/bin/curl'
23: 
24: rules:
25:   - SCRIPT,quic,REJECT
26: ```
27: 
28: ## Evaluation Engines
29: 
30: [Expr](https://expr.medv.io/) is used as the default engine for Script Shortcuts, offering 10x to 20x performance boost compared to Starlark.
31: 
32: [Starlark](https://github.com/google/starlark-go) is a Python-like langauge for configuration purposes, you can also use it for Script Shortcuts.
33: 
34: ## Variables
35: 
36: - network: string
37: - type: string
38: - src_ip: string
39: - dst_ip: string
40: - src_port: uint16
41: - dst_port: uint16
42: - inbound_port: uint16
43: - host: string
44: - process_path: string
45: 
46: ::: warning
47: Starlark is missing `process_path` variable for now.
48: :::
49: 
50: ## Functions
51: 
52: ```ts
53: type resolve_ip = (host: string) => string // ip string
54: type in_cidr = (ip: string, cidr: string) => boolean // ip in cidr
55: type in_ipset = (name: string, ip: string) => boolean // ip in ipset
56: type geoip = (ip: string) => string // country code
57: type match_provider = (name: string) => boolean // in rule provider
58: type resolve_process_name = () => string // find process name (curl .e.g)
59: type resolve_process_path = () => string // find process path (/usr/bin/curl .e.g)
60: ```


./docs\premium\script.md
1: ---
2: sidebarTitle: "Feature: Script"
3: sidebarOrder: 5
4: ---
5: 
6: # Script
7: 
8: Clash Premium implements the Scripting feature powered by Python3, enableing users to programmatically select policies for the packets with dynamic flexibility.
9: 
10: You can either control the entire rule-matching engine with a single Python script, or define a number of shortcuts and use them in companion with the regular rules. This page refers to the first feature, for the latter, see [Script Shortcuts](./script-shortcuts.md).
11: 
12: ## Scripting the entire rule-matching engine
13: 
14: ```yaml
15: mode: Script
16: 
17: # https://lancellc.gitbook.io/clash/clash-config-file/script
18: script:
19:   code: |
20:     def main(ctx, metadata):
21:       ip = ctx.resolve_ip(metadata["host"])
22:       if ip == "":
23:         return "DIRECT"
24:       metadata["dst_ip"] = ip
25: 
26:       code = ctx.geoip(ip)
27:       if code == "LAN" or code == "CN":
28:         return "DIRECT"
29: 
30:       return "Proxy" # default policy for requests which are not matched by any other script
31: ```
32: 
33: If you want to use ip rules (i.e.: IP-CIDR, GEOIP, etc), you will first need to manually resolve IP addresses and assign them to metadata:
34: 
35: ```python
36: def main(ctx, metadata):
37:     # ctx.rule_providers["geoip"].match(metadata) return false
38: 
39:     ip = ctx.resolve_ip(metadata["host"])
40:     if ip == "":
41:         return "DIRECT"
42:     metadata["dst_ip"] = ip
43: 
44:     # ctx.rule_providers["iprule"].match(metadata) return true
45: 
46:     return "Proxy"
47: ```
48: 
49: Interface definition for Metadata and Context:
50: 
51: ```ts
52: interface Metadata {
53:   type: string // socks5、http
54:   network: string // tcp
55:   host: string
56:   src_ip: string
57:   src_port: string
58:   dst_ip: string
59:   dst_port: string
60:   inbound_port: number
61: }
62: 
63: interface Context {
64:   resolve_ip: (host: string) => string // ip string
65:   resolve_process_name: (metadata: Metadata) => string
66:   resolve_process_path: (metadata: Metadata) => string
67:   geoip: (ip: string) => string // country code
68:   log: (log: string) => void
69:   proxy_providers: Record<string, Array<{ name: string, alive: boolean, delay: number }>>
70:   rule_providers: Record<string, { match: (metadata: Metadata) => boolean }>
71: }
72: ```


./docs\premium\the-profiling-engine.md
1: ---
2: sidebarTitle: "Feature: The Profiling Engine"
3: sidebarOrder: 8
4: ---
5: 
6: # The Profiling Engine
7: 
8: https://github.com/Dreamacro/clash-tracing
9: 
10: ```yaml
11: profile:
12:     tracing: true
13: ```


./docs\premium\tun-device.md
1: ---
2: sidebarTitle: "Feature: TUN Device"
3: sidebarOrder: 2
4: ---
5: 
6: # TUN Device
7: 
8: The Premium core has out-of-the-box support of TUN device. Being a Network layer device, it can be used to handle TCP, UDP, ICMP traffic. It has been extensively tested and used in production environments - you can even play competitive games with it.
9: 
10: One of the biggest advantage of using Clash TUN is the built-in support of the *automagic* management of the route table, routing rules and nftable. You can enable it with the options `tun.auto-route` and `tun.auto-redir`. It's a drop-in replacement of the ancient configuration option `redir-port` (TCP) for the sake of easier configuration and better stability.
11: 
12: ::: tip
13: `tun.auto-route` is only available on macOS, Windows, Linux and Android, and only receives IPv4 traffic. `tun.auto-redir` is only available on Linux(needs netlink support in the kernel).
14: :::
15: 
16: There are two options of TCP/IP stack available: `system` or `gvisor`. In order to get the best performance available, we recommend that you always use `system` stack unless you have a specific reason or compatibility issue to use `gvisor`. If that's the case, do not hesitate to [submit an issue](https://github.com/Dreamacro/clash/issues/new/choose).
17: 
18: ## Technical Limitations
19: 
20: * For Android, the control device is at `/dev/tun` instead of `/dev/net/tun`, you will need to create a symbolic link first (i.e. `ln -sf /dev/tun /dev/net/tun`)
21: 
22: * DNS hijacking might result in a failure, if the system DNS is at a private IP address (since `auto-route` does not capture private network traffic).
23: 
24: ## Linux, macOS or Android
25: 
26: This is an example configuration of the TUN feature:
27: 
28: ```yaml
29: interface-name: en0 # conflict with `tun.auto-detect-interface`
30: 
31: tun:
32:   enable: true
33:   stack: system # or gvisor
34:   # dns-hijack:
35:   #   - 8.8.8.8:53
36:   #   - tcp://8.8.8.8:53
37:   #   - any:53
38:   #   - tcp://any:53
39:   auto-route: true # manage `ip route` and `ip rules`
40:   auto-redir: true # manage nftable REDIRECT
41:   auto-detect-interface: true # conflict with `interface-name`
42: ```
43: 
44: Be advised, since the use of TUN device and manipulation of system route/nft settings, Clash will need superuser privileges to run.
45: 
46: ```shell
47: sudo ./clash
48: ```
49: 
50: If your device already has some TUN device, Clash TUN might not work - you will have to check the route table and routing rules manually. In this case, `fake-ip-filter` may helpful as well.
51: 
52: ## Windows
53: 
54: You will need to visit the [WinTUN website](https://www.wintun.net) and download the latest release. After that, copy `wintun.dll` into Clash home directory. Example configuration:
55: 
56: ```yaml
57: tun:
58:   enable: true
59:   stack: gvisor # or system
60:   dns-hijack:
61:     - 198.18.0.2:53 # when `fake-ip-range` is 198.18.0.1/16, should hijack 198.18.0.2:53
62:   auto-route: true # auto set global route for Windows
63:   # It is recommended to use `interface-name`
64:   auto-detect-interface: true # auto detect interface, conflict with `interface-name`
65: ```


./docs\premium\userspace-wireguard.md
1: ---
2: sidebarTitle: "Feature: Userspace Wireguard"
3: sidebarOrder: 7
4: ---
5: 
6: # Userspace Wireguard
7: 
8: Due to the dependency on gvisor TCP/IP stack, Wireguard outbound is currently only available in the Premium core.
9: 
10: ```yaml
11: proxies:
12:   - name: "wg"
13:     type: wireguard
14:     server: 127.0.0.1
15:     port: 443
16:     ip: 172.16.0.2
17:     # ipv6: your_ipv6
18:     private-key: eCtXsJZ27+4PbhDkHnB923tkUn2Gj59wZw5wFA75MnU=
19:     public-key: Cr8hWlKvtDt7nrvf+f0brNQQzabAqrjfBvas9pmowjo=
20:     # preshared-key: base64
21:     # remote-dns-resolve: true # remote resolve DNS with `dns` field, default is true
22:     # dns: [1.1.1.1, 8.8.8.8]
23:     # mtu: 1420
24:     udp: true
25: ```


./docs\runtime\external-controller.md
1: ---
2: sidebarTitle: The External Controller
3: sidebarOrder: 1
4: ---
5: 
6: # The External Controller
7: 
8: ## Introduction
9: 
10: External Controller enables users to control Clash programmatically with the HTTP RESTful API. The third-party Clash GUIs are heavily based on this feature. Enable this feature by specifying an address in `external-controller`.
11: 
12: ## Authentication
13: 
14: - External Controllers Accept `Bearer Tokens` as access authentication method.
15:   - Use `Authorization: Bearer <Your Secret>` as your request header in order to pass credentials.
16: 
17: ## RESTful API Documentation
18: 
19: ### Logs
20: 
21: - `/logs`
22:   - Method: `GET`
23:     - Full Path: `GET /logs`
24:     - Description: Get real-time logs
25: 
26: ### Traffic
27: 
28: - `/traffic`
29:   - Method: `GET`
30:     - Full Path: `GET /traffic`
31:     - Description: Get real-time traffic data
32: 
33: ### Version
34: 
35: - `/version`
36:   - Method: `GET`
37:     - Full Path: `GET /version`
38:     - Description: Get clash version
39: 
40: ### Configs
41: 
42: - `/configs`
43:   - Method: `GET`
44:     - Full Path: `GET /configs`
45:     - Description: Get base configs
46: 
47:   - Method: `PUT`
48:     - Full Path: `PUT /configs`
49:     - Description: Reloading base configs
50: 
51:   - Method: `PATCH`
52:     - Full Path: `PATCH /configs`
53:     - Description: Update base configs
54: 
55: ### Proxies
56: 
57: - `/proxies`
58:   - Method: `GET`
59:     - Full Path: `GET /proxies`
60:     - Description: Get proxies information
61: 
62: - `/proxies/:name`
63:   - Method: `GET`
64:     - Full Path: `GET /proxies/:name`
65:     - Description: Get specific proxy information
66: 
67:   - Method: `PUT`
68:     - Full Path: `PUT /proxies/:name`
69:     - Description: Select specific proxy
70: 
71: - `/proxies/:name/delay`
72:   - Method: `GET`
73:     - Full Path: `GET /proxies/:name/delay`
74:     - Description: Get specific proxy delay test information
75: 
76: ### Rules
77: 
78: - `/rules`
79:   - Method: `GET`
80:     - Full Path: `GET /rules`
81:     - Description: Get rules information
82: 
83: ### Connections
84: 
85: - `/connections`
86:   - Method: `GET`
87:     - Full Path: `GET /connections`
88:     - Description: Get connections information
89: 
90:   - Method: `DELETE`
91:     - Full Path: `DELETE /connections`
92:     - Description: Close all connections
93: 
94: - `/connections/:id`
95:   - Method: `DELETE`
96:     - Full Path: `DELETE /connections/:id`
97:     - Description: Close specific connection
98: 
99: ### Providers
100: 
101: - `/providers/proxies`
102:   - Method: `GET`
103:     - Full Path: `GET /providers/proxies`
104:     - Description: Get all proxies information for all proxy-providers
105: 
106: - `/providers/proxies/:name`
107:   - Method: `GET`
108:     - Full Path: `GET /providers/proxies/:name`
109:     - Description: Get proxies information for specific proxy-provider
110: 
111:   - Method: `PUT`
112:     - Full Path: `PUT /providers/proxies/:name`
113:     - Description: Select specific proxy-provider
114: 
115: - `/providers/proxies/:name/healthcheck`
116:   - Method: `GET`
117:     - Full Path: `GET /providers/proxies/:name/healthcheck`
118:     - Description: Get proxies information for specific proxy-provider
119: 
120: ### DNS Query
121: 
122: - `/dns/query`
123:   - Method: `GET`
124:   - Full Path: `GET /dns/query?name={name}[&type={type}]`
125:   - Description: Get DNS query data for a specified name and type.
126:   - Parameters:
127:     - `name` (required): The domain name to query.
128:     - `type` (optional): The DNS record type to query (e.g., A, MX, CNAME, etc.). Defaults to `A` if not provided.
129: 
130:   - Example: `GET /dns/query?name=example.com&type=A`


./docs\zh_CN\index.md
1: <!-- 这是 index 页面, 由位于 Introduction/_dummy-index.md 的虚拟侧边栏文件链接 -->
2: # 什么是 Clash?
3: 
4: 欢迎访问 Clash 内核项目的官方说明文档.
5: 
6: Clash是一个跨平台的基于规则的代理工具, 在网络和应用层运行, 支持各种代理和反审查协议的开箱即用.
7: 
8: 在一些互联网受到严格审查或封锁的国家和地区, 它已被互联网用户广泛采用. 无论如何, 任何想要改善其 Internet 体验的人都可以使用 Clash.
9: 
10: 目前, Clash 包含两个版本:
11: 
12: - [Clash](https://github.com/Dreamacro/clash): 发布于[github.com/Dreamacro/clash](https://github.com/Dreamacro/clash)的开源版本
13: - [Clash Premium 版本](https://github.com/Dreamacro/clash/releases/tag/premium): 具有[TUN 和更多支持](/zh_CN/premium/introduction) 的专有内核 (免费)
14: 
15: 虽然这个 Wiki 涵盖了上述两个版本的内容, 然而对于普通用户来说, Clash 的使用可能仍是一种挑战. 而对于考虑使用 GUI 客户端的用户, 我们确实有一些建议:
16: 
17: - [Clash for Windows](https://github.com/Fndroid/clash_for_windows_pkg/releases) (Windows 和 macOS)
18: - [Clash for Android](https://github.com/Kr328/ClashForAndroid)
19: - [ClashX](https://github.com/yichengchen/clashX) 或 [ClashX Pro](https://install.appcenter.ms/users/clashx/apps/clashx-pro/distribution_groups/public) (macOS)
20: 
21: ## 特点概述
22: 
23: - 入站连接支持: HTTP, HTTPS, SOCKS5 服务端, TUN 设备*
24: - 出站连接支持: Shadowsocks(R), VMess, Trojan, Snell, SOCKS5, HTTP(S), Wireguard*
25: - 基于规则的路由: 动态脚本、域名、IP地址、进程名称和更多*
26: - Fake-IP DNS: 尽量减少 DNS 污染的影响, 提高网络性能
27: - 透明代理: 使用自动路由表/规则管理 Redirect TCP 和 TProxy TCP/UDP*
28: - Proxy Groups 策略组: 自动化的可用性测试 (fallback)、负载均衡 (load balance) 或 延迟测试 (url-test)
29: - 远程 Providers: 动态加载远程代理列表
30: - RESTful API: 通过一个全面的 API 就地更新配置
31: 
32: <!-- markdownlint-disable MD033 -->
33: <small>\*: 只在免费的 Premium 版本中提供. </small>
34: <!-- markdownlint-enable MD033 -->
35: 
36: ## License
37: 
38: Clash 是根据 [GPL-3.0](https://github.com/Dreamacro/clash/blob/master/LICENSE) 开源许可证发布的. 在 [v0.16.0](https://github.com/Dreamacro/clash/releases/tag/v0.16.0) 或 [e5284c](https://github.com/Dreamacro/clash/commit/e5284cf647717a8087a185d88d15a01096274bc2) 提交之前, 其基于 MIT 许可证授权.


./docs\zh_CN\advanced-usages\golang-api.md
1: ---
2: sidebarTitle: 在 Golang 程序中集成 Clash
3: sidebarOrder: 3
4: ---
5: 
6: # 在 Golang 程序中集成 Clash
7: 
8: 如果 Clash 不能满足您的需求, 您可以在自己的 Golang 代码中使用 Clash.
9: 
10: 目前已经有基本的支持:
11: 
12: ```go
13: package main
14: 
15: import (
16: 	"context"
17: 	"fmt"
18: 	"io"
19: 	"net"
20: 
21: 	"github.com/Dreamacro/clash/adapter/outbound"
22: 	"github.com/Dreamacro/clash/constant"
23: 	"github.com/Dreamacro/clash/listener/socks"
24: )
25: 
26: func main() {
27: 	in := make(chan constant.ConnContext, 100)
28: 	defer close(in)
29: 
30: 	l, err := socks.New("127.0.0.1:10000", in)
31: 	if err != nil {
32: 		panic(err)
33: 	}
34: 	defer l.Close()
35: 
36: 	println("listen at:", l.Address())
37: 
38: 	direct := outbound.NewDirect()
39: 
40: 	for c := range in {
41: 		conn := c
42: 		metadata := conn.Metadata()
43: 		fmt.Printf("请求从 %s 传入到 %s\n", metadata.SourceAddress(), metadata.RemoteAddress())
44: 		go func () {
45: 			remote, err := direct.DialContext(context.Background(), metadata)
46: 			if err != nil {
47: 				fmt.Printf("Dial 错误: %s\n", err.Error())
48: 				return
49: 			}
50: 			relay(remote, conn.Conn())
51: 		}()
52: 	}
53: }
54: 
55: func relay(l, r net.Conn) {
56: 	go io.Copy(l, r)
57: 	io.Copy(r, l)
58: }
59: ```


./docs\zh_CN\advanced-usages\openconnect.md
1: ---
2: sidebarTitle: 基于规则的 OpenConnect
3: sidebarOrder: 2
4: ---
5: 
6: # 基于规则的 OpenConnect
7: 
8: 支持以下 OpenConnect:
9: 
10: - Cisco AnyConnect SSL VPN
11: - Juniper Network Connect
12: - Palo Alto Networks (PAN) GlobalProtect SSL VPN
13: - Pulse Connect Secure SSL VPN
14: - F5 BIG-IP SSL VPN
15: - FortiGate SSL VPN
16: - Array Networks SSL VPN
17: 
18: 例如, 您的公司使用 Cisco AnyConnect 作为内部网络访问的方式. 这里我将向您展示如何使用 Clash 提供的策略路由来使用 OpenConnect.
19: 
20: 首先, [安装 vpn-slice](https://github.com/dlenski/vpn-slice#requirements). 这个工具会覆写 OpenConnect 的默认路由表行为. 简单来说, 它会阻止 VPN 覆写您的默认路由.
21: 
22: 接下来您需要一个脚本 (比如 `tun0.sh`) 类似于这样:
23: 
24: ```sh
25: #!/bin/bash
26: ANYCONNECT_HOST="vpn.example.com"
27: ANYCONNECT_USER="john"
28: ANYCONNECT_PASSWORD="foobar"
29: ROUTING_TABLE_ID="6667"
30: TUN_INTERFACE="tun0"
31: 
32: # 如果服务器在中国大陆, 请添加 --no-dtls. 中国大陆的 UDP 会很卡.
33: echo "$ANYCONNECT_PASSWORD" | \
34:   openconnect \
35:     --non-inter \
36:     --passwd-on-stdin \
37:     --protocol=anyconnect \
38:     --interface $TUN_INTERFACE \
39:     --script "vpn-slice
40: if [ \"\$reason\" = 'connect' ]; then
41:   ip rule add from \$INTERNAL_IP4_ADDRESS table $ROUTING_TABLE_ID
42:   ip route add default dev \$TUNDEV scope link table $ROUTING_TABLE_ID
43: elif [ \"\$reason\" = 'disconnect' ]; then
44:   ip rule del from \$INTERNAL_IP4_ADDRESS table $ROUTING_TABLE_ID
45:   ip route del default dev \$TUNDEV scope link table $ROUTING_TABLE_ID
46: fi" \
47:     --user $ANYCONNECT_USER \
48:     https://$ANYCONNECT_HOST
49: ```
50: 
51: 之后, 我们将其配置成一个 systemd 服务. 创建 `/etc/systemd/system/tun0.service`:
52: 
53: ```ini
54: [Unit]
55: Description=Cisco AnyConnect VPN
56: After=network-online.target
57: Conflicts=shutdown.target sleep.target
58: 
59: [Service]
60: Type=simple
61: ExecStart=/path/to/tun0.sh
62: KillSignal=SIGINT
63: Restart=always
64: RestartSec=3
65: StartLimitIntervalSec=0
66: 
67: [Install]
68: WantedBy=multi-user.target
69: ```
70: 
71: 然后我们启用并启动服务.
72: 
73: ```shell
74: chmod +x /path/to/tun0.sh
75: systemctl daemon-reload
76: systemctl enable tun0
77: systemctl start tun0
78: ```
79: 
80: 这里您可以查看日志来查看它是否正常运行. 简单的方法是查看 `tun0` 接口是否已经创建.
81: 
82: 和 Wireguard 类似, 将 TUN 设备作为出站很简单, 只需要添加一个策略组:
83: 
84: ```yaml
85: proxy-groups:
86:   - name: Cisco AnyConnect VPN
87:     type: select
88:     interface-name: tun0
89:     proxies:
90:       - DIRECT
91: ```
92: 
93: ... 然后就可以使用了!
94: 
95: 添加您想要的规则:
96: 
97: ```yaml
98: rules:
99:   - DOMAIN-SUFFIX,internal.company.com,Cisco AnyConnect VPN
100: ```
101: 
102: 当您发现有问题时, 您应该查看 debug 级别的日志.


./docs\zh_CN\advanced-usages\wireguard.md
1: ---
2: sidebarTitle: 基于规则的 Wireguard
3: sidebarOrder: 1
4: ---
5: 
6: # 基于规则的 Wireguard
7: 
8: 假设您的内核支持 Wireguard 并且您已经启用了它. `Table` 选项可以阻止 _wg-quick_ 覆写默认路由.
9: 
10: 例如 `wg0.conf`:
11: 
12: ```ini
13: [Interface]
14: PrivateKey = ...
15: Address = 172.16.0.1/32
16: MTU = ...
17: Table = off
18: PostUp = ip rule add from 172.16.0.1/32 table 6666
19: 
20: [Peer]
21: AllowedIPs = 0.0.0.0/0
22: AllowedIPs = ::/0
23: PublicKey = ...
24: Endpoint = ...
25: ```
26: 
27: 然后在 Clash 中您只需要有一个 DIRECT 策略组, 它包含一个指定的出站接口:
28: 
29: ```yaml
30: proxy-groups:
31:   - name: Wireguard
32:     type: select
33:     interface-name: wg0
34:     proxies:
35:       - DIRECT
36: rules:
37:   - DOMAIN,google.com,Wireguard
38: ```
39: 
40: 这通常比 Clash 自己实现的用户空间 Wireguard 客户端性能更好. Wireguard 在内核中支持.


./docs\zh_CN\configuration\configuration-reference.md
1: ---
2: sidebarTitle: 参考配置
3: sidebarOrder: 7
4: ---
5: 
6: # 参考配置
7: 
8: ```yaml
9: # HTTP(S) 代理服务端口
10: port: 7890
11: 
12: # SOCKS5 代理服务端口
13: socks-port: 7891
14: 
15: # Linux 和 macOS 的透明代理服务端口 (TCP 和 TProxy UDP 重定向)
16: # redir-port: 7892
17: 
18: # Linux 的透明代理服务端口 (TProxy TCP 和 TProxy UDP)
19: # tproxy-port: 7893
20: 
21: # HTTP(S) 和 SOCKS4(A)/SOCKS5 代理服务共用一个端口
22: # mixed-port: 7890
23: 
24: # 本地 SOCKS5/HTTP(S) 代理服务的认证
25: # authentication:
26: #  - "user1:pass1"
27: #  - "user2:pass2"
28: 
29: # 设置为 true 以允许来自其他 LAN IP 地址的连接
30: # allow-lan: false
31: 
32: # 仅当 `allow-lan` 为 `true` 时有效
33: # '*': 绑定所有 IP 地址
34: # 192.168.122.11: 绑定单个 IPv4 地址
35: # "[aaaa::a8aa:ff:fe09:57d8]": 绑定单个 IPv6 地址
36: # bind-address: '*'
37: 
38: # Clash 路由工作模式
39: # rule: 基于规则的数据包路由
40: # global: 所有数据包将被转发到单个节点
41: # direct: 直接将数据包转发到互联网
42: mode: rule
43: 
44: # 默认情况下, Clash 将日志打印到 STDOUT
45: # 日志级别: info / warning / error / debug / silent
46: # log-level: info
47: 
48: # 当设置为 false 时, 解析器不会将主机名解析为 IPv6 地址
49: # ipv6: false
50: 
51: # RESTful Web API 监听地址
52: external-controller: 127.0.0.1:9090
53: 
54: # 配置目录的相对路径或静态 Web 资源目录的绝对路径. Clash core 将在
55: # `http://{{external-controller}}/ui` 中提供服务.
56: # external-ui: folder
57: 
58: # RESTful API 密钥 (可选)
59: # 通过指定 HTTP 头 `Authorization: Bearer ${secret}` 进行身份验证
60: # 如果RESTful API在 0.0.0.0 上监听, 务必设置一个 secret 密钥.
61: # secret: ""
62: 
63: # 出站接口名称
64: # interface-name: en0
65: 
66: # fwmark (仅在 Linux 上有效)
67: # routing-mark: 6666
68: 
69: # 用于DNS服务器和连接建立的静态主机 (如/etc/hosts) .
70: #
71: # 支持通配符主机名 (例如 *.clash.dev, *.foo.*.example.com)
72: # 非通配符域名优先级高于通配符域名
73: # 例如 foo.example.com > *.example.com > .example.com
74: # P.S. +.foo.com 等于 .foo.com 和 foo.com
75: # hosts:
76:   # '*.clash.dev': 127.0.0.1
77:   # '.dev': 127.0.0.1
78:   # 'alpha.clash.dev': '::1'
79: 
80: # profile:
81:   # 将 `select` 手动选择 结果存储在 $HOME/.config/clash/.cache 中
82:   # 如果不需要此行为, 请设置为 false
83:   # 当两个不同的配置具有同名的组时, 将共享所选值
84:   # store-selected: true
85: 
86:   # 持久化 fakeip
87:   # store-fake-ip: false
88: 
89: # DNS 服务设置
90: # 此部分是可选的. 当不存在时, DNS 服务将被禁用.
91: dns:
92:   enable: false
93:   listen: 0.0.0.0:53
94:   # ipv6: false # 当为 false 时, AAAA 查询的响应将为空
95: 
96:   # 这些 名称服务器(nameservers) 用于解析下列 DNS 名称服务器主机名.
97:   # 仅指定 IP 地址
98:   default-nameserver:
99:     - 114.114.114.114
100:     - 8.8.8.8
101:   # enhanced-mode: fake-ip
102:   fake-ip-range: 198.18.0.1/16 # Fake IP 地址池 CIDR
103:   # use-hosts: true # 查找 hosts 并返回 IP 记录
104: 
105:   # search-domains: [local] # A/AAAA 记录的搜索域
106: 
107:   # 此列表中的主机名将不会使用 Fake IP 解析
108:   # 即, 对这些域名的请求将始终使用其真实 IP 地址进行响应
109:   # fake-ip-filter:
110:   #   - '*.lan'
111:   #   - localhost.ptlogin2.qq.com
112: 
113:   # 支持 UDP、TCP、DoT、DoH. 您可以指定要连接的端口.
114:   # 所有 DNS 查询都直接发送到名称服务器, 无需代理
115:   # Clash 使用第一个收到的响应作为 DNS 查询的结果.
116:   nameserver:
117:     - 114.114.114.114 # 默认值
118:     - 8.8.8.8 # 默认值
119:     - tls://dns.rubyfish.cn:853 # DNS over TLS
120:     - https://1.1.1.1/dns-query # DNS over HTTPS
121:     - dhcp://en0 # 来自 dhcp 的 dns
122:     # - '8.8.8.8#en0'
123: 
124:   # 当 `fallback` 存在时, DNS 服务器将向此部分中的服务器
125:   # 与 `nameservers` 中的服务器发送并发请求
126:   # 当 GEOIP 国家不是 `CN` 时, 将使用 fallback 服务器的响应
127:   # fallback:
128:   #   - tcp://1.1.1.1
129:   #   - 'tcp://1.1.1.1#en0'
130: 
131:   # 如果使用 `nameservers` 解析的 IP 地址在下面指定的子网中,
132:   # 则认为它们无效, 并使用 `fallback` 服务器的结果.
133:   #
134:   # 当 `fallback-filter.geoip` 为 true 且 IP 地址的 GEOIP 为 `CN` 时,
135:   # 将使用 `nameservers` 服务器解析的 IP 地址.
136:   #
137:   # 如果 `fallback-filter.geoip` 为 false, 且不匹配 `fallback-filter.ipcidr`,
138:   # 则始终使用 `nameservers` 服务器的结果
139:   #
140:   # 这是对抗 DNS 污染攻击的一种措施.
141:   # fallback-filter:
142:   #   geoip: true
143:   #   geoip-code: CN
144:   #   ipcidr:
145:   #     - 240.0.0.0/4
146:   #   domain:
147:   #     - '+.google.com'
148:   #     - '+.facebook.com'
149:   #     - '+.youtube.com'
150: 
151:   # 通过特定的名称服务器查找域名
152:   # nameserver-policy:
153:   #   'www.baidu.com': '114.114.114.114'
154:   #   '+.internal.crop.com': '10.0.0.1'
155: 
156: proxies:
157:   # Shadowsocks
158:   # 支持的加密方法:
159:   #   aes-128-gcm aes-192-gcm aes-256-gcm
160:   #   aes-128-cfb aes-192-cfb aes-256-cfb
161:   #   aes-128-ctr aes-192-ctr aes-256-ctr
162:   #   rc4-md5 chacha20-ietf xchacha20
163:   #   chacha20-ietf-poly1305 xchacha20-ietf-poly1305
164:   - name: "ss1"
165:     type: ss
166:     server: server
167:     port: 443
168:     cipher: chacha20-ietf-poly1305
169:     password: "password"
170:     # udp: true
171: 
172:   - name: "ss2"
173:     type: ss
174:     server: server
175:     port: 443
176:     cipher: chacha20-ietf-poly1305
177:     password: "password"
178:     plugin: obfs
179:     plugin-opts:
180:       mode: tls # or http
181:       # host: bing.com
182: 
183:   - name: "ss3"
184:     type: ss
185:     server: server
186:     port: 443
187:     cipher: chacha20-ietf-poly1305
188:     password: "password"
189:     plugin: v2ray-plugin
190:     plugin-opts:
191:       mode: websocket # 暂不支持 QUIC
192:       # tls: true # wss
193:       # skip-cert-verify: true
194:       # host: bing.com
195:       # path: "/"
196:       # mux: true
197:       # headers:
198:       #   custom: value
199: 
200:   # vmess
201:   # 支持的加密方法:
202:   #  auto/aes-128-gcm/chacha20-poly1305/none
203:   - name: "vmess"
204:     type: vmess
205:     server: server
206:     port: 443
207:     uuid: uuid
208:     alterId: 32
209:     cipher: auto
210:     # udp: true
211:     # tls: true
212:     # skip-cert-verify: true
213:     # servername: example.com # 优先于 wss 主机
214:     # network: ws
215:     # ws-opts:
216:     #   path: /path
217:     #   headers:
218:     #     Host: v2ray.com
219:     #   max-early-data: 2048
220:     #   early-data-header-name: Sec-WebSocket-Protocol
221: 
222:   - name: "vmess-h2"
223:     type: vmess
224:     server: server
225:     port: 443
226:     uuid: uuid
227:     alterId: 32
228:     cipher: auto
229:     network: h2
230:     tls: true
231:     h2-opts:
232:       host:
233:         - http.example.com
234:         - http-alt.example.com
235:       path: /
236: 
237:   - name: "vmess-http"
238:     type: vmess
239:     server: server
240:     port: 443
241:     uuid: uuid
242:     alterId: 32
243:     cipher: auto
244:     # udp: true
245:     # network: http
246:     # http-opts:
247:     #   # method: "GET"
248:     #   # path:
249:     #   #   - '/'
250:     #   #   - '/video'
251:     #   # headers:
252:     #   #   Connection:
253:     #   #     - keep-alive
254: 
255:   - name: vmess-grpc
256:     server: server
257:     port: 443
258:     type: vmess
259:     uuid: uuid
260:     alterId: 32
261:     cipher: auto
262:     network: grpc
263:     tls: true
264:     servername: example.com
265:     # skip-cert-verify: true
266:     grpc-opts:
267:       grpc-service-name: "example"
268: 
269:   # socks5
270:   - name: "socks"
271:     type: socks5
272:     server: server
273:     port: 443
274:     # username: username
275:     # password: password
276:     # tls: true
277:     # skip-cert-verify: true
278:     # udp: true
279: 
280:   # http
281:   - name: "http"
282:     type: http
283:     server: server
284:     port: 443
285:     # username: username
286:     # password: password
287:     # tls: true # https
288:     # skip-cert-verify: true
289:     # sni: custom.com
290: 
291:   # Snell
292:   # 请注意, 目前还没有UDP支持.
293:   - name: "snell"
294:     type: snell
295:     server: server
296:     port: 44046
297:     psk: yourpsk
298:     # version: 2
299:     # obfs-opts:
300:       # mode: http # or tls
301:       # host: bing.com
302: 
303:   # Trojan
304:   - name: "trojan"
305:     type: trojan
306:     server: server
307:     port: 443
308:     password: yourpsk
309:     # udp: true
310:     # sni: example.com # aka 服务器名称
311:     # alpn:
312:     #   - h2
313:     #   - http/1.1
314:     # skip-cert-verify: true
315: 
316:   - name: trojan-grpc
317:     server: server
318:     port: 443
319:     type: trojan
320:     password: "example"
321:     network: grpc
322:     sni: example.com
323:     # skip-cert-verify: true
324:     udp: true
325:     grpc-opts:
326:       grpc-service-name: "example"
327: 
328:   - name: trojan-ws
329:     server: server
330:     port: 443
331:     type: trojan
332:     password: "example"
333:     network: ws
334:     sni: example.com
335:     # skip-cert-verify: true
336:     udp: true
337:     # ws-opts:
338:       # path: /path
339:       # headers:
340:       #   Host: example.com
341: 
342:   # ShadowsocksR
343:   # 支持的加密方法: ss 中的所有流加密方法
344:   # 支持的混淆方式:
345:   #   plain http_simple http_post
346:   #   random_head tls1.2_ticket_auth tls1.2_ticket_fastauth
347:   # 支持的协议:
348:   #   origin auth_sha1_v4 auth_aes128_md5
349:   #   auth_aes128_sha1 auth_chain_a auth_chain_b
350:   - name: "ssr"
351:     type: ssr
352:     server: server
353:     port: 443
354:     cipher: chacha20-ietf
355:     password: "password"
356:     obfs: tls1.2_ticket_auth
357:     protocol: auth_sha1_v4
358:     # obfs-param: domain.tld
359:     # protocol-param: "#"
360:     # udp: true
361: 
362: proxy-groups:
363:   # 中继链路代理节点. 节点不应包含中继. 不支持 UDP.
364:   # 流量节点链路: clash <-> http <-> vmess <-> ss1 <-> ss2 <-> Internet
365:   - name: "relay"
366:     type: relay
367:     proxies:
368:       - http
369:       - vmess
370:       - ss1
371:       - ss2
372: 
373:   # url-test 通过对 指定URL 进行基准速度测试来选择将使用哪个代理.
374:   - name: "auto"
375:     type: url-test
376:     proxies:
377:       - ss1
378:       - ss2
379:       - vmess1
380:     # tolerance: 150
381:     # lazy: true
382:     url: 'http://www.gstatic.com/generate_204'
383:     interval: 300
384: 
385:   # fallback-auto 基于优先级选择可用策略. 可用性通过访问 指定URL 来测试, 就像自动 url-test 组一样.
386:   - name: "fallback-auto"
387:     type: fallback
388:     proxies:
389:       - ss1
390:       - ss2
391:       - vmess1
392:     url: 'http://www.gstatic.com/generate_204'
393:     interval: 300
394: 
395:   # 负载均衡: 同一 eTLD+1 的请求将拨号到同一代理.
396:   - name: "load-balance"
397:     type: load-balance
398:     proxies:
399:       - ss1
400:       - ss2
401:       - vmess1
402:     url: 'http://www.gstatic.com/generate_204'
403:     interval: 300
404:     # strategy: consistent-hashing # or round-robin
405: 
406:   # select 手动选择, 用于选择代理或策略组
407:   # 您可以使用 RESTful API 来切换代理, 建议在GUI中切换.
408:   - name: Proxy
409:     type: select
410:     # disable-udp: true
411:     # filter: 'someregex'
412:     proxies:
413:       - ss1
414:       - ss2
415:       - vmess1
416:       - auto
417: 
418:   # 直接连接到另一个接口名称或 fwmark, 也支持代理
419:   - name: en1
420:     type: select
421:     interface-name: en1
422:     routing-mark: 6667
423:     proxies:
424:       - DIRECT
425: 
426:   - name: UseProvider
427:     type: select
428:     use:
429:       - provider1
430:     proxies:
431:       - Proxy
432:       - DIRECT
433: 
434: proxy-providers:
435:   provider1:
436:     type: http
437:     url: "url"
438:     interval: 3600
439:     path: ./provider1.yaml
440:     health-check:
441:       enable: true
442:       interval: 600
443:       # lazy: true
444:       url: http://www.gstatic.com/generate_204
445:   test:
446:     type: file
447:     path: /test.yaml
448:     health-check:
449:       enable: true
450:       interval: 36000
451:       url: http://www.gstatic.com/generate_204
452: 
453: tunnels:
454:   # 单行配置
455:   - tcp/udp,127.0.0.1:6553,114.114.114.114:53,proxy
456:   - tcp,127.0.0.1:6666,rds.mysql.com:3306,vpn
457:   # 全 yaml 配置
458:   - network: [tcp, udp]
459:     address: 127.0.0.1:7777
460:     target: target.com
461:     proxy: proxy
462: 
463: rules:
464:   - DOMAIN-SUFFIX,google.com,auto
465:   - DOMAIN-KEYWORD,google,auto
466:   - DOMAIN,google.com,auto
467:   - DOMAIN-SUFFIX,ad.com,REJECT
468:   - SRC-IP-CIDR,192.168.1.201/32,DIRECT
469:   # 用于 IP 规则 (GEOIP, IP-CIDR, IP-CIDR6) 的可选参数 "no-resolve"
470:   - IP-CIDR,127.0.0.0/8,DIRECT
471:   - GEOIP,CN,DIRECT
472:   - DST-PORT,80,DIRECT
473:   - SRC-PORT,7777,DIRECT
474:   - RULE-SET,apple,REJECT # 仅 Premium 版本支持
475:   - MATCH,auto
476: ```


./docs\zh_CN\configuration\dns.md
1: ---
2: sidebarTitle: Clash DNS
3: sidebarOrder: 6
4: ---
5: 
6: # Clash DNS
7: 
8: 由于 Clash 的某些部分运行在第 3 层 (网络层) , 因此其数据包的域名是无法获取的, 也就无法进行基于规则的路由.
9: 
10: *Enter fake-ip*: 它支持基于规则的路由, 最大程度地减少了 DNS 污染攻击的影响, 并且提高了网络性能, 有时甚至是显著的.
11: 
12: ## fake-ip
13: 
14: "fake IP" 的概念源自 [RFC 3089](https://tools.ietf.org/rfc/rfc3089):
15: 
16: > 一个 "fake IP" 地址被用于查询相应的 "FQDN" 信息的关键字.
17: 
18: fake-ip 池的默认 CIDR 是 `198.18.0.1/16` (一个保留的 IPv4 地址空间, 可以在 `dns.fake-ip-range` 中进行更改).
19: 
20: 当 DNS 请求被发送到 Clash DNS 时, Clash 内核会通过管理内部的域名和其 fake-ip 地址的映射, 从池中分配一个 *空闲* 的 fake-ip 地址.
21: 
22: 以使用浏览器访问 `http://google.com` 为例.
23: 
24: 1. 浏览器向 Clash DNS 请求 `google.com` 的 IP 地址
25: 2. Clash 检查内部映射并返回 `198.18.1.5`
26: 3. 浏览器向 `198.18.1.5` 的 `80/tcp` 端口发送 HTTP 请求
27: 4. 当收到 `198.18.1.5` 的入站数据包时, Clash 查询内部映射, 发现客户端实际上是在向 `google.com` 发送数据包
28: 5. 根据规则的不同:
29: 
30:     1. Clash 可能仅将域名发送到 SOCKS5 或 shadowsocks 等出站代理, 并与代理服务器建立连接
31: 
32:     2. 或者 Clash 可能会基于 `SCRIPT`、`GEOIP`、`IP-CIDR` 规则或者使用 DIRECT 直连出口查询 `google.com` 的真实 IP 地址
33: 
34: 由于这是一个令人困惑的概念, 我将以使用 cURL 程序访问 `http://google.com` 为例:
35: 
36: ```txt{2,3,5,6,8,9}
37: $ curl -v http://google.com
38: <---- cURL 向您的系统 DNS (Clash) 询问 google.com 的 IP 地址
39: ----> Clash 决定使用 198.18.1.70 作为 google.com 的 IP 地址, 并记住它
40: *   Trying 198.18.1.70:80...
41: <---- cURL 连接到 198.18.1.70 tcp/80
42: ----> Clash 将立即接受连接, 并且..
43: * Connected to google.com (198.18.1.70) port 80 (#0)
44: ----> Clash 在其内存中查找到 198.18.1.70 对应于 google.com
45: ----> Clash 查询对应的规则, 并通过匹配的出口发送数据包
46: > GET / HTTP/1.1
47: > Host: google.com
48: > User-Agent: curl/8.0.1
49: > Accept: */*
50: >
51: < HTTP/1.1 301 Moved Permanently
52: < Location: http://www.google.com/
53: < Content-Type: text/html; charset=UTF-8
54: < Content-Security-Policy-Report-Only: object-src 'none';base-uri 'self';script-src 'nonce-ahELFt78xOoxhySY2lQ34A' 'strict-dynamic' 'report-sample' 'unsafe-eval' 'unsafe-inline' https: http:;report-uri https://csp.withgoogle.com/csp/gws/other-hp
55: < Date: Thu, 11 May 2023 06:52:19 GMT
56: < Expires: Sat, 10 Jun 2023 06:52:19 GMT
57: < Cache-Control: public, max-age=2592000
58: < Server: gws
59: < Content-Length: 219
60: < X-XSS-Protection: 0
61: < X-Frame-Options: SAMEORIGIN
62: <
63: <HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
64: <TITLE>301 Moved</TITLE></HEAD><BODY>
65: <H1>301 Moved</H1>
66: The document has moved
67: <A HREF="http://www.google.com/">here</A>.
68: </BODY></HTML>
69: * Connection #0 to host google.com left intact
70: ```
71: 
72: <!-- TODO: nameserver, fallback, fallback-filter, hosts, search-domains, fake-ip-filter, nameserver-policy -->


./docs\zh_CN\configuration\getting-started.md
1: ---
2: sidebarTitle: 快速入手
3: sidebarOrder: 2
4: ---
5: 
6: # 快速入手
7: 
8: 建议您在继续阅读本节之前, 先阅读[介绍](/zh_CN/configuration/introduction). 在您对Clash的工作原理有了简单的了解后, 您可以开始编写您自己的配置.
9: 
10: ## 配置文件
11: 
12: 主配置文件名为 `config.yaml`. 默认情况下, Clash会在 `$HOME/.config/clash` 目录读取配置文件. 如果该目录不存在, Clash会在该位置生成一个最小的配置文件.
13: 
14: 如果您想将配置文件放在其他地方 (例如 `/etc/clash`) , 您可以使用命令行选项 `-d` 来指定配置目录:
15: 
16: ```shell
17: clash -d . # current directory
18: clash -d /etc/clash
19: ```
20: 
21: 或者, 您可以使用选项 `-f` 来指定配置文件:
22: 
23: ```shell
24: clash -f ./config.yaml
25: clash -f /etc/clash/config.yaml
26: ```
27: 
28: ## 特殊语法
29: 
30: Clash 配置文件中有一些特殊的语法, 您可能需要了解:
31: 
32: ### IPv6 地址
33: 
34: 您应该使用方括号 (`[]`) 来包裹 IPv6 地址, 例如:
35: 
36: ```txt
37: [aaaa::a8aa:ff:fe09:57d8]
38: ```
39: 
40: ### DNS 通配符域名匹配
41: 
42: 在某些情况下, 您需要匹配通配符域名. 例如, 当您设置 [Clash DNS](/zh_CN/configuration/dns) 时, 您可能想要匹配 `localdomain` 的所有子域名.
43: 
44: Clash 在 DNS 配置中提供了匹配不同级别通配符域名的支持, 其语法如下:
45: 
46: ::: tip
47: 任何包含这些字符的域名都应该用单引号 (`'`) 包裹. 例如, `'*.google.com'`.
48: 静态域名的优先级高于通配符域名 (foo.example.com > *.example.com > .example.com) .
49: :::
50: 
51: 使用星号 (`*`) 来匹配单级通配符子域名.
52: 
53: | 表达式 | 匹配 | 不匹配 |
54: | ---------- | ------- | -------------- |
55: | `*.google.com` | `www.google.com` | `google.com` |
56: | `*.bar.google.com` | `foo.bar.google.com` | `bar.google.com` |
57: | `*.*.google.com` | `thoughtful.sandbox.google.com` | `one.two.three.google.com` |
58: 
59: 使用点号 (`.`) 来匹配多级通配符子域名.
60: 
61: | 表达式 | 匹配 | 不匹配 |
62: | ---------- | ------- | -------------- |
63: | `.google.com` | `www.google.com` | `google.com` |
64: | `.google.com` | `thoughtful.sandbox.google.com` | `google.com` |
65: | `.google.com` | `one.two.three.google.com` | `google.com` |
66: 
67: 使用加号 (`+`) 来匹配多级通配符子域名.
68: 
69: `+` 通配符的工作方式类似于 `DOMAIN-SUFFIX`, 您可以一次进行多级的快速匹配.
70: 
71: | 表达式 | 匹配 |
72: | ---------- | ------- |
73: | `+.google.com` | `google.com` |
74: | `+.google.com` | `www.google.com` |
75: | `+.google.com` | `thoughtful.sandbox.google.com` |
76: | `+.google.com` | `one.two.three.google.com` |


./docs\zh_CN\configuration\inbound.md
1: ---
2: sidebarTitle: Inbound 入站
3: sidebarOrder: 3
4: ---
5: 
6: # Inbound 入站
7: 
8: Clash 支持多种入站协议, 包括:
9: 
10: - SOCKS5
11: - HTTP(S)
12: - Redirect TCP
13: - TProxy TCP
14: - TProxy UDP
15: - Linux TUN 设备 (仅 Premium 版本)
16: 
17: 任何入站协议的连接都将由同一个内部规则匹配引擎处理. 也就是说, Clash **目前**不支持为不同的入站协议设置不同的规则集.
18: 
19: ## 配置
20: 
21: ```yaml
22: # HTTP(S) 代理服务端口
23: # port: 7890
24: 
25: # SOCKS5 代理服务端口
26: socks-port: 7891
27: 
28: # HTTP(S) 和 SOCKS4(A)/SOCKS5 代理服务共用一个端口
29: mixed-port: 7890
30: 
31: # Linux 和 macOS 的透明代理服务端口 (TCP 和 TProxy UDP 重定向)
32: # redir-port: 7892
33: 
34: # Linux 的透明代理服务端口 (TProxy TCP 和 TProxy UDP)
35: # tproxy-port: 7893
36: 
37: # 设置为 true 以允许来自其他 LAN IP 地址的连接
38: # allow-lan: false
39: ```
40: 
41: ## Mixed 混合端口
42: 
43: 混合端口是一个特殊的端口, 它同时支持 HTTP(S) 和 SOCKS5 协议. 您可以使用任何支持 HTTP 或 SOCKS 代理的程序连接到这个端口, 例如:
44: 
45: ```shell
46: $ curl -x socks5h://127.0.0.1:7890 -v http://connect.rom.miui.com/generate_204
47: *   Trying 127.0.0.1:7890...
48: * SOCKS5 connect to connect.rom.miui.com:80 (remotely resolved)
49: * SOCKS5 request granted.
50: * Connected to (nil) (127.0.0.1) port 7890 (#0)
51: > GET /generate_204 HTTP/1.1
52: > Host: connect.rom.miui.com
53: > User-Agent: curl/7.81.0
54: > Accept: */*
55: >
56: * Mark bundle as not supporting multiuse
57: < HTTP/1.1 204 No Content
58: < Date: Thu, 11 May 2023 06:18:22 GMT
59: < Connection: keep-alive
60: < Content-Type: text/plain
61: <
62: * Connection #0 to host (nil) left intact
63: ```
64: 
65: ## Redirect 和 TProxy
66: 
67: Redirect 和 TProxy 是两种实现透明代理的不同方式, 均被 Clash 所支持.
68: 
69: 然而, 您不一定需要手动设置这两个功能 - 我们建议您使用 [Clash Premium 版本](/zh_CN/premium/introduction) 来配置透明代理, 因为它内置了对操作系统路由表、规则和 nftables 的自动管理.


./docs\zh_CN\configuration\introduction.md
1: ---
2: sidebarTitle: 介绍
3: sidebarOrder: 1
4: ---
5: 
6: # 介绍
7: 
8: 在本章中, 我们将介绍 Clash 的常见功能以及如何使用和配置它们.
9: 
10: Clash 使用 [YAML](https://yaml.org) (YAML Ain't Markup Language) 作为配置文件格式. YAML 旨在易于阅读、编写和解析, 通常用于配置文件.
11: 
12: ## 了解 Clash 的工作原理
13: 
14: 在继续之前, 有必要了解 Clash 的工作原理, 其中有两个关键部分:
15: 
16: ![](/assets/connection-flow.png)
17: 
18: <!-- https://excalidraw.com/clash-connection-flow#json=OHsOdaqAUPuuN7VPvdZ9Z,NT7rRrtzRgbVIM0tpkPnGA -->
19: 
20: ### Inbound 入站
21: 
22: Inbound 入站是在本地端监听的部分, 它通过打开一个本地端口并监听传入的连接来工作. 当连接进来时, Clash 会查询配置文件中配置的规则, 并决定连接应该去哪个 Outbound 出站.
23: 
24: ### Outbound 出站
25: 
26: Outbound 出站是连接到远程端的部分. 根据配置的不同, 它可以是一个特定的网络接口、一个代理服务器或一个[策略组](/zh_CN/configuration/outbound#proxy-groups-策略组).
27: 
28: ## 基于规则的路由
29: 
30: Clash 支持基于规则的路由, 这意味着您可以根据各种规则将数据包路由到不同的出站. 规则可以在配置文件的 `rules` 部分中定义.
31: 
32: 有许多可用的规则类型, 每种规则类型都有自己的语法. 规则的一般语法是:
33: 
34: ```txt
35: # 类型,参数,策略(,no-resolve)
36: TYPE,ARGUMENT,POLICY(,no-resolve)
37: ```
38: 
39: 在下一步指南中, 您将了解有关如何配置规则的更多信息.


./docs\zh_CN\configuration\outbound.md
1: ---
2: sidebarTitle: Outbound 出站
3: sidebarOrder: 4
4: ---
5: 
6: # Outbound 出站
7: 
8: Clash 中有几种类型的出站. 每种类型都有自己的特点和使用场景. 在本页中, 我们将介绍每种类型的通用特点以及如何使用和配置它们.
9: 
10: [[toc]]
11: 
12: ## Proxies 代理节点
13: 
14: Proxies 代理节点是您可以配置的一些出站目标. 就像代理服务器一样, 您在这里为数据包定义目的地.
15: 
16: ### Shadowsocks
17: 
18: Clash 支持以下 Shadowsocks 的加密方法:
19: 
20: | 系列 | 加密方法 |
21: | ------ | ------- |
22: | AEAD | aes-128-gcm, aes-192-gcm, aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305 |
23: | 流式 | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |
24: | 块式 | aes-128-ctr, aes-192-ctr, aes-256-ctr |
25: 
26: 此外, Clash 还支持流行的 Shadowsocks 插件 `obfs` 和 `v2ray-plugin`.
27: 
28: ::: code-group
29: 
30: ```yaml [basic]
31: - name: "ss1"
32:   type: ss
33:   # interface-name: eth0
34:   # routing-mark: 1234
35:   server: server
36:   port: 443
37:   cipher: chacha20-ietf-poly1305
38:   password: "password"
39:   # udp: true
40: ```
41: 
42: ```yaml [obfs]
43: - name: "ss2"
44:   type: ss
45:   # interface-name: eth0
46:   # routing-mark: 1234
47:   server: server
48:   port: 443
49:   cipher: chacha20-ietf-poly1305
50:   password: "password"
51:   plugin: obfs
52:   plugin-opts:
53:     mode: tls # or http
54:     # host: bing.com
55: ```
56: 
57: ```yaml [ws (websocket)]
58: - name: "ss3"
59:   type: ss
60:   # interface-name: eth0
61:   # routing-mark: 1234
62:   server: server
63:   port: 443
64:   cipher: chacha20-ietf-poly1305
65:   password: "password"
66:   plugin: v2ray-plugin
67:   plugin-opts:
68:     mode: websocket # 暂不支持 QUIC
69:     # tls: true # wss
70:     # skip-cert-verify: true
71:     # host: bing.com
72:     # path: "/"
73:     # mux: true
74:     # headers:
75:     #   custom: value
76: ```
77: 
78: :::
79: 
80: ### ShadowsocksR
81: 
82: Clash 也支持声名狼藉的反审查协议 ShadowsocksR.
83: 
84: 支持以下 ShadowsocksR 的加密方法:
85: 
86: | 系列 | 加密方法 |
87: | ------ | ------- |
88: | 流式 | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |
89: 
90: 支持的混淆方法:
91: 
92: - plain
93: - http_simple
94: - http_post
95: - random_head
96: - tls1.2_ticket_auth
97: - tls1.2_ticket_fastauth
98: 
99: 支持的协议:
100: 
101: - origin
102: - auth_sha1_v4
103: - auth_aes128_md5
104: - auth_aes128_sha1
105: - auth_chain_a
106: - auth_chain_b
107: 
108: ```yaml
109: - name: "ssr"
110:   type: ssr
111:   # interface-name: eth0
112:   # routing-mark: 1234
113:   server: server
114:   port: 443
115:   cipher: chacha20-ietf
116:   password: "password"
117:   obfs: tls1.2_ticket_auth
118:   protocol: auth_sha1_v4
119:   # obfs-param: domain.tld
120:   # protocol-param: "#"
121:   # udp: true
122: ```
123: 
124: ### Vmess
125: 
126: Clash 支持以下 Vmess 的加密方法:
127: 
128: - auto
129: - aes-128-gcm
130: - chacha20-poly1305
131: - none
132: 
133: ::: code-group
134: 
135: ```yaml [basic]
136: - name: "vmess"
137:   type: vmess
138:   # interface-name: eth0
139:   # routing-mark: 1234
140:   server: server
141:   port: 443
142:   uuid: uuid
143:   alterId: 32
144:   cipher: auto
145:   # udp: true
146:   # tls: true
147:   # skip-cert-verify: true
148:   # servername: example.com # 优先于 wss 主机
149:   # network: ws
150:   # ws-opts:
151:   #   path: /path
152:   #   headers:
153:   #     Host: v2ray.com
154:   #   max-early-data: 2048
155:   #   early-data-header-name: Sec-WebSocket-Protocol
156: ```
157: 
158: ```yaml [HTTP]
159: - name: "vmess-http"
160:   type: vmess
161:   # interface-name: eth0
162:   # routing-mark: 1234
163:   server: server
164:   port: 443
165:   uuid: uuid
166:   alterId: 32
167:   cipher: auto
168:   # udp: true
169:   # network: http
170:   # http-opts:
171:   #   # method: "GET"
172:   #   # path:
173:   #   #   - '/'
174:   #   #   - '/video'
175:   #   # headers:
176:   #   #   Connection:
177:   #   #     - keep-alive
178: ```
179: 
180: ```yaml [HTTP/2]
181: - name: "vmess-h2"
182:   type: vmess
183:   # interface-name: eth0
184:   # routing-mark: 1234
185:   server: server
186:   port: 443
187:   uuid: uuid
188:   alterId: 32
189:   cipher: auto
190:   network: h2
191:   tls: true
192:   h2-opts:
193:     host:
194:       - http.example.com
195:       - http-alt.example.com
196:     path: /
197: ```
198: 
199: ```yaml [gRPC]
200: - name: vmess-grpc
201:   type: vmess
202:   # interface-name: eth0
203:   # routing-mark: 1234
204:   server: server
205:   port: 443
206:   uuid: uuid
207:   alterId: 32
208:   cipher: auto
209:   network: grpc
210:   tls: true
211:   servername: example.com
212:   # skip-cert-verify: true
213:   grpc-opts:
214:     grpc-service-name: "example"
215: ```
216: 
217: :::
218: 
219: ### Socks5
220: 
221: 此外, Clash 还支持 Socks5 代理.
222: 
223: ```yaml
224: - name: "socks"
225:   type: socks5
226:   # interface-name: eth0
227:   # routing-mark: 1234
228:   server: server
229:   port: 443
230:   # username: username
231:   # password: password
232:   # tls: true
233:   # skip-cert-verify: true
234:   # udp: true
235: ```
236: 
237: ### HTTP
238: 
239: Clash 也支持 HTTP 代理:
240: 
241: ::: code-group
242: 
243: ```yaml [HTTP]
244: - name: "http"
245:   type: http
246:   # interface-name: eth0
247:   # routing-mark: 1234
248:   server: server
249:   port: 443
250:   # username: username
251:   # password: password
252: ```
253: 
254: ```yaml [HTTPS]
255: - name: "http"
256:   type: http
257:   # interface-name: eth0
258:   # routing-mark: 1234
259:   server: server
260:   port: 443
261:   # username: username
262:   # password: password
263:   tls: true
264:   skip-cert-verify: true
265: ```
266: 
267: :::
268: 
269: ### Snell
270: 
271: 作为可选的反审查协议, Clash也集成了对Snell的支持.
272: 
273: ```yaml
274: # 暂不支持 UDP
275: - name: "snell"
276:   type: snell
277:   # interface-name: eth0
278:   # routing-mark: 1234
279:   server: server
280:   port: 44046
281:   psk: yourpsk
282:   # version: 2
283:   # obfs-opts:
284:     # mode: http # or tls
285:     # host: bing.com
286: ```
287: 
288: ### Trojan
289: 
290: Clash 内置了对流行协议 Trojan 的支持:
291: 
292: ::: code-group
293: 
294: ```yaml [basic]
295: - name: "trojan"
296:   type: trojan
297:   # interface-name: eth0
298:   # routing-mark: 1234
299:   server: server
300:   port: 443
301:   password: yourpsk
302:   # udp: true
303:   # sni: example.com # aka server name
304:   # alpn:
305:   #   - h2
306:   #   - http/1.1
307:   # skip-cert-verify: true
308: ```
309: 
310: ```yaml [gRPC]
311: - name: trojan-grpc
312:   type: trojan
313:   # interface-name: eth0
314:   # routing-mark: 1234
315:   server: server
316:   port: 443
317:   password: "example"
318:   network: grpc
319:   sni: example.com
320:   # skip-cert-verify: true
321:   udp: true
322:   grpc-opts:
323:     grpc-service-name: "example"
324: ```
325: 
326: ```yaml  [ws (websocket)]
327: - name: trojan-ws
328:   type: trojan
329:   # interface-name: eth0
330:   # routing-mark: 1234
331:   server: server
332:   port: 443
333:   password: "example"
334:   network: ws
335:   sni: example.com
336:   # skip-cert-verify: true
337:   udp: true
338:   # ws-opts:
339:     # path: /path
340:     # headers:
341:     #   Host: example.com
342: ```
343: 
344: :::
345: 
346: ## Proxy Groups 策略组
347: 
348: Proxy Groups 策略组用于根据不同策略分发规则传递过来的请求, 其可以直接被规则引用, 也可以被其他策略组引用, 而最上级策略组被规则引用.
349: 
350: ### relay 中继
351: 
352: 请求将依次通过指定的代理服务器进行中继, 目前不支持 UDP. 指定的代理服务器不应包含另一个 relay 中继.
353: 
354: ### url-test 延迟测试
355: 
356: Clash 会周期性地通过指定的 URL 向列表中的代理服务器发送 HTTP HEAD 请求来测试每个代理服务器的**延迟**. 可以设置最大容忍值、测试间隔和目标 URL.
357: 
358: ### fallback 可用性测试
359: 
360: Clash 会周期性地通过指定的 URL 向列表中的代理服务器发送 HTTP HEAD 请求来测试每个代理服务器的**可用性**. 第一个可用的服务器将被使用.
361: 
362: ### load-balance 负载均衡
363: 
364: 相同 eTLD+1 的请求将使用同一个代理服务器.
365: 
366: ### select 手动选择
367: 
368: Clash 启动时默认使用策略组中的第一个代理服务器. 用户可以使用 RESTful API 选择要使用的代理服务器. 在此模式下, 您可以在配置中硬编码服务器或使用 [Proxy Providers 代理集](#proxy-providers-代理集) 动态添加服务器.
369: 
370: 无论哪种方式, 有时您也可以使用直接连接来路由数据包. 在这种情况下, 您可以使用 `DIRECT` 直连出站.
371: 
372: 要使用不同的网络接口, 您需要使用包含 `DIRECT` 直连出站的策略组, 并设置 `interface-name` 选项.
373: 
374: ```yaml
375: - name: "My Wireguard Outbound"
376:   type: select
377:   interface-name: wg0
378:   proxies: [ 'DIRECT' ]
379: ```
380: 
381: ## Proxy Providers 代理集
382: 
383: 代理集使用户可以动态加载代理服务器列表, 而不是在配置文件中硬编码. 目前有两种代理集可以加载服务器列表:
384: 
385: - `http`: Clash 会在启动时从指定的 URL 加载服务器列表. 如果设置了 `interval` 选项, Clash 会定期从远程拉取服务器列表.
386: - `file`: Clash 会在启动时从指定的文件位置加载服务器列表.
387: 
388: 健康检查对两种模式都可用, 并且与策略组中的 `fallback` 完全相同. 服务器列表文件的配置格式在主配置文件中也完全相同:
389: 
390: ::: code-group
391: 
392: ```yaml [config.yaml]
393: proxy-providers:
394:   provider1:
395:     type: http
396:     url: "url"
397:     interval: 3600
398:     path: ./provider1.yaml
399:     # filter: 'a|b' # golang regex 正则表达式
400:     health-check:
401:       enable: true
402:       interval: 600
403:       # lazy: true
404:       url: http://www.gstatic.com/generate_204
405:   test:
406:     type: file
407:     path: /test.yaml
408:     health-check:
409:       enable: true
410:       interval: 36000
411:       url: http://www.gstatic.com/generate_204
412: ```
413: 
414: ```yaml [test.yaml]
415: proxies:
416:   - name: "ss1"
417:     type: ss
418:     server: server
419:     port: 443
420:     cipher: chacha20-ietf-poly1305
421:     password: "password"
422: 
423:   - name: "ss2"
424:     type: ss
425:     server: server
426:     port: 443
427:     cipher: chacha20-ietf-poly1305
428:     password: "password"
429:     plugin: obfs
430:     plugin-opts:
431:       mode: tls
432: ```
433: 
434: :::


./docs\zh_CN\configuration\rules.md
1: ---
2: sidebarTitle: Rules 规则
3: sidebarOrder: 5
4: ---
5: 
6: # Rules 规则
7: 
8: 在[快速入手](/zh_CN/configuration/getting-started)中, 我们介绍了Clash中基于规则的匹配的基本知识. 在本章中, 我们将介绍最新版本的 Clash 中所有可用的规则类型.
9: 
10: ```txt
11: # 类型,参数,策略(,no-resolve)
12: TYPE,ARGUMENT,POLICY(,no-resolve)
13: ```
14: 
15: `no-resolve` 选项是可选的, 它用于跳过规则的 DNS 解析. 当您想要使用 `GEOIP`、`IP-CIDR`、`IP-CIDR6`、`SCRIPT` 规则, 但又不想立即将域名解析为 IP 地址时, 这个选项就很有用了.
16: 
17: [[toc]]
18: 
19: ## 策略
20: 
21: 目前有四种策略类型, 其中:
22: 
23: - DIRECT: 通过 `interface-name` 直接连接到目标 (不查找系统路由表)
24: - REJECT: 丢弃数据包
25: - Proxy: 将数据包路由到指定的代理服务器
26: - Proxy Group: 将数据包路由到指定的策略组
27: 
28: ## 规则类型
29: 
30: 以下部分介绍了每种规则类型及其使用方法:
31: 
32: ### DOMAIN 域名
33: 
34: `DOMAIN,www.google.com,policy` 将 `www.google.com` 路由到 `policy`.
35: 
36: ### DOMAIN-SUFFIX 域名后缀
37: 
38: `DOMAIN-SUFFIX,youtube.com,policy` 将任何以 `youtube.com` 结尾的域名路由到 `policy`.
39: 
40: 在这种情况下, `www.youtube.com` 和 `foo.bar.youtube.com` 都将路由到 `policy`.
41: 
42: ### DOMAIN-KEYWORD 域名关键字
43: 
44: `DOMAIN-KEYWORD,google,policy` 将任何包含 `google` 关键字的域名路由到 `policy`.
45: 
46: 在这种情况下, `www.google.com` 或 `googleapis.com` 都将路由到 `policy`.
47: 
48: ### GEOIP IP地理位置 (国家代码)
49: 
50: GEOIP 规则用于根据数据包的目标 IP 地址的**国家代码**路由数据包. Clash 使用 [MaxMind GeoLite2](https://dev.maxmind.com/geoip/geoip2/geolite2/) 数据库来实现这一功能.
51: 
52: ::: warning
53: 使用这种规则时, Clash 将域名解析为 IP 地址, 然后查找 IP 地址的国家代码.
54: 如果要跳过 DNS 解析, 请使用 `no-resolve` 选项.
55: :::
56: 
57: `GEOIP,CN,policy` 将任何目标 IP 地址为中国的数据包路由到 `policy`.
58: 
59: ### IP-CIDR IPv4地址段
60: 
61: IP-CIDR 规则用于根据数据包的**目标 IPv4 地址**路由数据包.
62: 
63: ::: warning
64: 使用这种规则时, Clash 将域名解析为 IPv4 地址.
65: 如果要跳过 DNS 解析, 请使用 `no-resolve` 选项.
66: :::
67: 
68: `IP-CIDR,127.0.0.0/8,DIRECT` 将任何目标 IP 地址为 `127.0.0.0/8` 的数据包路由到 `DIRECT`.
69: 
70: ### IP-CIDR6 IPv6地址段
71: 
72: IP-CIDR6 规则用于根据数据包的**目标 IPv6 地址**路由数据包.
73: 
74: ::: warning
75: 使用这种规则时, Clash 将域名解析为 IPv6 地址.
76: 如果要跳过 DNS 解析, 请使用 `no-resolve` 选项.
77: :::
78: 
79: `IP-CIDR6,2620:0:2d0:200::7/32,policy` 将任何目标 IP 地址为 `2620:0:2d0:200::7/32` 的数据包路由到 `policy`.
80: 
81: ### SRC-IP-CIDR 源IP段地址
82: 
83: SRC-IP-CIDR 规则用于根据数据包的**源 IPv4 地址**路由数据包.
84: 
85: `SRC-IP-CIDR,192.168.1.201/32,DIRECT` 将任何源 IP 地址为 `192.168.1.201/32` 的数据包路由到 `DIRECT`.
86: 
87: ### SRC-PORT 源端口
88: 
89: SRC-PORT 规则用于根据数据包的**源端口**路由数据包.
90: 
91: `SRC-PORT,80,policy` 将任何源端口为 `80` 的数据包路由到 `policy`.
92: 
93: ### DST-PORT 目标端口
94: 
95: DST-PORT 规则用于根据数据包的**目标端口**路由数据包.
96: 
97: `DST-PORT,80,policy` 将任何目标端口为 `80` 的数据包路由到 `policy`.
98: 
99: ### PROCESS-NAME 源进程名
100: 
101: PROCESS-NAME 规则用于根据发送数据包的进程名称路由数据包.
102: 
103: ::: warning
104: 目前, 仅支持 macOS、Linux、FreeBSD 和 Windows.
105: :::
106: 
107: `PROCESS-NAME,nc,DIRECT` 将任何来自进程 `nc` 的数据包路由到 `DIRECT`.
108: 
109: ### PROCESS-PATH 源进程路径
110: 
111: PROCESS-PATH 规则用于根据发送数据包的进程路径路由数据包.
112: 
113: ::: warning
114: 目前, 仅支持 macOS、Linux、FreeBSD 和 Windows.
115: :::
116: 
117: `PROCESS-PATH,/usr/local/bin/nc,DIRECT` 将任何来自路径为 `/usr/local/bin/nc` 的进程的数据包路由到 `DIRECT`.
118: 
119: ### IPSET IP集
120: 
121: IPSET 规则用于根据 IP 集匹配并路由数据包. 根据 [IPSET 的官方网站](https://ipset.netfilter.org/) 的介绍:
122: 
123: > IP 集是 Linux 内核中的一个框架, 可以通过 ipset 程序进行管理. 根据类型, IP 集可以存储 IP 地址、网络、 (TCP/UDP) 端口号、MAC 地址、接口名称或它们以某种方式的组合, 以确保在集合中匹配条目时具有闪电般的速度.
124: 
125: 因此, 此功能仅在 Linux 上工作, 并且需要安装 `ipset`.
126: 
127: ::: warning
128: 使用此规则时, Clash 将解析域名以获取 IP 地址, 然后查找 IP 地址是否在 IP 集中.
129: 如果要跳过 DNS 解析, 请使用 `no-resolve` 选项.
130: :::
131: 
132: `IPSET,chnroute,policy` 将任何目标 IP 地址在 IP 集 `chnroute` 中的数据包路由到 `policy`.
133: 
134: ### RULE-SET 规则集
135: 
136: ::: info
137: 此功能仅在 [Premium 版本](/zh_CN/premium/introduction) 中可用.
138: :::
139: 
140: RULE-SET 规则用于根据 [Rule Providers 规则集](/zh_CN/premium/rule-providers) 的结果路由数据包. 当 Clash 使用此规则时, 它会从指定的 Rule Providers 规则集中加载规则, 然后将数据包与规则进行匹配. 如果数据包与任何规则匹配, 则将数据包路由到指定的策略, 否则跳过此规则.
141: 
142: ::: warning
143: 使用 RULE-SET 时, 当规则集的类型为 IPCIDR , Clash 将解析域名以获取 IP 地址.
144: 如果要跳过 DNS 解析, 请使用 `no-resolve` 选项.
145: :::
146: 
147: `RULE-SET,my-rule-provider,DIRECT` 从 `my-rule-provider` 加载所有规则
148: 
149: ### SCRIPT 脚本
150: 
151: ::: info
152: 此功能仅在 [Premium 版本](/zh_CN/premium/introduction) 中可用.
153: :::
154: 
155: SCRIPT 规则用于根据脚本的结果路由数据包. 当 Clash 使用此规则时, 它会执行指定的脚本, 然后将数据包路由到脚本的输出.
156: 
157: ::: warning
158: 使用 SCRIPT 时, Clash 将解析域名以获取 IP 地址.
159: 如果要跳过 DNS 解析, 请使用 `no-resolve` 选项.
160: :::
161: 
162: `SCRIPT,script-path,DIRECT` 将数据包路由到脚本 `script-path` 的输出.
163: 
164: ### MATCH 全匹配
165: 
166: MATCH 规则用于路由剩余的数据包. 该规则是**必需**的, 通常用作最后一条规则.
167: 
168: `MATCH,policy` 将剩余的数据包路由到 `policy`.


./docs\zh_CN\introduction\faq.md
1: ---
2: sidebarTitle: 常见问题
3: sidebarOrder: 4
4: ---
5: 
6: # 常见问题
7: 
8: 这里是一些大家遇到的常见问题. 如果您有任何此处未列出的问题, 请随时[提交一个 issue](https://github.com/Dreamacro/clash/issues/new/choose).
9: 
10: [[toc]]
11: 
12: ## amd64 和 amd64-v3 有什么区别？
13: 
14: 引用自 [golang/go](https://github.com/golang/go/wiki/MinimumRequirements#amd64):
15: 
16: > 在 Go 1.17 之前, Go 编译器总是生成任何 64 位 x86 处理器都可以执行的 x86 二进制文件.
17: >
18: > Go 1.18 引入了 AMD64 的 [4 个架构级别](https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels).
19: > 每个级别都有不同的x86指令集, 编译器可以在生成的二进制文件中包含这些指令:
20: >
21: > - GOAMD64=v1 (默认) : 基线. 仅生成所有 64 位 x86 处理器都可以执行的指令.
22: > - GOAMD64=v2: 所有 v1 指令, 加上 CMPXCHG16B、LAHF、SAHF、POPCNT、SSE3、SSE4.1、SSE4.2、SSSE3.
23: > - GOAMD64=v3: 所有 v2 指令, 加上 AVX、AVX2、BMI1、BMI2、F16C、FMA、LZCNT、MOVBE、OSXSAVE.
24: > - GOAMD64=v4: 所有 v3 指令, 加上 AVX512F、AVX512BW、AVX512CD、AVX512DQ、AVX512VL.
25: >
26: > 例如, 设置 `GOAMD64=v3` 将允许 Go 编译器在生成的二进制文件中使用 AVX2 指令 (这可能会在某些情况下提高性能) ；但是这些二进制文件将无法在不支持 AVX2 的旧 x86 处理器上运行.
27: >
28: > Go工具链也可能生成较新的指令, 但会存在动态检查保护, 确保它们只在有能力的处理器上执行. 例如在 `GOAMD64=v1` 的情况下, 如果 [CPUID](https://www.felixcloutier.com/x86/cpuid) 报告说 [POPCNT](https://www.felixcloutier.com/x86/popcnt) 指令可用, [math/bits.OnesCount](https://pkg.go.dev/math/bits#OnesCount) 仍将使用该指令. 否则, 它就会退回到一个通用的实现.
29: >
30: > Go 工具链目前不会生成任何 AVX512 指令.
31: >
32: > 请注意, 在这种情况下, *处理器*是一个简化. 实际上, 整个系统 (固件、hypervisor、内核) 都需要支持.
33: 
34: ## 我的系统应该使用哪个版本？
35: 
36: 这里是一些人们在 Clash 上使用的常见系统, 以及每个系统的推荐版本:
37: 
38: - NETGEAR WNDR3700v2: mips-hardfloat [#846](https://github.com/Dreamacro/clash/issues/846)
39: - NETGEAR WNDR3800: mips-softfloat [#579](https://github.com/Dreamacro/clash/issues/579)
40: - 华硕RT-AC5300: armv5 [#2356](https://github.com/Dreamacro/clash/issues/2356)
41: - 联发科MT7620A, MT7621A: mipsle-softfloat ([#136](https://github.com/Dreamacro/clash/issues/136))
42: - mips_24kc: [#192](https://github.com/Dreamacro/clash/issues/192)
43: 
44: 如果您的设备未在此处列出, 您可以使用 `uname -m` 检查设备的 CPU 架构, 并在发布页面中找到相应的版本.
45: 
46: ## 不会修复的问题
47: 
48: 官方 Clash 内核项目不会实现/修复以下内容:
49: 
50: - [Snell](https://github.com/Dreamacro/clash/issues/2466)
51: - [Custom CA](https://github.com/Dreamacro/clash/issues/2333)
52: - [VMess Mux](https://github.com/Dreamacro/clash/issues/450)
53: - [VLess](https://github.com/Dreamacro/clash/issues/1185)
54: - [KCP](https://github.com/Dreamacro/clash/issues/16)
55: - [mKCP](https://github.com/Dreamacro/clash/issues/2308)
56: - [TLS Encrypted Client Hello](https://github.com/Dreamacro/clash/issues/2295)
57: - [TCP support for Clash DNS server](https://github.com/Dreamacro/clash/issues/368)
58: - [MITM](https://github.com/Dreamacro/clash/issues/227#issuecomment-508693628)
59: 
60: 当官方Go QUIC库发布时, 以下内容将被考虑实施:
61: 
62: - [TUIC](https://github.com/Dreamacro/clash/issues/2222)
63: - [Hysteria](https://github.com/Dreamacro/clash/issues/1863)
64: 
65: ## 在本地机器上节点正常工作, 但在路由器或容器中不起作用
66: 
67: 您的系统可能未与世界时间同步. 请参考您的平台关于时间同步的文件 - 如果时间不同步, 某些协议可能无法正常工作.
68: 
69: ## 规则匹配的时间复杂度
70: 
71: 请参考这个讨论: [#422](https://github.com/Dreamacro/clash/issues/422)
72: 
73: ## Clash Premium 无法访问互联网
74: 
75: 您可以参考这些相关讨论:
76: 
77: - [#432](https://github.com/Dreamacro/clash/issues/432#issuecomment-571634905)
78: - [#2480](https://github.com/Dreamacro/clash/issues/2480)
79: 
80: ## 错误: 不支持的 RULE-SET 规则类型
81: 
82: 如果您遇到了这个错误信息:
83: 
84: ```txt
85: FATA[0000] Parse config error: Rules[0] [RULE-SET,apple,REJECT] error: unsupported rule type RULE-SET
86: ```
87: 
88: 您正在使用 Clash 开源版. 规则 Providers 目前仅在 [免费 Premium 内核](https://github.com/Dreamacro/clash/releases/tag/premium) 中可用.
89: 
90: ## DNS 劫持不起作用
91: 
92: 由于 `tun.auto-route` 不会拦截局域网流量, 如果您的系统 DNS 设置为私有子网中的服务器, 则 DNS 劫持将不起作用. 您可以:
93: 
94: 1. 使用非私有 DNS 服务器作为系统 DNS, 如 `1.1.1.1`
95: 2. 或者手动将系统 DNS 设置为 Clash DNS (默认为 `198.18.0.1`)


./docs\zh_CN\introduction\getting-started.md
1: ---
2: sidebarTitle: 快速开始
3: sidebarOrder: 2
4: ---
5: 
6: # 快速开始
7: 
8: 为了开始使用 Clash, 您可以从源码编译或者下载预编译的二进制文件.
9: 
10: ## 使用预编译的二进制文件
11: 
12: 您可以在这里下载 Clash 的内核二进制文件: [https://github.com/Dreamacro/clash/releases](https://github.com/Dreamacro/clash/releases)
13: 
14: ## 从源码编译
15: 
16: 您可以使用 Golang 1.19+ 在您的设备上编译 Clash:
17: 
18: ```shell
19: $ go install github.com/Dreamacro/clash@latest
20: go: downloading github.com/Dreamacro/clash v1.15.1
21: ```
22: 
23: 二进制文件将会被编译到 `$GOPATH/bin` 目录下:
24: 
25: ```shell
26: $ $GOPATH/bin/clash -v
27: Clash unknown version darwin arm64 with go1.20.3 unknown time
28: ```
29: 
30: ## 跨平台/操作系统编译
31: 
32: Golang 支持交叉编译, 所以您可以为不同架构或操作系统的设备编译 Clash. 您可以使用 _make_ 来轻松地编译它们, 例如:
33: 
34: ```shell
35: $ git clone --depth 1 https://github.com/Dreamacro/clash
36: Cloning into 'clash'...
37: remote: Enumerating objects: 359, done.
38: remote: Counting objects: 100% (359/359), done.
39: remote: Compressing objects: 100% (325/325), done.
40: remote: Total 359 (delta 25), reused 232 (delta 17), pack-reused 0
41: Receiving objects: 100% (359/359), 248.99 KiB | 1.63 MiB/s, done.
42: Resolving deltas: 100% (25/25), done.
43: $ cd clash && make darwin-arm64
44: fatal: No names found, cannot describe anything.
45: GOARCH=arm64 GOOS=darwin CGO_ENABLED=0 go build -trimpath -ldflags '-X "github.com/Dreamacro/clash/constant.Version=unknown version" -X "github.com/Dreamacro/clash/constant.BuildTime=Mon May  8 16:47:10 UTC 2023" -w -s -buildid=' -o bin/clash-darwin-arm64
46: $ file bin/clash-darwin-arm64
47: bin/clash-darwin-arm64: Mach-O 64-bit executable arm64
48: ```
49: 
50: 对于其他构建目标, 请查看 [Makefile](https://github.com/Dreamacro/clash/blob/master/Makefile).

./docs\zh_CN\introduction\service.md
1: ---
2: sidebarTitle: Clash 服务运行
3: sidebarOrder: 3
4: ---
5: 
6: # Clash 服务运行
7: 
8: Clash 需要在后台运行, 但是目前 Golang 还没有很好的守护进程实现, 因此我们推荐使用第三方工具来创建 Clash 的守护进程.
9: 
10: ## systemd
11: 
12: 使用以下命令将 Clash 二进制文件复制到 `/usr/local/bin`, 配置文件复制到 `/etc/clash`:
13: 
14: ```shell
15: cp clash /usr/local/bin
16: cp config.yaml /etc/clash/
17: cp Country.mmdb /etc/clash/
18: ```
19: 
20: 创建 systemd 配置文件 `/etc/systemd/system/clash.service`:
21: 
22: ```ini
23: [Unit]
24: Description=Clash 守护进程, Go 语言实现的基于规则的代理.
25: After=network-online.target
26: 
27: [Service]
28: Type=simple
29: Restart=always
30: ExecStart=/usr/local/bin/clash -d /etc/clash
31: 
32: [Install]
33: WantedBy=multi-user.target
34: ```
35: 
36: 之后, 您应该使用以下命令重新加载 systemd:
37: 
38: ```shell
39: systemctl daemon-reload
40: ```
41: 
42: 使用以下命令在系统启动时启动 Clash:
43: 
44: ```shell
45: systemctl enable clash
46: ```
47: 
48: 使用以下命令立即启动 Clash:
49: 
50: ```shell
51: systemctl start clash
52: ```
53: 
54: 使用以下命令检查 Clash 的运行状况和日志:
55: 
56: ```shell
57: systemctl status clash
58: journalctl -xe
59: ```
60: 
61: 本指南贡献者为 [ktechmidas](https://github.com/ktechmidas). ([#754](https://github.com/Dreamacro/clash/issues/754))
62: 
63: ## Docker
64: 
65: 本项目提供了预构建的 Clash 和 Clash Premium Docker 镜像. 因此, 在 Linux 上您可以使用 [Docker Compose](https://docs.docker.com/compose/) 部署 Clash. 但是, 您应该知道在容器中运行 **Clash Premium** 是[不被推荐的](https://github.com/Dreamacro/clash/issues/2249#issuecomment-1203494599)
66: 
67: ::: warning
68: 由于 Mac 版 Docker 中缺少[主机网络和 TUN 支持](https://github.com/Dreamacro/clash/issues/770#issuecomment-650951876), 此设置将无法在 macOS 系统上运行.
69: :::
70: 
71: ::: code-group
72: 
73: ```yaml [Clash]
74: services:
75:   clash:
76:     image: ghcr.io/dreamacro/clash
77:     restart: always
78:     volumes:
79:       - ./config.yaml:/root/.config/clash/config.yaml:ro
80:       # - ./ui:/ui:ro # 仪表盘 Volume 映射
81:     ports:
82:       - "7890:7890"
83:       - "7891:7891"
84:       # - "8080:8080" # 外部控制 (RESTful API)
85:     network_mode: "bridge"
86: ```
87: 
88: ```yaml [Clash Premium]
89: services:
90:   clash:
91:     image: ghcr.io/dreamacro/clash-premium
92:     restart: always
93:     volumes:
94:       - ./config.yaml:/root/.config/clash/config.yaml:ro
95:       # - ./ui:/ui:ro # 仪表盘 Volume 映射
96:     ports:
97:       - "7890:7890"
98:       - "7891:7891"
99:       # - "8080:8080" # 外部控制 (RESTful API)
100:     cap_add:
101:       - NET_ADMIN
102:     devices:
103:       - /dev/net/tun
104:     network_mode: "host"
105: ```
106: 
107: :::
108: 
109: 保存为 `docker-compose.yaml`, 并将您的 `config.yaml` 放在同一目录下.
110: 
111: ::: tip
112: 在继续操作之前, 请参考您的平台关于时间同步的文件 - 如果时间不同步, 某些协议可能无法正常工作.
113: :::
114: 
115: 准备就绪后, 运行以下命令以启动 Clash:
116: 
117: ```shell
118: docker-compose up -d
119: ```
120: 
121: 您可以使用以下命令查看日志:
122: 
123: ```shell
124: docker-compose logs
125: ```
126: 
127: Stop Clash with:
128: 
129: ```shell
130: docker-compose stop
131: ```


./docs\zh_CN\introduction\_dummy-index.md
1: ---
2: sidebarTitle: 什么是 Clash?
3: sidebarOrder: 1
4: ---
5: 
6: <!-- 此文件用作始终链接到 / 的虚拟侧边栏项目 -->


./docs\zh_CN\premium\ebpf.md
1: ---
2: sidebarTitle: "功能: eBPF 重定向到 TUN"
3: sidebarOrder: 3
4: ---
5: 
6: # 功能: eBPF 重定向到 TUN
7: 
8: eBPF 重定向到 TUN 是一项拦截特定网络接口上的所有网络流量, 并将其重定向到 TUN 接口的功能. 该功能需要[内核支持](https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration).
9: 
10: ::: warning
11: 此功能与 `tun.auto-route` 冲突.
12: :::
13: 
14: 虽然它通常与 `tun.auto-redir` 和 `tun.auto-route` 相比具有更好的性能, 但与 `auto-route` 相比, 它并不够成熟. 因此, 您应该谨慎使用.
15: 
16: ## 配置
17: 
18: ```yaml
19: ebpf:
20:   redirect-to-tun:
21:     - eth0
22: ```
23: 
24: ## 已知问题
25: 
26: - 此功能与 Tailscaled 冲突, 因此您应该使用 `tun.auto-route` 作为替代.


./docs\zh_CN\premium\experimental-features.md
1: ---
2: sidebarTitle: 实验功能
3: sidebarOrder: 9
4: ---
5: 
6: # 实验功能
7: 
8: 偶尔我们会做一些新的功能, 这些功能需要大量的测试才能在主要版本中使用. 这些功能被标记为实验性的, 并且默认是禁用的.
9: 
10: ::: warning
11: 这里列出的一些功能可能不稳定, 并且可能在任何未来版本中被删除 - 我们不建议使用它们, 除非您有特定的原因.
12: :::
13: 
14: ## 嗅探 TLS SNI
15: 
16: ```yaml
17: experimental:
18:   sniff-tls-sni: true
19: ```


./docs\zh_CN\premium\introduction.md
1: ---
2: sidebarTitle: 简介
3: sidebarOrder: 1
4: ---
5: 
6: # 简介
7: 
8: 在过去, 只有一个开源版本的 Clash, 直到一些 [不当使用和再分发](https://github.com/Dreamacro/clash/issues/541#issuecomment-672029110) 的 Clash 出现. 从那时起, 我们决定分叉 Clash 并在私有 GitHub 存储库中开发更高级的功能.
9: 
10: 不要担心 - Premium 内核将保持免费, 并且其源代码的安全性通过多个可信的开发人员相互审查以保证.
11: 
12: ## 有什么区别？
13: 
14: Premium 内核是开源 Clash 内核的 Fork 分支, 增加了以下功能:
15: 
16: - [TUN 设备](/zh_CN/premium/tun-device) 支持 `auto-redir` 和 `auto-route`
17: - [eBPF 重定向到 TUN](/zh_CN/premium/ebpf)
18: - [Rule Providers 规则集](/zh_CN/premium/rule-providers)
19: - [Script 脚本](/zh_CN/premium/script)
20: - [Script Shotcuts 脚本捷径](/zh_CN/premium/script-shortcuts)
21: - [用户空间 Wireguard](/zh_CN/premium/userspace-wireguard)
22: - [性能分析引擎](/zh_CN/premium/the-profiling-engine)
23: 
24: ## 获取副本
25: 
26: 您可以从 [GitHub Releases](https://github.com/Dreamacro/clash/releases/tag/premium) 下载最新的 Clash Premium 二进制文件.


./docs\zh_CN\premium\rule-providers.md
1: ---
2: sidebarTitle: "功能: Rule Providers 规则集"
3: sidebarOrder: 4
4: ---
5: 
6: # Rule Providers 规则集
7: 
8: Rule Providers 规则集和 [Proxy Providers 代理集](/zh_CN/configuration/outbound#proxy-providers-代理集) 基本相同. 它允许用户从外部源加载规则, 从而使配置更加简洁. 该功能目前仅适用于 Clash Premium 内核.
9: 
10: 要定义 Rule Providers 规则集, 请将 `rule-providers` 规则集字段添加到主配置中:
11: 
12: ```yaml
13: rule-providers:
14:   apple:
15:     behavior: "domain" # domain, ipcidr or classical (仅限 Clash Premium 内核)
16:     type: http
17:     url: "url"
18:     # format: 'yaml' # or 'text'
19:     interval: 3600
20:     path: ./apple.yaml
21:   microsoft:
22:     behavior: "domain"
23:     type: file
24:     path: /microsoft.yaml
25: 
26: rules:
27:   - RULE-SET,apple,REJECT
28:   - RULE-SET,microsoft,policy
29: ```
30: 
31: 有三种行为类型可用:
32: 
33: ## `domain`
34: 
35: yaml:
36: 
37: ```yaml
38: payload:
39:   - '.blogger.com'
40:   - '*.*.microsoft.com'
41:   - 'books.itunes.apple.com'
42: ```
43: 
44: text:
45: 
46: ```txt
47: # comment
48: .blogger.com
49: *.*.microsoft.com
50: books.itunes.apple.com
51: ```
52: 
53: ## `ipcidr`
54: 
55: yaml
56: 
57: ```yaml
58: payload:
59:   - '192.168.1.0/24'
60:   - '10.0.0.0.1/32'
61: ```
62: 
63: text:
64: 
65: ```txt
66: # comment
67: 192.168.1.0/24
68: 10.0.0.0.1/32
69: ```
70: 
71: ## `classical`
72: 
73: yaml:
74: 
75: ```yaml
76: payload:
77:   - DOMAIN-SUFFIX,google.com
78:   - DOMAIN-KEYWORD,google
79:   - DOMAIN,ad.com
80:   - SRC-IP-CIDR,192.168.1.201/32
81:   - IP-CIDR,127.0.0.0/8
82:   - GEOIP,CN
83:   - DST-PORT,80
84:   - SRC-PORT,7777
85:   # MATCH 在这里并不是必须的
86: ```
87: 
88: text:
89: 
90: ```txt
91: # comment
92: DOMAIN-SUFFIX,google.com
93: DOMAIN-KEYWORD,google
94: DOMAIN,ad.com
95: SRC-IP-CIDR,192.168.1.201/32
96: IP-CIDR,127.0.0.0/8
97: GEOIP,CN
98: DST-PORT,80
99: SRC-PORT,7777
100: ```


./docs\zh_CN\premium\script-shortcuts.md
1: ---
2: sidebarTitle: "功能: Script Shortcuts 脚本捷径"
3: sidebarOrder: 6
4: ---
5: 
6: # Script Shortcuts 脚本捷径
7: 
8: Clash Premium 实现了基于 Python3 的脚本功能, 允许用户以动态灵活的方式为数据包选择策略.
9: 
10: 您可以使用单个 Python 脚本控制整个规则匹配引擎, 也可以定义一些 Shortcuts 捷径并将它们与常规规则一起使用. 本页参考后者功能. 有关前者, 请参见 [脚本](./script.md).
11: 
12: 此功能使得在 `rules` 模式下使用脚本成为可能. 默认情况下, DNS 解析将在 SCRIPT 规则中进行. 可以在规则后面添加 `no-resolve` 来阻止解析. (例如: `SCRIPT,quic,DIRECT,no-resolve`)
13: 
14: ```yaml
15: mode: Rule
16: 
17: script:
18:   engine: expr # or starlark (10x to 20x slower)
19:   shortcuts:
20:     quic: network == 'udp' and dst_port == 443
21:     curl: resolve_process_name() == 'curl'
22:     # curl: resolve_process_path() == '/usr/bin/curl'
23: 
24: rules:
25:   - SCRIPT,quic,REJECT
26: ```
27: 
28: ## 评估引擎
29: 
30: [Expr](https://expr.medv.io/) 作为 Script Shortcuts 的默认引擎, 相比 Starlark 提供了 10 倍到 20 倍的性能提升.
31: 
32: [Starlark](https://github.com/google/starlark-go) 是一种类似 Python 的配置语言, 您也可以将其用于 Script Shortcuts.
33: 
34: ## 变量
35: 
36: - network: string
37: - type: string
38: - src_ip: string
39: - dst_ip: string
40: - src_port: uint16
41: - dst_port: uint16
42: - inbound_port: uint16
43: - host: string
44: - process_path: string
45: 
46: ::: warning
47: Starlark 目前不包含 `process_path` 变量.
48: :::
49: 
50: ## 函数
51: 
52: ```ts
53: type resolve_ip = (host: string) => string // ip string
54: type in_cidr = (ip: string, cidr: string) => boolean // ip in cidr
55: type in_ipset = (name: string, ip: string) => boolean // ip in ipset
56: type geoip = (ip: string) => string // country code
57: type match_provider = (name: string) => boolean // in rule provider
58: type resolve_process_name = () => string // find process name (curl .e.g)
59: type resolve_process_path = () => string // find process path (/usr/bin/curl .e.g)
60: ```


./docs\zh_CN\premium\script.md
1: ---
2: sidebarTitle: "功能: Script 脚本"
3: sidebarOrder: 5
4: ---
5: 
6: # Script 脚本
7: 
8: Clash Premium 实现了基于 Python3 的脚本功能, 使用户能够以动态灵活的方式为数据包选择策略.
9: 
10: 您可以使用单个 Python 脚本控制整个规则匹配引擎, 也可以定义一些快捷方式, 并与常规规则一起使用. 本页介绍了第一种功能, 有关后者, 请参见[Script Shortcuts 脚本捷径](./script-shortcuts.md).
11: 
12: ## 控制整个规则匹配引擎
13: 
14: ```yaml
15: mode: Script
16: 
17: # https://lancellc.gitbook.io/clash/clash-config-file/script
18: script:
19:   code: |
20:     def main(ctx, metadata):
21:       ip = metadata["dst_ip"] = ctx.resolve_ip(metadata["host"])
22:       if ip == "":
23:         return "DIRECT"
24: 
25:       code = ctx.geoip(ip)
26:       if code == "LAN" or code == "CN":
27:         return "DIRECT"
28: 
29:       return "Proxy" # default policy for requests which are not matched by any other script
30: ```
31: 
32: 如果您想使用 IP 规则 (即: IP-CIDR、GEOIP 等) , 您首先需要手动解析 IP 地址并将其分配给 metadata:
33: 
34: ```python
35: def main(ctx, metadata):
36:     # ctx.rule_providers["geoip"].match(metadata) return false
37: 
38:     ip = ctx.resolve_ip(metadata["host"])
39:     if ip == "":
40:         return "DIRECT"
41:     metadata["dst_ip"] = ip
42: 
43:     # ctx.rule_providers["iprule"].match(metadata) return true
44: 
45:     return "Proxy"
46: ```
47: 
48: Metadata 和 Context 的接口定义:
49: 
50: ```ts
51: interface Metadata {
52:   type: string // socks5、http
53:   network: string // tcp
54:   host: string
55:   src_ip: string
56:   src_port: string
57:   dst_ip: string
58:   dst_port: string
59:   inbound_port: number
60: }
61: 
62: interface Context {
63:   resolve_ip: (host: string) => string // ip string
64:   resolve_process_name: (metadata: Metadata) => string
65:   resolve_process_path: (metadata: Metadata) => string
66:   geoip: (ip: string) => string // country code
67:   log: (log: string) => void
68:   proxy_providers: Record<string, Array<{ name: string, alive: boolean, delay: number }>>
69:   rule_providers: Record<string, { match: (metadata: Metadata) => boolean }>
70: }
71: ```


./docs\zh_CN\premium\the-profiling-engine.md
1: ---
2: sidebarTitle: "功能: 性能分析引擎"
3: sidebarOrder: 8
4: ---
5: 
6: # 性能分析引擎
7: 
8: https://github.com/Dreamacro/clash-tracing
9: 
10: ```yaml
11: profile:
12:     tracing: true
13: ```


./docs\zh_CN\premium\tun-device.md
1: ---
2: sidebarTitle: "功能: TUN 设备"
3: sidebarOrder: 2
4: ---
5: 
6: # TUN 设备
7: 
8: Premium 内核支持 TUN 设备. 作为网络层设备, 它可以用来处理 TCP、UDP、ICMP 流量. 它已经在生产环境中进行了广泛的测试和使用 - 您甚至可以用它来玩竞技游戏.
9: 
10: 使用 Clash TUN 的最大优势之一是内置支持对操作系统路由表、路由规则和 nftable 的自动管理. 您可以通过选项 `tun.auto-route` 和 `tun.auto-redir` 来启用它. 这个功能替换了古老的配置选项 `redir-port`(TCP), 以方便配置和提高稳定性.
11: 
12: ::: tip
13: `tun.auto-route` 仅在 macOS、Windows、Linux 和 Android 上可用, 并且仅接收 IPv4 流量。`tun.auto-redir` 仅在 Linux 上可用（需要内核 netlink 支持）。
14: :::
15: 
16: Clash 有两种可供选择的 TCP/IP 协议栈: `system` or `gvisor`. 为了获得最好的性能, 我们建议您优先使用 `system` 栈, 只有遇到兼容性问题时才使用 `gvisor`. 并且如果你遇到这样的情况, 请立即[提交 Issue](https://github.com/Dreamacro/clash/issues/new/choose).
17: 
18: ## 技术限制
19: 
20: * 对于 Android, 控制设备位于 `/dev/tun` 而不是 `/dev/net/tun`, 您需要先创建一个软链接 (i.e. `ln -sf /dev/tun /dev/net/tun`)
21: 
22: * 如果系统 DNS 位于私有 IP 地址上, DNS 劫持可能会失败 (因为 `auto-route` 不会捕获私有网络流量).
23: 
24: ## Linux, macOS 和 Windows
25: 
26: 这是 TUN 功能的示例配置:
27: 
28: ```yaml
29: interface-name: en0 # 与 `tun.auto-detect-interface` 冲突
30: 
31: tun:
32:   enable: true
33:   stack: system # or gvisor
34:   # dns-hijack:
35:   #   - 8.8.8.8:53
36:   #   - tcp://8.8.8.8:53
37:   #   - any:53
38:   #   - tcp://any:53
39:   auto-route: true # manage `ip route` and `ip rules`
40:   auto-redir: true # manage nftable REDIRECT
41:   auto-detect-interface: true # 与 `interface-name` 冲突
42: ```
43: 
44: 请注意, 由于使用了 TUN 设备和对系统路由表、nftable 的操作, Clash 在此处将需要超级用户权限来运行.
45: 
46: ```shell
47: sudo ./clash
48: ```
49: 
50: 如果您的设备已经有一些 TUN 设备, Clash TUN 可能无法工作 - 您必须手动检查路由表和路由规则. 在这种情况下, `fake-ip-filter` 也许也有帮助.
51: 
52: ## Windows
53: 
54: 您需要访问 [WinTUN 网站](https://www.wintun.net) 并下载最新版本. 之后, 将 `wintun.dll` 复制到 Clash 主目录. 示例配置:
55: 
56: ```yaml
57: tun:
58:   enable: true
59:   stack: gvisor # or system
60:   dns-hijack:
61:     - 198.18.0.2:53 # 当 `fake-ip-range` 是 198.18.0.1/16, 应该劫持 198.18.0.2:53
62:   auto-route: true # 为 Windows 自动设置全局路由
63:   # 推荐使用 `interface-name`
64:   auto-detect-interface: true # 自动检测接口, 与 `interface-name` 冲突
65: ```


./docs\zh_CN\premium\userspace-wireguard.md
1: ---
2: sidebarTitle: "功能: 用户空间 Wireguard"
3: sidebarOrder: 7
4: ---
5: 
6: # 用户空间 Wireguard
7: 
8: 由于依赖 gvisor TCP/IP 栈, 用户空间 Wireguard 目前仅在 Premium 内核中可用.
9: 
10: ```yaml
11: proxies:
12:   - name: "wg"
13:     type: wireguard
14:     server: 127.0.0.1
15:     port: 443
16:     ip: 172.16.0.2
17:     # ipv6: your_ipv6
18:     private-key: eCtXsJZ27+4PbhDkHnB923tkUn2Gj59wZw5wFA75MnU=
19:     public-key: Cr8hWlKvtDt7nrvf+f0brNQQzabAqrjfBvas9pmowjo=
20:     # preshared-key: base64
21:     # remote-dns-resolve: true # 远程解析 DNS, 使用 `dns` 字段, 默认为 true
22:     # dns: [1.1.1.1, 8.8.8.8]
23:     # mtu: 1420
24:     udp: true
25: ```


./docs\zh_CN\runtime\external-controller.md
1: ---
2: sidebarTitle: 外部控制设置
3: sidebarOrder: 1
4: ---
5: 
6: # 外部控制设置
7: 
8: ## 简介
9: 
10: 外部控制允许用户通过 HTTP RESTful API 来控制 Clash. 第三方 Clash GUI 就是基于这个功能的. 通过在 `external-controller` 中指定地址来启用这个功能.
11: 
12: ## 认证
13: 
14: - 外部控制器接受 `Bearer Tokens` 作为访问认证方式.
15:   - 使用 `Authorization: Bearer <Your Secret>` 作为请求头来传递凭证.
16: 
17: ## RESTful API 文档
18: 
19: ### 日志
20: 
21: - `/logs`
22:   - 方法: `GET`
23:     - 完整路径: `GET /logs`
24:     - 描述: 获取实时日志
25: 
26: ### 流量
27: 
28: - `/traffic`
29:   - 方法: `GET`
30:     - 完整路径: `GET /traffic`
31:     - 描述: 获取实时流量数据
32: 
33: ### 版本
34: 
35: - `/version`
36:   - 方法: `GET`
37:     - 完整路径: `GET /version`
38:     - 描述: 获取 Clash 版本
39: 
40: ### 配置
41: 
42: - `/configs`
43:   - 方法: `GET`
44:     - 完整路径: `GET /configs`
45:     - 描述: 获取基础配置
46: 
47:   - 方法: `PUT`
48:     - 完整路径: `PUT /configs`
49:     - 描述: 重新加载配置文件
50: 
51:   - 方法: `PATCH`
52:     - 完整路径: `PATCH /configs`
53:     - 描述: 增量修改配置
54: 
55: ### 节点
56: 
57: - `/proxies`
58:   - 方法: `GET`
59:     - 完整路径: `GET /proxies`
60:     - 描述: 获取所有节点信息
61: 
62: - `/proxies/:name`
63:   - 方法: `GET`
64:     - 完整路径: `GET /proxies/:name`
65:     - 描述: 获取指定节点信息
66: 
67:   - 方法: `PUT`
68:     - 完整路径: `PUT /proxies/:name`
69:     - 描述: 切换 Selector 中选中的节点
70: 
71: - `/proxies/:name/delay`
72:   - 方法: `GET`
73:     - 完整路径: `GET /proxies/:name/delay`
74:     - 描述: 获取指定节点的延迟测试信息
75: 
76: ### 规则
77: 
78: - `/rules`
79:   - 方法: `GET`
80:     - 完整路径: `GET /rules`
81:     - 描述: 获取规则信息
82: 
83: ### 连接
84: 
85: - `/connections`
86:   - 方法: `GET`
87:     - 完整路径: `GET /connections`
88:     - 描述: 获取连接信息
89: 
90:   - 方法: `DELETE`
91:     - 完整路径: `DELETE /connections`
92:     - 描述: 关闭所有连接
93: 
94: - `/connections/:id`
95:   - 方法: `DELETE`
96:     - 完整路径: `DELETE /connections/:id`
97:     - 描述: 关闭指定连接
98: 
99: ### 代理集
100: 
101: - `/providers/proxies`
102:   - 方法: `GET`
103:     - 完整路径: `GET /providers/proxies`
104:     - 描述: 获取所有代理集的代理信息
105: 
106: - `/providers/proxies/:name`
107:   - 方法: `GET`
108:     - 完整路径: `GET /providers/proxies/:name`
109:     - 描述: 获取指定代理集的代理信息
110: 
111:   - 方法: `PUT`
112:     - 完整路径: `PUT /providers/proxies/:name`
113:     - 描述: 切换指定代理集
114: 
115: - `/providers/proxies/:name/healthcheck`
116:   - 方法: `GET`
117:     - 完整路径: `GET /providers/proxies/:name/healthcheck`
118:     - 描述: 获取指定代理集的代理信息
119: 
120: ### DNS 查询
121: 
122: - `/dns/query`
123:   - 方法: `GET`
124:   - 完整路径: `GET /dns/query?name={name}[&type={type}]`
125:   - 描述: 获取指定域名和类型的 DNS 查询数据
126:   - 参数:
127:     - `name` (必填): 要查询的域名
128:     - `type` (可选): 要查询的 DNS 记录类型 (例如, A, MX, CNAME 等). 如果未提供, 则默认为 `A`.
129: 
130:   - 示例: `GET /dns/query?name=example.com&type=A`


./hub\hub.go
1: package hub
2: 
3: import (
4: 	"github.com/Dreamacro/clash/config"
5: 	"github.com/Dreamacro/clash/hub/executor"
6: 	"github.com/Dreamacro/clash/hub/route"
7: )
8: 
9: type Option func(*config.Config)
10: 
11: func WithExternalUI(externalUI string) Option {
12: 	return func(cfg *config.Config) {
13: 		cfg.General.ExternalUI = externalUI
14: 	}
15: }
16: 
17: func WithExternalController(externalController string) Option {
18: 	return func(cfg *config.Config) {
19: 		cfg.General.ExternalController = externalController
20: 	}
21: }
22: 
23: func WithSecret(secret string) Option {
24: 	return func(cfg *config.Config) {
25: 		cfg.General.Secret = secret
26: 	}
27: }
28: 
29: // Parse call at the beginning of clash
30: func Parse(options ...Option) error {
31: 	cfg, err := executor.Parse()
32: 	if err != nil {
33: 		return err
34: 	}
35: 
36: 	for _, option := range options {
37: 		option(cfg)
38: 	}
39: 
40: 	if cfg.General.ExternalUI != "" {
41: 		route.SetUIPath(cfg.General.ExternalUI)
42: 	}
43: 
44: 	if cfg.General.ExternalController != "" {
45: 		go route.Start(cfg.General.ExternalController, cfg.General.Secret)
46: 	}
47: 
48: 	executor.ApplyConfig(cfg, true)
49: 	return nil
50: }


./hub\executor\executor.go
1: package executor
2: 
3: import (
4: 	"fmt"
5: 	"os"
6: 	"sync"
7: 
8: 	"github.com/Dreamacro/clash/adapter"
9: 	"github.com/Dreamacro/clash/adapter/outboundgroup"
10: 	"github.com/Dreamacro/clash/component/auth"
11: 	"github.com/Dreamacro/clash/component/dialer"
12: 	"github.com/Dreamacro/clash/component/iface"
13: 	"github.com/Dreamacro/clash/component/profile"
14: 	"github.com/Dreamacro/clash/component/profile/cachefile"
15: 	"github.com/Dreamacro/clash/component/resolver"
16: 	"github.com/Dreamacro/clash/component/trie"
17: 	"github.com/Dreamacro/clash/config"
18: 	C "github.com/Dreamacro/clash/constant"
19: 	"github.com/Dreamacro/clash/constant/provider"
20: 	"github.com/Dreamacro/clash/dns"
21: 	"github.com/Dreamacro/clash/listener"
22: 	authStore "github.com/Dreamacro/clash/listener/auth"
23: 	"github.com/Dreamacro/clash/log"
24: 	"github.com/Dreamacro/clash/tunnel"
25: )
26: 
27: var mux sync.Mutex
28: 
29: func readConfig(path string) ([]byte, error) {
30: 	if _, err := os.Stat(path); os.IsNotExist(err) {
31: 		return nil, err
32: 	}
33: 	data, err := os.ReadFile(path)
34: 	if err != nil {
35: 		return nil, err
36: 	}
37: 
38: 	if len(data) == 0 {
39: 		return nil, fmt.Errorf("configuration file %s is empty", path)
40: 	}
41: 
42: 	return data, err
43: }
44: 
45: // Parse config with default config path
46: func Parse() (*config.Config, error) {
47: 	return ParseWithPath(C.Path.Config())
48: }
49: 
50: // ParseWithPath parse config with custom config path
51: func ParseWithPath(path string) (*config.Config, error) {
52: 	buf, err := readConfig(path)
53: 	if err != nil {
54: 		return nil, err
55: 	}
56: 
57: 	return ParseWithBytes(buf)
58: }
59: 
60: // ParseWithBytes config with buffer
61: func ParseWithBytes(buf []byte) (*config.Config, error) {
62: 	return config.Parse(buf)
63: }
64: 
65: // ApplyConfig dispatch configure to all parts
66: func ApplyConfig(cfg *config.Config, force bool) {
67: 	mux.Lock()
68: 	defer mux.Unlock()
69: 
70: 	updateUsers(cfg.Users)
71: 	updateProxies(cfg.Proxies, cfg.Providers)
72: 	updateRules(cfg.Rules)
73: 	updateHosts(cfg.Hosts)
74: 	updateProfile(cfg)
75: 	updateGeneral(cfg.General, force)
76: 	updateInbounds(cfg.Inbounds, force)
77: 	updateDNS(cfg.DNS)
78: 	updateExperimental(cfg)
79: 	updateTunnels(cfg.Tunnels)
80: }
81: 
82: func GetGeneral() *config.General {
83: 	ports := listener.GetPorts()
84: 	authenticator := []string{}
85: 	if auth := authStore.Authenticator(); auth != nil {
86: 		authenticator = auth.Users()
87: 	}
88: 
89: 	general := &config.General{
90: 		LegacyInbound: config.LegacyInbound{
91: 			Port:        ports.Port,
92: 			SocksPort:   ports.SocksPort,
93: 			RedirPort:   ports.RedirPort,
94: 			TProxyPort:  ports.TProxyPort,
95: 			MixedPort:   ports.MixedPort,
96: 			AllowLan:    listener.AllowLan(),
97: 			BindAddress: listener.BindAddress(),
98: 		},
99: 		Authentication: authenticator,
100: 		Mode:           tunnel.Mode(),
101: 		LogLevel:       log.Level(),
102: 		IPv6:           !resolver.DisableIPv6,
103: 	}
104: 
105: 	return general
106: }
107: 
108: func updateExperimental(c *config.Config) {
109: 	tunnel.UDPFallbackMatch.Store(c.Experimental.UDPFallbackMatch)
110: }
111: 
112: func updateDNS(c *config.DNS) {
113: 	if !c.Enable {
114: 		resolver.DefaultResolver = nil
115: 		resolver.DefaultHostMapper = nil
116: 		dns.ReCreateServer("", nil, nil)
117: 		return
118: 	}
119: 
120: 	cfg := dns.Config{
121: 		Main:         c.NameServer,
122: 		Fallback:     c.Fallback,
123: 		IPv6:         c.IPv6,
124: 		EnhancedMode: c.EnhancedMode,
125: 		Pool:         c.FakeIPRange,
126: 		Hosts:        c.Hosts,
127: 		FallbackFilter: dns.FallbackFilter{
128: 			GeoIP:     c.FallbackFilter.GeoIP,
129: 			GeoIPCode: c.FallbackFilter.GeoIPCode,
130: 			IPCIDR:    c.FallbackFilter.IPCIDR,
131: 			Domain:    c.FallbackFilter.Domain,
132: 		},
133: 		Default:       c.DefaultNameserver,
134: 		Policy:        c.NameServerPolicy,
135: 		SearchDomains: c.SearchDomains,
136: 	}
137: 
138: 	r := dns.NewResolver(cfg)
139: 	m := dns.NewEnhancer(cfg)
140: 
141: 	// reuse cache of old host mapper
142: 	if old := resolver.DefaultHostMapper; old != nil {
143: 		m.PatchFrom(old.(*dns.ResolverEnhancer))
144: 	}
145: 
146: 	resolver.DefaultResolver = r
147: 	resolver.DefaultHostMapper = m
148: 
149: 	dns.ReCreateServer(c.Listen, r, m)
150: }
151: 
152: func updateHosts(tree *trie.DomainTrie) {
153: 	resolver.DefaultHosts = tree
154: }
155: 
156: func updateProxies(proxies map[string]C.Proxy, providers map[string]provider.ProxyProvider) {
157: 	tunnel.UpdateProxies(proxies, providers)
158: }
159: 
160: func updateRules(rules []C.Rule) {
161: 	tunnel.UpdateRules(rules)
162: }
163: 
164: func updateTunnels(tunnels []config.Tunnel) {
165: 	listener.PatchTunnel(tunnels, tunnel.TCPIn(), tunnel.UDPIn())
166: }
167: 
168: func updateInbounds(inbounds []C.Inbound, force bool) {
169: 	if !force {
170: 		return
171: 	}
172: 	tcpIn := tunnel.TCPIn()
173: 	udpIn := tunnel.UDPIn()
174: 
175: 	listener.ReCreateListeners(inbounds, tcpIn, udpIn)
176: }
177: 
178: func updateGeneral(general *config.General, force bool) {
179: 	log.SetLevel(general.LogLevel)
180: 	tunnel.SetMode(general.Mode)
181: 	resolver.DisableIPv6 = !general.IPv6
182: 
183: 	dialer.DefaultInterface.Store(general.Interface)
184: 	dialer.DefaultRoutingMark.Store(int32(general.RoutingMark))
185: 
186: 	iface.FlushCache()
187: 
188: 	if !force {
189: 		return
190: 	}
191: 
192: 	allowLan := general.AllowLan
193: 	listener.SetAllowLan(allowLan)
194: 
195: 	bindAddress := general.BindAddress
196: 	listener.SetBindAddress(bindAddress)
197: 
198: 	ports := listener.Ports{
199: 		Port:       general.Port,
200: 		SocksPort:  general.SocksPort,
201: 		RedirPort:  general.RedirPort,
202: 		TProxyPort: general.TProxyPort,
203: 		MixedPort:  general.MixedPort,
204: 	}
205: 	listener.ReCreatePortsListeners(ports, tunnel.TCPIn(), tunnel.UDPIn())
206: }
207: 
208: func updateUsers(users []auth.AuthUser) {
209: 	authenticator := auth.NewAuthenticator(users)
210: 	authStore.SetAuthenticator(authenticator)
211: 	if authenticator != nil {
212: 		log.Infoln("Authentication of local server updated")
213: 	}
214: }
215: 
216: func updateProfile(cfg *config.Config) {
217: 	profileCfg := cfg.Profile
218: 
219: 	profile.StoreSelected.Store(profileCfg.StoreSelected)
220: 	if profileCfg.StoreSelected {
221: 		patchSelectGroup(cfg.Proxies)
222: 	}
223: }
224: 
225: func patchSelectGroup(proxies map[string]C.Proxy) {
226: 	mapping := cachefile.Cache().SelectedMap()
227: 	if mapping == nil {
228: 		return
229: 	}
230: 
231: 	for name, proxy := range proxies {
232: 		outbound, ok := proxy.(*adapter.Proxy)
233: 		if !ok {
234: 			continue
235: 		}
236: 
237: 		selector, ok := outbound.ProxyAdapter.(*outboundgroup.Selector)
238: 		if !ok {
239: 			continue
240: 		}
241: 
242: 		selected, exist := mapping[name]
243: 		if !exist {
244: 			continue
245: 		}
246: 
247: 		selector.Set(selected)
248: 	}
249: }


./hub\route\common.go
1: package route
2: 
3: import (
4: 	"net/http"
5: 	"net/url"
6: 
7: 	"github.com/go-chi/chi/v5"
8: )
9: 
10: // When name is composed of a partial escape string, Golang does not unescape it
11: func getEscapeParam(r *http.Request, paramName string) string {
12: 	param := chi.URLParam(r, paramName)
13: 	if newParam, err := url.PathUnescape(param); err == nil {
14: 		param = newParam
15: 	}
16: 	return param
17: }


./hub\route\configs.go
1: package route
2: 
3: import (
4: 	"net/http"
5: 	"path/filepath"
6: 
7: 	"github.com/Dreamacro/clash/component/resolver"
8: 	"github.com/Dreamacro/clash/config"
9: 	C "github.com/Dreamacro/clash/constant"
10: 	"github.com/Dreamacro/clash/hub/executor"
11: 	"github.com/Dreamacro/clash/listener"
12: 	"github.com/Dreamacro/clash/log"
13: 	"github.com/Dreamacro/clash/tunnel"
14: 
15: 	"github.com/go-chi/chi/v5"
16: 	"github.com/go-chi/render"
17: 	"github.com/samber/lo"
18: )
19: 
20: func configRouter() http.Handler {
21: 	r := chi.NewRouter()
22: 	r.Get("/", getConfigs)
23: 	r.Put("/", updateConfigs)
24: 	r.Patch("/", patchConfigs)
25: 	return r
26: }
27: 
28: func getConfigs(w http.ResponseWriter, r *http.Request) {
29: 	general := executor.GetGeneral()
30: 	render.JSON(w, r, general)
31: }
32: 
33: func patchConfigs(w http.ResponseWriter, r *http.Request) {
34: 	general := struct {
35: 		Port        *int               `json:"port"`
36: 		SocksPort   *int               `json:"socks-port"`
37: 		RedirPort   *int               `json:"redir-port"`
38: 		TProxyPort  *int               `json:"tproxy-port"`
39: 		MixedPort   *int               `json:"mixed-port"`
40: 		AllowLan    *bool              `json:"allow-lan"`
41: 		BindAddress *string            `json:"bind-address"`
42: 		Mode        *tunnel.TunnelMode `json:"mode"`
43: 		LogLevel    *log.LogLevel      `json:"log-level"`
44: 		IPv6        *bool              `json:"ipv6"`
45: 	}{}
46: 	if err := render.DecodeJSON(r.Body, &general); err != nil {
47: 		render.Status(r, http.StatusBadRequest)
48: 		render.JSON(w, r, ErrBadRequest)
49: 		return
50: 	}
51: 
52: 	if general.Mode != nil {
53: 		tunnel.SetMode(*general.Mode)
54: 	}
55: 
56: 	if general.LogLevel != nil {
57: 		log.SetLevel(*general.LogLevel)
58: 	}
59: 
60: 	if general.IPv6 != nil {
61: 		resolver.DisableIPv6 = !*general.IPv6
62: 	}
63: 
64: 	if general.AllowLan != nil {
65: 		listener.SetAllowLan(*general.AllowLan)
66: 	}
67: 
68: 	if general.BindAddress != nil {
69: 		listener.SetBindAddress(*general.BindAddress)
70: 	}
71: 
72: 	ports := listener.GetPorts()
73: 	ports.Port = lo.FromPtrOr(general.Port, ports.Port)
74: 	ports.SocksPort = lo.FromPtrOr(general.SocksPort, ports.SocksPort)
75: 	ports.RedirPort = lo.FromPtrOr(general.RedirPort, ports.RedirPort)
76: 	ports.TProxyPort = lo.FromPtrOr(general.TProxyPort, ports.TProxyPort)
77: 	ports.MixedPort = lo.FromPtrOr(general.MixedPort, ports.MixedPort)
78: 
79: 	listener.ReCreatePortsListeners(*ports, tunnel.TCPIn(), tunnel.UDPIn())
80: 
81: 	render.NoContent(w, r)
82: }
83: 
84: func updateConfigs(w http.ResponseWriter, r *http.Request) {
85: 	req := struct {
86: 		Path    string `json:"path"`
87: 		Payload string `json:"payload"`
88: 	}{}
89: 	if err := render.DecodeJSON(r.Body, &req); err != nil {
90: 		render.Status(r, http.StatusBadRequest)
91: 		render.JSON(w, r, ErrBadRequest)
92: 		return
93: 	}
94: 
95: 	force := r.URL.Query().Get("force") == "true"
96: 	var cfg *config.Config
97: 	var err error
98: 
99: 	if req.Payload != "" {
100: 		cfg, err = executor.ParseWithBytes([]byte(req.Payload))
101: 		if err != nil {
102: 			render.Status(r, http.StatusBadRequest)
103: 			render.JSON(w, r, newError(err.Error()))
104: 			return
105: 		}
106: 	} else {
107: 		if req.Path == "" {
108: 			req.Path = C.Path.Config()
109: 		}
110: 		if !filepath.IsAbs(req.Path) {
111: 			render.Status(r, http.StatusBadRequest)
112: 			render.JSON(w, r, newError("path is not a absolute path"))
113: 			return
114: 		}
115: 
116: 		cfg, err = executor.ParseWithPath(req.Path)
117: 		if err != nil {
118: 			render.Status(r, http.StatusBadRequest)
119: 			render.JSON(w, r, newError(err.Error()))
120: 			return
121: 		}
122: 	}
123: 
124: 	executor.ApplyConfig(cfg, force)
125: 	render.NoContent(w, r)
126: }


./hub\route\connections.go
1: package route
2: 
3: import (
4: 	"encoding/json"
5: 	"net/http"
6: 	"strconv"
7: 	"time"
8: 
9: 	"github.com/Dreamacro/clash/tunnel/statistic"
10: 
11: 	"github.com/Dreamacro/protobytes"
12: 	"github.com/go-chi/chi/v5"
13: 	"github.com/go-chi/render"
14: 	"github.com/gorilla/websocket"
15: )
16: 
17: func connectionRouter() http.Handler {
18: 	r := chi.NewRouter()
19: 	r.Get("/", getConnections)
20: 	r.Delete("/", closeAllConnections)
21: 	r.Delete("/{id}", closeConnection)
22: 	return r
23: }
24: 
25: func getConnections(w http.ResponseWriter, r *http.Request) {
26: 	if !websocket.IsWebSocketUpgrade(r) {
27: 		snapshot := statistic.DefaultManager.Snapshot()
28: 		render.JSON(w, r, snapshot)
29: 		return
30: 	}
31: 
32: 	conn, err := upgrader.Upgrade(w, r, nil)
33: 	if err != nil {
34: 		return
35: 	}
36: 
37: 	intervalStr := r.URL.Query().Get("interval")
38: 	interval := 1000
39: 	if intervalStr != "" {
40: 		t, err := strconv.Atoi(intervalStr)
41: 		if err != nil {
42: 			render.Status(r, http.StatusBadRequest)
43: 			render.JSON(w, r, ErrBadRequest)
44: 			return
45: 		}
46: 
47: 		interval = t
48: 	}
49: 
50: 	buf := protobytes.BytesWriter{}
51: 	sendSnapshot := func() error {
52: 		buf.Reset()
53: 		snapshot := statistic.DefaultManager.Snapshot()
54: 		if err := json.NewEncoder(&buf).Encode(snapshot); err != nil {
55: 			return err
56: 		}
57: 
58: 		return conn.WriteMessage(websocket.TextMessage, buf.Bytes())
59: 	}
60: 
61: 	if err := sendSnapshot(); err != nil {
62: 		return
63: 	}
64: 
65: 	tick := time.NewTicker(time.Millisecond * time.Duration(interval))
66: 	defer tick.Stop()
67: 	for range tick.C {
68: 		if err := sendSnapshot(); err != nil {
69: 			break
70: 		}
71: 	}
72: }
73: 
74: func closeConnection(w http.ResponseWriter, r *http.Request) {
75: 	id := chi.URLParam(r, "id")
76: 	snapshot := statistic.DefaultManager.Snapshot()
77: 	for _, c := range snapshot.Connections {
78: 		if id == c.ID() {
79: 			c.Close()
80: 			break
81: 		}
82: 	}
83: 	render.NoContent(w, r)
84: }
85: 
86: func closeAllConnections(w http.ResponseWriter, r *http.Request) {
87: 	snapshot := statistic.DefaultManager.Snapshot()
88: 	for _, c := range snapshot.Connections {
89: 		c.Close()
90: 	}
91: 	render.NoContent(w, r)
92: }


./hub\route\ctxkeys.go
1: package route
2: 
3: var (
4: 	CtxKeyProxyName    = contextKey("proxy name")
5: 	CtxKeyProviderName = contextKey("provider name")
6: 	CtxKeyProxy        = contextKey("proxy")
7: 	CtxKeyProvider     = contextKey("provider")
8: )
9: 
10: type contextKey string
11: 
12: func (c contextKey) String() string {
13: 	return "clash context key " + string(c)
14: }


./hub\route\dns.go
1: package route
2: 
3: import (
4: 	"context"
5: 	"math"
6: 	"net/http"
7: 
8: 	"github.com/Dreamacro/clash/component/resolver"
9: 
10: 	"github.com/go-chi/chi/v5"
11: 	"github.com/go-chi/render"
12: 	"github.com/miekg/dns"
13: 	"github.com/samber/lo"
14: )
15: 
16: func dnsRouter() http.Handler {
17: 	r := chi.NewRouter()
18: 	r.Get("/query", queryDNS)
19: 	return r
20: }
21: 
22: func queryDNS(w http.ResponseWriter, r *http.Request) {
23: 	if resolver.DefaultResolver == nil {
24: 		render.Status(r, http.StatusInternalServerError)
25: 		render.JSON(w, r, newError("DNS section is disabled"))
26: 		return
27: 	}
28: 
29: 	name := r.URL.Query().Get("name")
30: 	qTypeStr, _ := lo.Coalesce(r.URL.Query().Get("type"), "A")
31: 
32: 	qType, exist := dns.StringToType[qTypeStr]
33: 	if !exist {
34: 		render.Status(r, http.StatusBadRequest)
35: 		render.JSON(w, r, newError("invalid query type"))
36: 		return
37: 	}
38: 
39: 	ctx, cancel := context.WithTimeout(context.Background(), resolver.DefaultDNSTimeout)
40: 	defer cancel()
41: 
42: 	msg := dns.Msg{}
43: 	msg.SetQuestion(dns.Fqdn(name), qType)
44: 	resp, err := resolver.DefaultResolver.ExchangeContext(ctx, &msg)
45: 	if err != nil {
46: 		render.Status(r, http.StatusInternalServerError)
47: 		render.JSON(w, r, newError(err.Error()))
48: 		return
49: 	}
50: 
51: 	responseData := render.M{
52: 		"Status":   resp.Rcode,
53: 		"Question": resp.Question,
54: 		"TC":       resp.Truncated,
55: 		"RD":       resp.RecursionDesired,
56: 		"RA":       resp.RecursionAvailable,
57: 		"AD":       resp.AuthenticatedData,
58: 		"CD":       resp.CheckingDisabled,
59: 	}
60: 
61: 	rr2Json := func(rr dns.RR, _ int) render.M {
62: 		header := rr.Header()
63: 		return render.M{
64: 			"name": header.Name,
65: 			"type": header.Rrtype,
66: 			"TTL":  header.Ttl,
67: 			"data": lo.Substring(rr.String(), len(header.String()), math.MaxUint),
68: 		}
69: 	}
70: 
71: 	if len(resp.Answer) > 0 {
72: 		responseData["Answer"] = lo.Map(resp.Answer, rr2Json)
73: 	}
74: 	if len(resp.Ns) > 0 {
75: 		responseData["Authority"] = lo.Map(resp.Ns, rr2Json)
76: 	}
77: 	if len(resp.Extra) > 0 {
78: 		responseData["Additional"] = lo.Map(resp.Extra, rr2Json)
79: 	}
80: 
81: 	render.JSON(w, r, responseData)
82: }


./hub\route\errors.go
1: package route
2: 
3: var (
4: 	ErrUnauthorized   = newError("Unauthorized")
5: 	ErrBadRequest     = newError("Body invalid")
6: 	ErrForbidden      = newError("Forbidden")
7: 	ErrNotFound       = newError("Resource not found")
8: 	ErrRequestTimeout = newError("Timeout")
9: )
10: 
11: // HTTPError is custom HTTP error for API
12: type HTTPError struct {
13: 	Message string `json:"message"`
14: }
15: 
16: func (e *HTTPError) Error() string {
17: 	return e.Message
18: }
19: 
20: func newError(msg string) *HTTPError {
21: 	return &HTTPError{Message: msg}
22: }


./hub\route\inbounds.go
1: package route
2: 
3: import (
4: 	"net/http"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: 	"github.com/Dreamacro/clash/listener"
8: 	"github.com/Dreamacro/clash/tunnel"
9: 
10: 	"github.com/go-chi/chi/v5"
11: 	"github.com/go-chi/render"
12: )
13: 
14: func inboundRouter() http.Handler {
15: 	r := chi.NewRouter()
16: 	r.Get("/", getInbounds)
17: 	r.Put("/", updateInbounds)
18: 	return r
19: }
20: 
21: func getInbounds(w http.ResponseWriter, r *http.Request) {
22: 	inbounds := listener.GetInbounds()
23: 	render.JSON(w, r, render.M{
24: 		"inbounds": inbounds,
25: 	})
26: }
27: 
28: func updateInbounds(w http.ResponseWriter, r *http.Request) {
29: 	var req []C.Inbound
30: 	if err := render.DecodeJSON(r.Body, &req); err != nil {
31: 		render.Status(r, http.StatusBadRequest)
32: 		render.JSON(w, r, ErrBadRequest)
33: 		return
34: 	}
35: 	tcpIn := tunnel.TCPIn()
36: 	udpIn := tunnel.UDPIn()
37: 	listener.ReCreateListeners(req, tcpIn, udpIn)
38: 	render.NoContent(w, r)
39: }


./hub\route\provider.go
1: package route
2: 
3: import (
4: 	"context"
5: 	"net/http"
6: 
7: 	C "github.com/Dreamacro/clash/constant"
8: 	"github.com/Dreamacro/clash/constant/provider"
9: 	"github.com/Dreamacro/clash/tunnel"
10: 
11: 	"github.com/go-chi/chi/v5"
12: 	"github.com/go-chi/render"
13: 	"github.com/samber/lo"
14: )
15: 
16: func proxyProviderRouter() http.Handler {
17: 	r := chi.NewRouter()
18: 	r.Get("/", getProviders)
19: 
20: 	r.Route("/{providerName}", func(r chi.Router) {
21: 		r.Use(parseProviderName, findProviderByName)
22: 		r.Get("/", getProvider)
23: 		r.Put("/", updateProvider)
24: 		r.Get("/healthcheck", healthCheckProvider)
25: 		r.Mount("/", proxyProviderProxyRouter())
26: 	})
27: 	return r
28: }
29: 
30: func proxyProviderProxyRouter() http.Handler {
31: 	r := chi.NewRouter()
32: 	r.Route("/{name}", func(r chi.Router) {
33: 		r.Use(parseProxyName, findProviderProxyByName)
34: 		r.Get("/", getProxy)
35: 		r.Get("/healthcheck", getProxyDelay)
36: 	})
37: 	return r
38: }
39: 
40: func getProviders(w http.ResponseWriter, r *http.Request) {
41: 	providers := tunnel.Providers()
42: 	render.JSON(w, r, render.M{
43: 		"providers": providers,
44: 	})
45: }
46: 
47: func getProvider(w http.ResponseWriter, r *http.Request) {
48: 	provider := r.Context().Value(CtxKeyProvider).(provider.ProxyProvider)
49: 	render.JSON(w, r, provider)
50: }
51: 
52: func updateProvider(w http.ResponseWriter, r *http.Request) {
53: 	provider := r.Context().Value(CtxKeyProvider).(provider.ProxyProvider)
54: 	if err := provider.Update(); err != nil {
55: 		render.Status(r, http.StatusServiceUnavailable)
56: 		render.JSON(w, r, newError(err.Error()))
57: 		return
58: 	}
59: 	render.NoContent(w, r)
60: }
61: 
62: func healthCheckProvider(w http.ResponseWriter, r *http.Request) {
63: 	provider := r.Context().Value(CtxKeyProvider).(provider.ProxyProvider)
64: 	provider.HealthCheck()
65: 	render.NoContent(w, r)
66: }
67: 
68: func parseProviderName(next http.Handler) http.Handler {
69: 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
70: 		name := getEscapeParam(r, "providerName")
71: 		ctx := context.WithValue(r.Context(), CtxKeyProviderName, name)
72: 		next.ServeHTTP(w, r.WithContext(ctx))
73: 	})
74: }
75: 
76: func findProviderByName(next http.Handler) http.Handler {
77: 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
78: 		name := r.Context().Value(CtxKeyProviderName).(string)
79: 		providers := tunnel.Providers()
80: 		provider, exist := providers[name]
81: 		if !exist {
82: 			render.Status(r, http.StatusNotFound)
83: 			render.JSON(w, r, ErrNotFound)
84: 			return
85: 		}
86: 
87: 		ctx := context.WithValue(r.Context(), CtxKeyProvider, provider)
88: 		next.ServeHTTP(w, r.WithContext(ctx))
89: 	})
90: }
91: 
92: func findProviderProxyByName(next http.Handler) http.Handler {
93: 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
94: 		var (
95: 			name = r.Context().Value(CtxKeyProxyName).(string)
96: 			pd   = r.Context().Value(CtxKeyProvider).(provider.ProxyProvider)
97: 		)
98: 		proxy, exist := lo.Find(pd.Proxies(), func(proxy C.Proxy) bool {
99: 			return proxy.Name() == name
100: 		})
101: 
102: 		if !exist {
103: 			render.Status(r, http.StatusNotFound)
104: 			render.JSON(w, r, ErrNotFound)
105: 			return
106: 		}
107: 
108: 		ctx := context.WithValue(r.Context(), CtxKeyProxy, proxy)
109: 		next.ServeHTTP(w, r.WithContext(ctx))
110: 	})
111: }


./hub\route\proxies.go
1: package route
2: 
3: import (
4: 	"context"
5: 	"fmt"
6: 	"net/http"
7: 	"strconv"
8: 	"time"
9: 
10: 	"github.com/Dreamacro/clash/adapter"
11: 	"github.com/Dreamacro/clash/adapter/outboundgroup"
12: 	"github.com/Dreamacro/clash/component/profile/cachefile"
13: 	C "github.com/Dreamacro/clash/constant"
14: 	"github.com/Dreamacro/clash/tunnel"
15: 
16: 	"github.com/go-chi/chi/v5"
17: 	"github.com/go-chi/render"
18: )
19: 
20: func proxyRouter() http.Handler {
21: 	r := chi.NewRouter()
22: 	r.Get("/", getProxies)
23: 
24: 	r.Route("/{name}", func(r chi.Router) {
25: 		r.Use(parseProxyName, findProxyByName)
26: 		r.Get("/", getProxy)
27: 		r.Get("/delay", getProxyDelay)
28: 		r.Put("/", updateProxy)
29: 	})
30: 	return r
31: }
32: 
33: func parseProxyName(next http.Handler) http.Handler {
34: 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
35: 		name := getEscapeParam(r, "name")
36: 		ctx := context.WithValue(r.Context(), CtxKeyProxyName, name)
37: 		next.ServeHTTP(w, r.WithContext(ctx))
38: 	})
39: }
40: 
41: func findProxyByName(next http.Handler) http.Handler {
42: 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
43: 		name := r.Context().Value(CtxKeyProxyName).(string)
44: 		proxies := tunnel.Proxies()
45: 		proxy, exist := proxies[name]
46: 		if !exist {
47: 			render.Status(r, http.StatusNotFound)
48: 			render.JSON(w, r, ErrNotFound)
49: 			return
50: 		}
51: 
52: 		ctx := context.WithValue(r.Context(), CtxKeyProxy, proxy)
53: 		next.ServeHTTP(w, r.WithContext(ctx))
54: 	})
55: }
56: 
57: func getProxies(w http.ResponseWriter, r *http.Request) {
58: 	proxies := tunnel.Proxies()
59: 	render.JSON(w, r, render.M{
60: 		"proxies": proxies,
61: 	})
62: }
63: 
64: func getProxy(w http.ResponseWriter, r *http.Request) {
65: 	proxy := r.Context().Value(CtxKeyProxy).(C.Proxy)
66: 	render.JSON(w, r, proxy)
67: }
68: 
69: func updateProxy(w http.ResponseWriter, r *http.Request) {
70: 	req := struct {
71: 		Name string `json:"name"`
72: 	}{}
73: 	if err := render.DecodeJSON(r.Body, &req); err != nil {
74: 		render.Status(r, http.StatusBadRequest)
75: 		render.JSON(w, r, ErrBadRequest)
76: 		return
77: 	}
78: 
79: 	proxy := r.Context().Value(CtxKeyProxy).(*adapter.Proxy)
80: 	selector, ok := proxy.ProxyAdapter.(*outboundgroup.Selector)
81: 	if !ok {
82: 		render.Status(r, http.StatusBadRequest)
83: 		render.JSON(w, r, newError("Must be a Selector"))
84: 		return
85: 	}
86: 
87: 	if err := selector.Set(req.Name); err != nil {
88: 		render.Status(r, http.StatusBadRequest)
89: 		render.JSON(w, r, newError(fmt.Sprintf("Selector update error: %s", err.Error())))
90: 		return
91: 	}
92: 
93: 	cachefile.Cache().SetSelected(proxy.Name(), req.Name)
94: 	render.NoContent(w, r)
95: }
96: 
97: func getProxyDelay(w http.ResponseWriter, r *http.Request) {
98: 	query := r.URL.Query()
99: 	url := query.Get("url")
100: 	timeout, err := strconv.ParseInt(query.Get("timeout"), 10, 16)
101: 	if err != nil {
102: 		render.Status(r, http.StatusBadRequest)
103: 		render.JSON(w, r, ErrBadRequest)
104: 		return
105: 	}
106: 
107: 	proxy := r.Context().Value(CtxKeyProxy).(C.Proxy)
108: 
109: 	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*time.Duration(timeout))
110: 	defer cancel()
111: 
112: 	delay, meanDelay, err := proxy.URLTest(ctx, url)
113: 	if ctx.Err() != nil {
114: 		render.Status(r, http.StatusGatewayTimeout)
115: 		render.JSON(w, r, ErrRequestTimeout)
116: 		return
117: 	}
118: 
119: 	if err != nil || delay == 0 {
120: 		render.Status(r, http.StatusServiceUnavailable)
121: 		render.JSON(w, r, newError("An error occurred in the delay test"))
122: 		return
123: 	}
124: 
125: 	render.JSON(w, r, render.M{
126: 		"delay":     delay,
127: 		"meanDelay": meanDelay,
128: 	})
129: }


./hub\route\rules.go
1: package route
2: 
3: import (
4: 	"net/http"
5: 
6: 	"github.com/Dreamacro/clash/tunnel"
7: 
8: 	"github.com/go-chi/chi/v5"
9: 	"github.com/go-chi/render"
10: )
11: 
12: func ruleRouter() http.Handler {
13: 	r := chi.NewRouter()
14: 	r.Get("/", getRules)
15: 	return r
16: }
17: 
18: type Rule struct {
19: 	Type    string `json:"type"`
20: 	Payload string `json:"payload"`
21: 	Proxy   string `json:"proxy"`
22: }
23: 
24: func getRules(w http.ResponseWriter, r *http.Request) {
25: 	rawRules := tunnel.Rules()
26: 
27: 	rules := []Rule{}
28: 	for _, rule := range rawRules {
29: 		rules = append(rules, Rule{
30: 			Type:    rule.RuleType().String(),
31: 			Payload: rule.Payload(),
32: 			Proxy:   rule.Adapter(),
33: 		})
34: 	}
35: 
36: 	render.JSON(w, r, render.M{
37: 		"rules": rules,
38: 	})
39: }


./hub\route\server.go
1: package route
2: 
3: import (
4: 	"bytes"
5: 	"crypto/subtle"
6: 	"encoding/json"
7: 	"net"
8: 	"net/http"
9: 	"strings"
10: 	"time"
11: 	"unsafe"
12: 
13: 	C "github.com/Dreamacro/clash/constant"
14: 	"github.com/Dreamacro/clash/log"
15: 	"github.com/Dreamacro/clash/tunnel/statistic"
16: 
17: 	"github.com/Dreamacro/protobytes"
18: 	"github.com/go-chi/chi/v5"
19: 	"github.com/go-chi/cors"
20: 	"github.com/go-chi/render"
21: 	"github.com/gorilla/websocket"
22: )
23: 
24: var (
25: 	serverSecret = ""
26: 	serverAddr   = ""
27: 
28: 	uiPath = ""
29: 
30: 	upgrader = websocket.Upgrader{
31: 		CheckOrigin: func(r *http.Request) bool {
32: 			return true
33: 		},
34: 	}
35: )
36: 
37: type Traffic struct {
38: 	Up   int64 `json:"up"`
39: 	Down int64 `json:"down"`
40: }
41: 
42: func SetUIPath(path string) {
43: 	uiPath = C.Path.Resolve(path)
44: }
45: 
46: func Start(addr string, secret string) {
47: 	if serverAddr != "" {
48: 		return
49: 	}
50: 
51: 	serverAddr = addr
52: 	serverSecret = secret
53: 
54: 	r := chi.NewRouter()
55: 
56: 	cors := cors.New(cors.Options{
57: 		AllowedOrigins: []string{"*"},
58: 		AllowedMethods: []string{"GET", "POST", "PUT", "PATCH", "DELETE"},
59: 		AllowedHeaders: []string{"Content-Type", "Authorization"},
60: 		MaxAge:         300,
61: 	})
62: 
63: 	r.Use(cors.Handler)
64: 	r.Group(func(r chi.Router) {
65: 		r.Use(authentication)
66: 
67: 		r.Get("/", hello)
68: 		r.Get("/logs", getLogs)
69: 		r.Get("/traffic", traffic)
70: 		r.Get("/version", version)
71: 		r.Mount("/configs", configRouter())
72: 		r.Mount("/inbounds", inboundRouter())
73: 		r.Mount("/proxies", proxyRouter())
74: 		r.Mount("/rules", ruleRouter())
75: 		r.Mount("/connections", connectionRouter())
76: 		r.Mount("/providers/proxies", proxyProviderRouter())
77: 		r.Mount("/dns", dnsRouter())
78: 	})
79: 
80: 	if uiPath != "" {
81: 		r.Group(func(r chi.Router) {
82: 			fs := http.StripPrefix("/ui", http.FileServer(http.Dir(uiPath)))
83: 			r.Get("/ui", http.RedirectHandler("/ui/", http.StatusTemporaryRedirect).ServeHTTP)
84: 			r.Get("/ui/*", func(w http.ResponseWriter, r *http.Request) {
85: 				fs.ServeHTTP(w, r)
86: 			})
87: 		})
88: 	}
89: 
90: 	l, err := net.Listen("tcp", addr)
91: 	if err != nil {
92: 		log.Errorln("External controller listen error: %s", err)
93: 		return
94: 	}
95: 	serverAddr = l.Addr().String()
96: 	log.Infoln("RESTful API listening at: %s", serverAddr)
97: 	if err = http.Serve(l, r); err != nil {
98: 		log.Errorln("External controller serve error: %s", err)
99: 	}
100: }
101: 
102: func safeEuqal(a, b string) bool {
103: 	aBuf := unsafe.Slice(unsafe.StringData(a), len(a))
104: 	bBuf := unsafe.Slice(unsafe.StringData(b), len(b))
105: 	return subtle.ConstantTimeCompare(aBuf, bBuf) == 1
106: }
107: 
108: func authentication(next http.Handler) http.Handler {
109: 	fn := func(w http.ResponseWriter, r *http.Request) {
110: 		if serverSecret == "" {
111: 			next.ServeHTTP(w, r)
112: 			return
113: 		}
114: 
115: 		// Browser websocket not support custom header
116: 		if websocket.IsWebSocketUpgrade(r) && r.URL.Query().Get("token") != "" {
117: 			token := r.URL.Query().Get("token")
118: 			if !safeEuqal(token, serverSecret) {
119: 				render.Status(r, http.StatusUnauthorized)
120: 				render.JSON(w, r, ErrUnauthorized)
121: 				return
122: 			}
123: 			next.ServeHTTP(w, r)
124: 			return
125: 		}
126: 
127: 		header := r.Header.Get("Authorization")
128: 		bearer, token, found := strings.Cut(header, " ")
129: 
130: 		hasInvalidHeader := bearer != "Bearer"
131: 		hasInvalidSecret := !found || !safeEuqal(token, serverSecret)
132: 		if hasInvalidHeader || hasInvalidSecret {
133: 			render.Status(r, http.StatusUnauthorized)
134: 			render.JSON(w, r, ErrUnauthorized)
135: 			return
136: 		}
137: 		next.ServeHTTP(w, r)
138: 	}
139: 	return http.HandlerFunc(fn)
140: }
141: 
142: func hello(w http.ResponseWriter, r *http.Request) {
143: 	render.JSON(w, r, render.M{"hello": "clash"})
144: }
145: 
146: func traffic(w http.ResponseWriter, r *http.Request) {
147: 	var wsConn *websocket.Conn
148: 	if websocket.IsWebSocketUpgrade(r) {
149: 		var err error
150: 		wsConn, err = upgrader.Upgrade(w, r, nil)
151: 		if err != nil {
152: 			return
153: 		}
154: 	}
155: 
156: 	if wsConn == nil {
157: 		w.Header().Set("Content-Type", "application/json")
158: 		render.Status(r, http.StatusOK)
159: 	}
160: 
161: 	tick := time.NewTicker(time.Second)
162: 	defer tick.Stop()
163: 	t := statistic.DefaultManager
164: 	buf := protobytes.BytesWriter{}
165: 	var err error
166: 	for range tick.C {
167: 		buf.Reset()
168: 		up, down := t.Now()
169: 		if err := json.NewEncoder(&buf).Encode(Traffic{
170: 			Up:   up,
171: 			Down: down,
172: 		}); err != nil {
173: 			break
174: 		}
175: 
176: 		if wsConn == nil {
177: 			_, err = w.Write(buf.Bytes())
178: 			w.(http.Flusher).Flush()
179: 		} else {
180: 			err = wsConn.WriteMessage(websocket.TextMessage, buf.Bytes())
181: 		}
182: 
183: 		if err != nil {
184: 			break
185: 		}
186: 	}
187: }
188: 
189: type Log struct {
190: 	Type    string `json:"type"`
191: 	Payload string `json:"payload"`
192: }
193: 
194: func getLogs(w http.ResponseWriter, r *http.Request) {
195: 	levelText := r.URL.Query().Get("level")
196: 	if levelText == "" {
197: 		levelText = "info"
198: 	}
199: 
200: 	level, ok := log.LogLevelMapping[levelText]
201: 	if !ok {
202: 		render.Status(r, http.StatusBadRequest)
203: 		render.JSON(w, r, ErrBadRequest)
204: 		return
205: 	}
206: 
207: 	var wsConn *websocket.Conn
208: 	if websocket.IsWebSocketUpgrade(r) {
209: 		var err error
210: 		wsConn, err = upgrader.Upgrade(w, r, nil)
211: 		if err != nil {
212: 			return
213: 		}
214: 	}
215: 
216: 	if wsConn == nil {
217: 		w.Header().Set("Content-Type", "application/json")
218: 		render.Status(r, http.StatusOK)
219: 	}
220: 
221: 	ch := make(chan log.Event, 1024)
222: 	sub := log.Subscribe()
223: 	defer log.UnSubscribe(sub)
224: 	buf := &bytes.Buffer{}
225: 
226: 	go func() {
227: 		for elm := range sub {
228: 			log := elm.(log.Event)
229: 			select {
230: 			case ch <- log:
231: 			default:
232: 			}
233: 		}
234: 		close(ch)
235: 	}()
236: 
237: 	for log := range ch {
238: 		if log.LogLevel < level {
239: 			continue
240: 		}
241: 		buf.Reset()
242: 
243: 		if err := json.NewEncoder(buf).Encode(Log{
244: 			Type:    log.Type(),
245: 			Payload: log.Payload,
246: 		}); err != nil {
247: 			break
248: 		}
249: 
250: 		var err error
251: 		if wsConn == nil {
252: 			_, err = w.Write(buf.Bytes())
253: 			w.(http.Flusher).Flush()
254: 		} else {
255: 			err = wsConn.WriteMessage(websocket.TextMessage, buf.Bytes())
256: 		}
257: 
258: 		if err != nil {
259: 			break
260: 		}
261: 	}
262: }
263: 
264: func version(w http.ResponseWriter, r *http.Request) {
265: 	render.JSON(w, r, render.M{"version": C.Version})
266: }


./listener\listener.go
1: package listener
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 	"strconv"
7: 	"strings"
8: 	"sync"
9: 
10: 	"github.com/Dreamacro/clash/adapter/inbound"
11: 	"github.com/Dreamacro/clash/config"
12: 	C "github.com/Dreamacro/clash/constant"
13: 	"github.com/Dreamacro/clash/listener/http"
14: 	"github.com/Dreamacro/clash/listener/mixed"
15: 	"github.com/Dreamacro/clash/listener/redir"
16: 	"github.com/Dreamacro/clash/listener/socks"
17: 	"github.com/Dreamacro/clash/listener/tproxy"
18: 	"github.com/Dreamacro/clash/listener/tunnel"
19: 	"github.com/Dreamacro/clash/log"
20: 
21: 	"github.com/samber/lo"
22: )
23: 
24: var (
25: 	allowLan    = false
26: 	bindAddress = "*"
27: 
28: 	tcpListeners = map[C.Inbound]C.Listener{}
29: 	udpListeners = map[C.Inbound]C.Listener{}
30: 
31: 	tunnelTCPListeners = map[string]*tunnel.Listener{}
32: 	tunnelUDPListeners = map[string]*tunnel.PacketConn{}
33: 
34: 	// lock for recreate function
35: 	recreateMux sync.Mutex
36: 	tunnelMux   sync.Mutex
37: )
38: 
39: type Ports struct {
40: 	Port       int `json:"port"`
41: 	SocksPort  int `json:"socks-port"`
42: 	RedirPort  int `json:"redir-port"`
43: 	TProxyPort int `json:"tproxy-port"`
44: 	MixedPort  int `json:"mixed-port"`
45: }
46: 
47: var tcpListenerCreators = map[C.InboundType]tcpListenerCreator{
48: 	C.InboundTypeHTTP:   http.New,
49: 	C.InboundTypeSocks:  socks.New,
50: 	C.InboundTypeRedir:  redir.New,
51: 	C.InboundTypeTproxy: tproxy.New,
52: 	C.InboundTypeMixed:  mixed.New,
53: }
54: 
55: var udpListenerCreators = map[C.InboundType]udpListenerCreator{
56: 	C.InboundTypeSocks:  socks.NewUDP,
57: 	C.InboundTypeRedir:  tproxy.NewUDP,
58: 	C.InboundTypeTproxy: tproxy.NewUDP,
59: 	C.InboundTypeMixed:  socks.NewUDP,
60: }
61: 
62: type (
63: 	tcpListenerCreator func(addr string, tcpIn chan<- C.ConnContext) (C.Listener, error)
64: 	udpListenerCreator func(addr string, udpIn chan<- *inbound.PacketAdapter) (C.Listener, error)
65: )
66: 
67: func AllowLan() bool {
68: 	return allowLan
69: }
70: 
71: func BindAddress() string {
72: 	return bindAddress
73: }
74: 
75: func SetAllowLan(al bool) {
76: 	allowLan = al
77: }
78: 
79: func SetBindAddress(host string) {
80: 	bindAddress = host
81: }
82: 
83: func createListener(inbound C.Inbound, tcpIn chan<- C.ConnContext, udpIn chan<- *inbound.PacketAdapter) {
84: 	addr := inbound.BindAddress
85: 	if portIsZero(addr) {
86: 		return
87: 	}
88: 	tcpCreator := tcpListenerCreators[inbound.Type]
89: 	udpCreator := udpListenerCreators[inbound.Type]
90: 	if tcpCreator == nil && udpCreator == nil {
91: 		log.Errorln("inbound type %s is not supported", inbound.Type)
92: 		return
93: 	}
94: 	if tcpCreator != nil {
95: 		tcpListener, err := tcpCreator(addr, tcpIn)
96: 		if err != nil {
97: 			log.Errorln("create addr %s tcp listener error: %v", addr, err)
98: 			return
99: 		}
100: 		tcpListeners[inbound] = tcpListener
101: 	}
102: 	if udpCreator != nil {
103: 		udpListener, err := udpCreator(addr, udpIn)
104: 		if err != nil {
105: 			log.Errorln("create addr %s udp listener error: %v", addr, err)
106: 			return
107: 		}
108: 		udpListeners[inbound] = udpListener
109: 	}
110: 	log.Infoln("inbound %s created successfully", inbound.ToAlias())
111: }
112: 
113: func closeListener(inbound C.Inbound) {
114: 	listener := tcpListeners[inbound]
115: 	if listener != nil {
116: 		if err := listener.Close(); err != nil {
117: 			log.Errorln("close tcp address `%s` error: %s", inbound.ToAlias(), err.Error())
118: 		}
119: 		delete(tcpListeners, inbound)
120: 	}
121: 	listener = udpListeners[inbound]
122: 	if listener != nil {
123: 		if err := listener.Close(); err != nil {
124: 			log.Errorln("close udp address `%s` error: %s", inbound.ToAlias(), err.Error())
125: 		}
126: 		delete(udpListeners, inbound)
127: 	}
128: }
129: 
130: func getNeedCloseAndCreateInbound(originInbounds []C.Inbound, newInbounds []C.Inbound) ([]C.Inbound, []C.Inbound) {
131: 	needCloseMap := map[C.Inbound]bool{}
132: 	needClose := []C.Inbound{}
133: 	needCreate := []C.Inbound{}
134: 
135: 	for _, inbound := range originInbounds {
136: 		needCloseMap[inbound] = true
137: 	}
138: 	for _, inbound := range newInbounds {
139: 		if needCloseMap[inbound] {
140: 			delete(needCloseMap, inbound)
141: 		} else {
142: 			needCreate = append(needCreate, inbound)
143: 		}
144: 	}
145: 	for inbound := range needCloseMap {
146: 		needClose = append(needClose, inbound)
147: 	}
148: 	return needClose, needCreate
149: }
150: 
151: // only recreate inbound config listener
152: func ReCreateListeners(inbounds []C.Inbound, tcpIn chan<- C.ConnContext, udpIn chan<- *inbound.PacketAdapter) {
153: 	newInbounds := []C.Inbound{}
154: 	newInbounds = append(newInbounds, inbounds...)
155: 	for _, inbound := range getInbounds() {
156: 		if inbound.IsFromPortCfg {
157: 			newInbounds = append(newInbounds, inbound)
158: 		}
159: 	}
160: 	reCreateListeners(newInbounds, tcpIn, udpIn)
161: }
162: 
163: // only recreate ports config listener
164: func ReCreatePortsListeners(ports Ports, tcpIn chan<- C.ConnContext, udpIn chan<- *inbound.PacketAdapter) {
165: 	newInbounds := []C.Inbound{}
166: 	newInbounds = append(newInbounds, GetInbounds()...)
167: 	newInbounds = addPortInbound(newInbounds, C.InboundTypeHTTP, ports.Port)
168: 	newInbounds = addPortInbound(newInbounds, C.InboundTypeSocks, ports.SocksPort)
169: 	newInbounds = addPortInbound(newInbounds, C.InboundTypeRedir, ports.RedirPort)
170: 	newInbounds = addPortInbound(newInbounds, C.InboundTypeTproxy, ports.TProxyPort)
171: 	newInbounds = addPortInbound(newInbounds, C.InboundTypeMixed, ports.MixedPort)
172: 	reCreateListeners(newInbounds, tcpIn, udpIn)
173: }
174: 
175: func addPortInbound(inbounds []C.Inbound, inboundType C.InboundType, port int) []C.Inbound {
176: 	if port != 0 {
177: 		inbounds = append(inbounds, C.Inbound{
178: 			Type:          inboundType,
179: 			BindAddress:   genAddr(bindAddress, port, allowLan),
180: 			IsFromPortCfg: true,
181: 		})
182: 	}
183: 	return inbounds
184: }
185: 
186: func reCreateListeners(inbounds []C.Inbound, tcpIn chan<- C.ConnContext, udpIn chan<- *inbound.PacketAdapter) {
187: 	recreateMux.Lock()
188: 	defer recreateMux.Unlock()
189: 	needClose, needCreate := getNeedCloseAndCreateInbound(getInbounds(), inbounds)
190: 	for _, inbound := range needClose {
191: 		closeListener(inbound)
192: 	}
193: 	for _, inbound := range needCreate {
194: 		createListener(inbound, tcpIn, udpIn)
195: 	}
196: }
197: 
198: func PatchTunnel(tunnels []config.Tunnel, tcpIn chan<- C.ConnContext, udpIn chan<- *inbound.PacketAdapter) {
199: 	tunnelMux.Lock()
200: 	defer tunnelMux.Unlock()
201: 
202: 	type addrProxy struct {
203: 		network string
204: 		addr    string
205: 		target  string
206: 		proxy   string
207: 	}
208: 
209: 	tcpOld := lo.Map(
210: 		lo.Keys(tunnelTCPListeners),
211: 		func(key string, _ int) addrProxy {
212: 			parts := strings.Split(key, "/")
213: 			return addrProxy{
214: 				network: "tcp",
215: 				addr:    parts[0],
216: 				target:  parts[1],
217: 				proxy:   parts[2],
218: 			}
219: 		},
220: 	)
221: 	udpOld := lo.Map(
222: 		lo.Keys(tunnelUDPListeners),
223: 		func(key string, _ int) addrProxy {
224: 			parts := strings.Split(key, "/")
225: 			return addrProxy{
226: 				network: "udp",
227: 				addr:    parts[0],
228: 				target:  parts[1],
229: 				proxy:   parts[2],
230: 			}
231: 		},
232: 	)
233: 	oldElm := lo.Union(tcpOld, udpOld)
234: 
235: 	newElm := lo.FlatMap(
236: 		tunnels,
237: 		func(tunnel config.Tunnel, _ int) []addrProxy {
238: 			return lo.Map(
239: 				tunnel.Network,
240: 				func(network string, _ int) addrProxy {
241: 					return addrProxy{
242: 						network: network,
243: 						addr:    tunnel.Address,
244: 						target:  tunnel.Target,
245: 						proxy:   tunnel.Proxy,
246: 					}
247: 				},
248: 			)
249: 		},
250: 	)
251: 
252: 	needClose, needCreate := lo.Difference(oldElm, newElm)
253: 
254: 	for _, elm := range needClose {
255: 		key := fmt.Sprintf("%s/%s/%s", elm.addr, elm.target, elm.proxy)
256: 		if elm.network == "tcp" {
257: 			tunnelTCPListeners[key].Close()
258: 			delete(tunnelTCPListeners, key)
259: 		} else {
260: 			tunnelUDPListeners[key].Close()
261: 			delete(tunnelUDPListeners, key)
262: 		}
263: 	}
264: 
265: 	for _, elm := range needCreate {
266: 		key := fmt.Sprintf("%s/%s/%s", elm.addr, elm.target, elm.proxy)
267: 		if elm.network == "tcp" {
268: 			l, err := tunnel.New(elm.addr, elm.target, elm.proxy, tcpIn)
269: 			if err != nil {
270: 				log.Errorln("Start tunnel %s error: %s", elm.target, err.Error())
271: 				continue
272: 			}
273: 			tunnelTCPListeners[key] = l
274: 			log.Infoln("Tunnel(tcp/%s) proxy %s listening at: %s", elm.target, elm.proxy, tunnelTCPListeners[key].Address())
275: 		} else {
276: 			l, err := tunnel.NewUDP(elm.addr, elm.target, elm.proxy, udpIn)
277: 			if err != nil {
278: 				log.Errorln("Start tunnel %s error: %s", elm.target, err.Error())
279: 				continue
280: 			}
281: 			tunnelUDPListeners[key] = l
282: 			log.Infoln("Tunnel(udp/%s) proxy %s listening at: %s", elm.target, elm.proxy, tunnelUDPListeners[key].Address())
283: 		}
284: 	}
285: }
286: 
287: func GetInbounds() []C.Inbound {
288: 	return lo.Filter(getInbounds(), func(inbound C.Inbound, idx int) bool {
289: 		return !inbound.IsFromPortCfg
290: 	})
291: }
292: 
293: // GetInbounds return the inbounds of proxy servers
294: func getInbounds() []C.Inbound {
295: 	var inbounds []C.Inbound
296: 	for inbound := range tcpListeners {
297: 		inbounds = append(inbounds, inbound)
298: 	}
299: 	for inbound := range udpListeners {
300: 		if _, ok := tcpListeners[inbound]; !ok {
301: 			inbounds = append(inbounds, inbound)
302: 		}
303: 	}
304: 	return inbounds
305: }
306: 
307: // GetPorts return the ports of proxy servers
308: func GetPorts() *Ports {
309: 	ports := &Ports{}
310: 	for _, inbound := range getInbounds() {
311: 		fillPort(inbound, ports)
312: 	}
313: 	return ports
314: }
315: 
316: func fillPort(inbound C.Inbound, ports *Ports) {
317: 	if inbound.IsFromPortCfg {
318: 		port := getPort(inbound.BindAddress)
319: 		switch inbound.Type {
320: 		case C.InboundTypeHTTP:
321: 			ports.Port = port
322: 		case C.InboundTypeSocks:
323: 			ports.SocksPort = port
324: 		case C.InboundTypeTproxy:
325: 			ports.TProxyPort = port
326: 		case C.InboundTypeRedir:
327: 			ports.RedirPort = port
328: 		case C.InboundTypeMixed:
329: 			ports.MixedPort = port
330: 		default:
331: 			// do nothing
332: 		}
333: 	}
334: }
335: 
336: func portIsZero(addr string) bool {
337: 	_, port, err := net.SplitHostPort(addr)
338: 	if port == "0" || port == "" || err != nil {
339: 		return true
340: 	}
341: 	return false
342: }
343: 
344: func genAddr(host string, port int, allowLan bool) string {
345: 	if allowLan {
346: 		if host == "*" {
347: 			return fmt.Sprintf(":%d", port)
348: 		}
349: 		return fmt.Sprintf("%s:%d", host, port)
350: 	}
351: 
352: 	return fmt.Sprintf("127.0.0.1:%d", port)
353: }
354: 
355: func getPort(addr string) int {
356: 	_, portStr, err := net.SplitHostPort(addr)
357: 	if err != nil {
358: 		return 0
359: 	}
360: 	port, err := strconv.Atoi(portStr)
361: 	if err != nil {
362: 		return 0
363: 	}
364: 	return port
365: }


./listener\auth\auth.go
1: package auth
2: 
3: import (
4: 	"github.com/Dreamacro/clash/component/auth"
5: )
6: 
7: var authenticator auth.Authenticator
8: 
9: func Authenticator() auth.Authenticator {
10: 	return authenticator
11: }
12: 
13: func SetAuthenticator(au auth.Authenticator) {
14: 	authenticator = au
15: }


./listener\http\client.go
1: package http
2: 
3: import (
4: 	"context"
5: 	"errors"
6: 	"net"
7: 	"net/http"
8: 	"time"
9: 
10: 	"github.com/Dreamacro/clash/adapter/inbound"
11: 	C "github.com/Dreamacro/clash/constant"
12: 	"github.com/Dreamacro/clash/transport/socks5"
13: )
14: 
15: func newClient(source net.Addr, originTarget net.Addr, in chan<- C.ConnContext) *http.Client {
16: 	return &http.Client{
17: 		Transport: &http.Transport{
18: 			// from http.DefaultTransport
19: 			MaxIdleConns:          100,
20: 			IdleConnTimeout:       90 * time.Second,
21: 			TLSHandshakeTimeout:   10 * time.Second,
22: 			ExpectContinueTimeout: 1 * time.Second,
23: 			DialContext: func(context context.Context, network, address string) (net.Conn, error) {
24: 				if network != "tcp" && network != "tcp4" && network != "tcp6" {
25: 					return nil, errors.New("unsupported network " + network)
26: 				}
27: 
28: 				dstAddr := socks5.ParseAddr(address)
29: 				if dstAddr == nil {
30: 					return nil, socks5.ErrAddressNotSupported
31: 				}
32: 
33: 				left, right := net.Pipe()
34: 
35: 				in <- inbound.NewHTTP(dstAddr, source, originTarget, right)
36: 
37: 				return left, nil
38: 			},
39: 		},
40: 		CheckRedirect: func(req *http.Request, via []*http.Request) error {
41: 			return http.ErrUseLastResponse
42: 		},
43: 	}
44: }


./listener\http\hack.go
1: package http
2: 
3: import (
4: 	"bufio"
5: 	"net/http"
6: 	_ "unsafe"
7: )
8: 
9: //go:linkname ReadRequest net/http.readRequest
10: func ReadRequest(b *bufio.Reader) (req *http.Request, err error)


./listener\http\proxy.go
1: package http
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 	"net/http"
7: 	"strings"
8: 
9: 	"github.com/Dreamacro/clash/adapter/inbound"
10: 	"github.com/Dreamacro/clash/common/cache"
11: 	N "github.com/Dreamacro/clash/common/net"
12: 	C "github.com/Dreamacro/clash/constant"
13: 	authStore "github.com/Dreamacro/clash/listener/auth"
14: 	"github.com/Dreamacro/clash/log"
15: )
16: 
17: func HandleConn(c net.Conn, in chan<- C.ConnContext, cache *cache.LruCache) {
18: 	client := newClient(c.RemoteAddr(), c.LocalAddr(), in)
19: 	defer client.CloseIdleConnections()
20: 
21: 	conn := N.NewBufferedConn(c)
22: 
23: 	keepAlive := true
24: 	trusted := cache == nil // disable authenticate if cache is nil
25: 
26: 	for keepAlive {
27: 		request, err := ReadRequest(conn.Reader())
28: 		if err != nil {
29: 			break
30: 		}
31: 
32: 		request.RemoteAddr = conn.RemoteAddr().String()
33: 
34: 		keepAlive = strings.TrimSpace(strings.ToLower(request.Header.Get("Proxy-Connection"))) == "keep-alive"
35: 
36: 		var resp *http.Response
37: 
38: 		if !trusted {
39: 			resp = authenticate(request, cache)
40: 
41: 			trusted = resp == nil
42: 		}
43: 
44: 		if trusted {
45: 			if request.Method == http.MethodConnect {
46: 				// Manual writing to support CONNECT for http 1.0 (workaround for uplay client)
47: 				if _, err = fmt.Fprintf(conn, "HTTP/%d.%d %03d %s\r\n\r\n", request.ProtoMajor, request.ProtoMinor, http.StatusOK, "Connection established"); err != nil {
48: 					break // close connection
49: 				}
50: 
51: 				in <- inbound.NewHTTPS(request, conn)
52: 
53: 				return // hijack connection
54: 			}
55: 
56: 			host := request.Header.Get("Host")
57: 			if host != "" {
58: 				request.Host = host
59: 			}
60: 
61: 			request.RequestURI = ""
62: 
63: 			if isUpgradeRequest(request) {
64: 				handleUpgrade(conn, request, in)
65: 
66: 				return // hijack connection
67: 			}
68: 
69: 			removeHopByHopHeaders(request.Header)
70: 			removeExtraHTTPHostPort(request)
71: 
72: 			if request.URL.Scheme == "" || request.URL.Host == "" {
73: 				resp = responseWith(request, http.StatusBadRequest)
74: 			} else {
75: 				resp, err = client.Do(request)
76: 				if err != nil {
77: 					resp = responseWith(request, http.StatusBadGateway)
78: 				}
79: 			}
80: 
81: 			removeHopByHopHeaders(resp.Header)
82: 		}
83: 
84: 		if keepAlive {
85: 			resp.Header.Set("Proxy-Connection", "keep-alive")
86: 			resp.Header.Set("Connection", "keep-alive")
87: 			resp.Header.Set("Keep-Alive", "timeout=4")
88: 		}
89: 
90: 		resp.Close = !keepAlive
91: 
92: 		err = resp.Write(conn)
93: 		if err != nil {
94: 			break // close connection
95: 		}
96: 	}
97: 
98: 	conn.Close()
99: }
100: 
101: func authenticate(request *http.Request, cache *cache.LruCache) *http.Response {
102: 	authenticator := authStore.Authenticator()
103: 	if authenticator != nil {
104: 		credential := parseBasicProxyAuthorization(request)
105: 		if credential == "" {
106: 			resp := responseWith(request, http.StatusProxyAuthRequired)
107: 			resp.Header.Set("Proxy-Authenticate", "Basic")
108: 			return resp
109: 		}
110: 
111: 		authed, exist := cache.Get(credential)
112: 		if !exist {
113: 			user, pass, err := decodeBasicProxyAuthorization(credential)
114: 			authed = err == nil && authenticator.Verify(user, pass)
115: 			cache.Set(credential, authed)
116: 		}
117: 		if !authed.(bool) {
118: 			log.Infoln("Auth failed from %s", request.RemoteAddr)
119: 
120: 			return responseWith(request, http.StatusForbidden)
121: 		}
122: 	}
123: 
124: 	return nil
125: }
126: 
127: func responseWith(request *http.Request, statusCode int) *http.Response {
128: 	return &http.Response{
129: 		StatusCode: statusCode,
130: 		Status:     http.StatusText(statusCode),
131: 		Proto:      request.Proto,
132: 		ProtoMajor: request.ProtoMajor,
133: 		ProtoMinor: request.ProtoMinor,
134: 		Header:     http.Header{},
135: 	}
136: }


./listener\http\server.go
1: package http
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/common/cache"
7: 	C "github.com/Dreamacro/clash/constant"
8: )
9: 
10: type Listener struct {
11: 	listener net.Listener
12: 	addr     string
13: 	closed   bool
14: }
15: 
16: // RawAddress implements C.Listener
17: func (l *Listener) RawAddress() string {
18: 	return l.addr
19: }
20: 
21: // Address implements C.Listener
22: func (l *Listener) Address() string {
23: 	return l.listener.Addr().String()
24: }
25: 
26: // Close implements C.Listener
27: func (l *Listener) Close() error {
28: 	l.closed = true
29: 	return l.listener.Close()
30: }
31: 
32: func New(addr string, in chan<- C.ConnContext) (C.Listener, error) {
33: 	return NewWithAuthenticate(addr, in, true)
34: }
35: 
36: func NewWithAuthenticate(addr string, in chan<- C.ConnContext, authenticate bool) (C.Listener, error) {
37: 	l, err := net.Listen("tcp", addr)
38: 	if err != nil {
39: 		return nil, err
40: 	}
41: 
42: 	var c *cache.LruCache
43: 	if authenticate {
44: 		c = cache.New(cache.WithAge(30))
45: 	}
46: 
47: 	hl := &Listener{
48: 		listener: l,
49: 		addr:     addr,
50: 	}
51: 	go func() {
52: 		for {
53: 			conn, err := hl.listener.Accept()
54: 			if err != nil {
55: 				if hl.closed {
56: 					break
57: 				}
58: 				continue
59: 			}
60: 			go HandleConn(conn, in, c)
61: 		}
62: 	}()
63: 
64: 	return hl, nil
65: }


./listener\http\upgrade.go
1: package http
2: 
3: import (
4: 	"net"
5: 	"net/http"
6: 	"strings"
7: 
8: 	"github.com/Dreamacro/clash/adapter/inbound"
9: 	N "github.com/Dreamacro/clash/common/net"
10: 	C "github.com/Dreamacro/clash/constant"
11: 	"github.com/Dreamacro/clash/transport/socks5"
12: )
13: 
14: func isUpgradeRequest(req *http.Request) bool {
15: 	for _, header := range req.Header["Connection"] {
16: 		for _, elm := range strings.Split(header, ",") {
17: 			if strings.EqualFold(strings.TrimSpace(elm), "Upgrade") {
18: 				return true
19: 			}
20: 		}
21: 	}
22: 
23: 	return false
24: }
25: 
26: func handleUpgrade(conn net.Conn, request *http.Request, in chan<- C.ConnContext) {
27: 	defer conn.Close()
28: 
29: 	removeProxyHeaders(request.Header)
30: 	removeExtraHTTPHostPort(request)
31: 
32: 	address := request.Host
33: 	if _, _, err := net.SplitHostPort(address); err != nil {
34: 		address = net.JoinHostPort(address, "80")
35: 	}
36: 
37: 	dstAddr := socks5.ParseAddr(address)
38: 	if dstAddr == nil {
39: 		return
40: 	}
41: 
42: 	left, right := net.Pipe()
43: 
44: 	in <- inbound.NewHTTP(dstAddr, conn.RemoteAddr(), conn.LocalAddr(), right)
45: 
46: 	bufferedLeft := N.NewBufferedConn(left)
47: 	defer bufferedLeft.Close()
48: 
49: 	err := request.Write(bufferedLeft)
50: 	if err != nil {
51: 		return
52: 	}
53: 
54: 	resp, err := http.ReadResponse(bufferedLeft.Reader(), request)
55: 	if err != nil {
56: 		return
57: 	}
58: 
59: 	removeProxyHeaders(resp.Header)
60: 
61: 	err = resp.Write(conn)
62: 	if err != nil {
63: 		return
64: 	}
65: 
66: 	if resp.StatusCode == http.StatusSwitchingProtocols {
67: 		N.Relay(bufferedLeft, conn)
68: 	}
69: }


./listener\http\utils.go
1: package http
2: 
3: import (
4: 	"encoding/base64"
5: 	"errors"
6: 	"net"
7: 	"net/http"
8: 	"strings"
9: )
10: 
11: // removeHopByHopHeaders remove Proxy-* headers
12: func removeProxyHeaders(header http.Header) {
13: 	header.Del("Proxy-Connection")
14: 	header.Del("Proxy-Authenticate")
15: 	header.Del("Proxy-Authorization")
16: }
17: 
18: // removeHopByHopHeaders remove hop-by-hop header
19: func removeHopByHopHeaders(header http.Header) {
20: 	// Strip hop-by-hop header based on RFC:
21: 	// http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1
22: 	// https://www.mnot.net/blog/2011/07/11/what_proxies_must_do
23: 
24: 	removeProxyHeaders(header)
25: 
26: 	header.Del("TE")
27: 	header.Del("Trailers")
28: 	header.Del("Transfer-Encoding")
29: 	header.Del("Upgrade")
30: 
31: 	connections := header.Get("Connection")
32: 	header.Del("Connection")
33: 	if len(connections) == 0 {
34: 		return
35: 	}
36: 	for _, h := range strings.Split(connections, ",") {
37: 		header.Del(strings.TrimSpace(h))
38: 	}
39: }
40: 
41: // removeExtraHTTPHostPort remove extra host port (example.com:80 --> example.com)
42: // It resolves the behavior of some HTTP servers that do not handle host:80 (e.g. baidu.com)
43: func removeExtraHTTPHostPort(req *http.Request) {
44: 	host := req.Host
45: 	if host == "" {
46: 		host = req.URL.Host
47: 	}
48: 
49: 	if pHost, port, err := net.SplitHostPort(host); err == nil && port == "80" {
50: 		host = pHost
51: 	}
52: 
53: 	req.Host = host
54: 	req.URL.Host = host
55: }
56: 
57: // parseBasicProxyAuthorization parse header Proxy-Authorization and return base64-encoded credential
58: func parseBasicProxyAuthorization(request *http.Request) string {
59: 	value := request.Header.Get("Proxy-Authorization")
60: 	if !strings.HasPrefix(value, "Basic ") {
61: 		return ""
62: 	}
63: 
64: 	return value[6:] // value[len("Basic "):]
65: }
66: 
67: // decodeBasicProxyAuthorization decode base64-encoded credential
68: func decodeBasicProxyAuthorization(credential string) (string, string, error) {
69: 	plain, err := base64.StdEncoding.DecodeString(credential)
70: 	if err != nil {
71: 		return "", "", err
72: 	}
73: 
74: 	user, pass, found := strings.Cut(string(plain), ":")
75: 	if !found {
76: 		return "", "", errors.New("invalid login")
77: 	}
78: 
79: 	return user, pass, nil
80: }


./listener\mixed\mixed.go
1: package mixed
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/common/cache"
7: 	N "github.com/Dreamacro/clash/common/net"
8: 	C "github.com/Dreamacro/clash/constant"
9: 	"github.com/Dreamacro/clash/listener/http"
10: 	"github.com/Dreamacro/clash/listener/socks"
11: 	"github.com/Dreamacro/clash/transport/socks4"
12: 	"github.com/Dreamacro/clash/transport/socks5"
13: )
14: 
15: type Listener struct {
16: 	listener net.Listener
17: 	addr     string
18: 	cache    *cache.LruCache
19: 	closed   bool
20: }
21: 
22: // RawAddress implements C.Listener
23: func (l *Listener) RawAddress() string {
24: 	return l.addr
25: }
26: 
27: // Address implements C.Listener
28: func (l *Listener) Address() string {
29: 	return l.listener.Addr().String()
30: }
31: 
32: // Close implements C.Listener
33: func (l *Listener) Close() error {
34: 	l.closed = true
35: 	return l.listener.Close()
36: }
37: 
38: func New(addr string, in chan<- C.ConnContext) (C.Listener, error) {
39: 	l, err := net.Listen("tcp", addr)
40: 	if err != nil {
41: 		return nil, err
42: 	}
43: 
44: 	ml := &Listener{
45: 		listener: l,
46: 		addr:     addr,
47: 		cache:    cache.New(cache.WithAge(30)),
48: 	}
49: 	go func() {
50: 		for {
51: 			c, err := ml.listener.Accept()
52: 			if err != nil {
53: 				if ml.closed {
54: 					break
55: 				}
56: 				continue
57: 			}
58: 			go handleConn(c, in, ml.cache)
59: 		}
60: 	}()
61: 
62: 	return ml, nil
63: }
64: 
65: func handleConn(conn net.Conn, in chan<- C.ConnContext, cache *cache.LruCache) {
66: 	conn.(*net.TCPConn).SetKeepAlive(true)
67: 
68: 	bufConn := N.NewBufferedConn(conn)
69: 	head, err := bufConn.Peek(1)
70: 	if err != nil {
71: 		return
72: 	}
73: 
74: 	switch head[0] {
75: 	case socks4.Version:
76: 		socks.HandleSocks4(bufConn, in)
77: 	case socks5.Version:
78: 		socks.HandleSocks5(bufConn, in)
79: 	default:
80: 		http.HandleConn(bufConn, in, cache)
81: 	}
82: }


./listener\redir\tcp.go
1: package redir
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/adapter/inbound"
7: 	C "github.com/Dreamacro/clash/constant"
8: )
9: 
10: type Listener struct {
11: 	listener net.Listener
12: 	addr     string
13: 	closed   bool
14: }
15: 
16: // RawAddress implements C.Listener
17: func (l *Listener) RawAddress() string {
18: 	return l.addr
19: }
20: 
21: // Address implements C.Listener
22: func (l *Listener) Address() string {
23: 	return l.listener.Addr().String()
24: }
25: 
26: // Close implements C.Listener
27: func (l *Listener) Close() error {
28: 	l.closed = true
29: 	return l.listener.Close()
30: }
31: 
32: func New(addr string, in chan<- C.ConnContext) (C.Listener, error) {
33: 	l, err := net.Listen("tcp", addr)
34: 	if err != nil {
35: 		return nil, err
36: 	}
37: 	rl := &Listener{
38: 		listener: l,
39: 		addr:     addr,
40: 	}
41: 
42: 	go func() {
43: 		for {
44: 			c, err := l.Accept()
45: 			if err != nil {
46: 				if rl.closed {
47: 					break
48: 				}
49: 				continue
50: 			}
51: 			go handleRedir(c, in)
52: 		}
53: 	}()
54: 
55: 	return rl, nil
56: }
57: 
58: func handleRedir(conn net.Conn, in chan<- C.ConnContext) {
59: 	target, err := parserPacket(conn)
60: 	if err != nil {
61: 		conn.Close()
62: 		return
63: 	}
64: 	conn.(*net.TCPConn).SetKeepAlive(true)
65: 	in <- inbound.NewSocket(target, conn, C.REDIR)
66: }


./listener\redir\tcp_darwin.go
1: package redir
2: 
3: import (
4: 	"net"
5: 	"syscall"
6: 	"unsafe"
7: 
8: 	"github.com/Dreamacro/clash/transport/socks5"
9: )
10: 
11: func parserPacket(c net.Conn) (socks5.Addr, error) {
12: 	const (
13: 		PfInout     = 0
14: 		PfIn        = 1
15: 		PfOut       = 2
16: 		IOCOut      = 0x40000000
17: 		IOCIn       = 0x80000000
18: 		IOCInOut    = IOCIn | IOCOut
19: 		IOCPARMMask = 0x1FFF
20: 		LEN         = 4*16 + 4*4 + 4*1
21: 		// #define	_IOC(inout,group,num,len) (inout | ((len & IOCPARMMask) << 16) | ((group) << 8) | (num))
22: 		// #define	_IOWR(g,n,t)	_IOC(IOCInOut,	(g), (n), sizeof(t))
23: 		// #define DIOCNATLOOK		_IOWR('D', 23, struct pfioc_natlook)
24: 		DIOCNATLOOK = IOCInOut | ((LEN & IOCPARMMask) << 16) | ('D' << 8) | 23
25: 	)
26: 
27: 	fd, err := syscall.Open("/dev/pf", 0, syscall.O_RDONLY)
28: 	if err != nil {
29: 		return nil, err
30: 	}
31: 	defer syscall.Close(fd)
32: 
33: 	nl := struct { // struct pfioc_natlook
34: 		saddr, daddr, rsaddr, rdaddr       [16]byte
35: 		sxport, dxport, rsxport, rdxport   [4]byte
36: 		af, proto, protoVariant, direction uint8
37: 	}{
38: 		af:        syscall.AF_INET,
39: 		proto:     syscall.IPPROTO_TCP,
40: 		direction: PfOut,
41: 	}
42: 	saddr := c.RemoteAddr().(*net.TCPAddr)
43: 	daddr := c.LocalAddr().(*net.TCPAddr)
44: 	copy(nl.saddr[:], saddr.IP)
45: 	copy(nl.daddr[:], daddr.IP)
46: 	nl.sxport[0], nl.sxport[1] = byte(saddr.Port>>8), byte(saddr.Port)
47: 	nl.dxport[0], nl.dxport[1] = byte(daddr.Port>>8), byte(daddr.Port)
48: 
49: 	if _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, uintptr(fd), DIOCNATLOOK, uintptr(unsafe.Pointer(&nl))); errno != 0 {
50: 		return nil, errno
51: 	}
52: 
53: 	addr := make([]byte, 1+net.IPv4len+2)
54: 	addr[0] = socks5.AtypIPv4
55: 	copy(addr[1:1+net.IPv4len], nl.rdaddr[:4])
56: 	copy(addr[1+net.IPv4len:], nl.rdxport[:2])
57: 	return addr, nil
58: }


./listener\redir\tcp_freebsd.go
1: package redir
2: 
3: import (
4: 	"encoding/binary"
5: 	"errors"
6: 	"net"
7: 	"net/netip"
8: 	"syscall"
9: 	"unsafe"
10: 
11: 	"github.com/Dreamacro/clash/transport/socks5"
12: 
13: 	"golang.org/x/sys/unix"
14: )
15: 
16: const (
17: 	SO_ORIGINAL_DST      = 80 // from linux/include/uapi/linux/netfilter_ipv4.h
18: 	IP6T_SO_ORIGINAL_DST = 80 // from linux/include/uapi/linux/netfilter_ipv6/ip6_tables.h
19: )
20: 
21: func parserPacket(conn net.Conn) (socks5.Addr, error) {
22: 	c, ok := conn.(*net.TCPConn)
23: 	if !ok {
24: 		return nil, errors.New("only work with TCP connection")
25: 	}
26: 
27: 	rc, err := c.SyscallConn()
28: 	if err != nil {
29: 		return nil, err
30: 	}
31: 
32: 	var addr netip.AddrPort
33: 
34: 	rc.Control(func(fd uintptr) {
35: 		if ip4 := c.LocalAddr().(*net.TCPAddr).IP.To4(); ip4 != nil {
36: 			addr, err = getorigdst(fd)
37: 		} else {
38: 			addr, err = getorigdst6(fd)
39: 		}
40: 	})
41: 
42: 	return socks5.AddrFromStdAddrPort(addr), err
43: }
44: 
45: // Call getorigdst() from linux/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
46: func getorigdst(fd uintptr) (netip.AddrPort, error) {
47: 	addr := unix.RawSockaddrInet4{}
48: 	size := uint32(unsafe.Sizeof(addr))
49: 	_, _, err := syscall.Syscall6(syscall.SYS_GETSOCKOPT, fd, syscall.IPPROTO_IP, SO_ORIGINAL_DST, uintptr(unsafe.Pointer(&addr)), uintptr(unsafe.Pointer(&size)), 0)
50: 	if err != 0 {
51: 		return netip.AddrPort{}, err
52: 	}
53: 	port := binary.BigEndian.Uint16((*(*[2]byte)(unsafe.Pointer(&addr.Port)))[:])
54: 	return netip.AddrPortFrom(netip.AddrFrom4(addr.Addr), port), nil
55: }
56: 
57: func getorigdst6(fd uintptr) (netip.AddrPort, error) {
58: 	addr := unix.RawSockaddrInet6{}
59: 	size := uint32(unsafe.Sizeof(addr))
60: 	_, _, err := syscall.Syscall6(syscall.SYS_GETSOCKOPT, fd, syscall.IPPROTO_IPV6, IP6T_SO_ORIGINAL_DST, uintptr(unsafe.Pointer(&addr)), uintptr(unsafe.Pointer(&size)), 0)
61: 	if err != 0 {
62: 		return netip.AddrPort{}, err
63: 	}
64: 	port := binary.BigEndian.Uint16((*(*[2]byte)(unsafe.Pointer(&addr.Port)))[:])
65: 	return netip.AddrPortFrom(netip.AddrFrom16(addr.Addr), port), nil
66: }


./listener\redir\tcp_linux.go
1: package redir
2: 
3: import (
4: 	"encoding/binary"
5: 	"errors"
6: 	"net"
7: 	"net/netip"
8: 	"syscall"
9: 	"unsafe"
10: 
11: 	"github.com/Dreamacro/clash/transport/socks5"
12: 
13: 	"golang.org/x/sys/unix"
14: )
15: 
16: const (
17: 	SO_ORIGINAL_DST      = 80 // from linux/include/uapi/linux/netfilter_ipv4.h
18: 	IP6T_SO_ORIGINAL_DST = 80 // from linux/include/uapi/linux/netfilter_ipv6/ip6_tables.h
19: )
20: 
21: func parserPacket(conn net.Conn) (socks5.Addr, error) {
22: 	c, ok := conn.(*net.TCPConn)
23: 	if !ok {
24: 		return nil, errors.New("only work with TCP connection")
25: 	}
26: 
27: 	rc, err := c.SyscallConn()
28: 	if err != nil {
29: 		return nil, err
30: 	}
31: 
32: 	var addr netip.AddrPort
33: 
34: 	rc.Control(func(fd uintptr) {
35: 		if ip4 := c.LocalAddr().(*net.TCPAddr).IP.To4(); ip4 != nil {
36: 			addr, err = getorigdst(fd)
37: 		} else {
38: 			addr, err = getorigdst6(fd)
39: 		}
40: 	})
41: 
42: 	return socks5.AddrFromStdAddrPort(addr), err
43: }
44: 
45: // Call getorigdst() from linux/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
46: func getorigdst(fd uintptr) (netip.AddrPort, error) {
47: 	addr := unix.RawSockaddrInet4{}
48: 	size := uint32(unsafe.Sizeof(addr))
49: 	if err := socketcall(GETSOCKOPT, fd, syscall.IPPROTO_IP, SO_ORIGINAL_DST, uintptr(unsafe.Pointer(&addr)), uintptr(unsafe.Pointer(&size)), 0); err != nil {
50: 		return netip.AddrPort{}, err
51: 	}
52: 	port := binary.BigEndian.Uint16((*(*[2]byte)(unsafe.Pointer(&addr.Port)))[:])
53: 	return netip.AddrPortFrom(netip.AddrFrom4(addr.Addr), port), nil
54: }
55: 
56: func getorigdst6(fd uintptr) (netip.AddrPort, error) {
57: 	addr := unix.RawSockaddrInet6{}
58: 	size := uint32(unsafe.Sizeof(addr))
59: 	if err := socketcall(GETSOCKOPT, fd, syscall.IPPROTO_IPV6, IP6T_SO_ORIGINAL_DST, uintptr(unsafe.Pointer(&addr)), uintptr(unsafe.Pointer(&size)), 0); err != nil {
60: 		return netip.AddrPort{}, err
61: 	}
62: 	port := binary.BigEndian.Uint16((*(*[2]byte)(unsafe.Pointer(&addr.Port)))[:])
63: 	return netip.AddrPortFrom(netip.AddrFrom16(addr.Addr), port), nil
64: }


./listener\redir\tcp_linux_386.go
1: package redir
2: 
3: import (
4: 	"syscall"
5: 	"unsafe"
6: )
7: 
8: const GETSOCKOPT = 15 // https://golang.org/src/syscall/syscall_linux_386.go#L183
9: 
10: func socketcall(call, a0, a1, a2, a3, a4, a5 uintptr) error {
11: 	var a [6]uintptr
12: 	a[0], a[1], a[2], a[3], a[4], a[5] = a0, a1, a2, a3, a4, a5
13: 	if _, _, errno := syscall.Syscall6(syscall.SYS_SOCKETCALL, call, uintptr(unsafe.Pointer(&a)), 0, 0, 0, 0); errno != 0 {
14: 		return errno
15: 	}
16: 	return nil
17: }


./listener\redir\tcp_linux_other.go
1: //go:build linux && !386
2: 
3: package redir
4: 
5: import "syscall"
6: 
7: const GETSOCKOPT = syscall.SYS_GETSOCKOPT
8: 
9: func socketcall(call, a0, a1, a2, a3, a4, a5 uintptr) error {
10: 	if _, _, errno := syscall.Syscall6(call, a0, a1, a2, a3, a4, a5); errno != 0 {
11: 		return errno
12: 	}
13: 	return nil
14: }


./listener\redir\tcp_other.go
1: //go:build !darwin && !linux && !freebsd
2: 
3: package redir
4: 
5: import (
6: 	"errors"
7: 	"net"
8: 
9: 	"github.com/Dreamacro/clash/transport/socks5"
10: )
11: 
12: func parserPacket(conn net.Conn) (socks5.Addr, error) {
13: 	return nil, errors.New("system not support yet")
14: }


./listener\socks\tcp.go
1: package socks
2: 
3: import (
4: 	"io"
5: 	"net"
6: 
7: 	"github.com/Dreamacro/clash/adapter/inbound"
8: 	N "github.com/Dreamacro/clash/common/net"
9: 	C "github.com/Dreamacro/clash/constant"
10: 	authStore "github.com/Dreamacro/clash/listener/auth"
11: 	"github.com/Dreamacro/clash/transport/socks4"
12: 	"github.com/Dreamacro/clash/transport/socks5"
13: )
14: 
15: type Listener struct {
16: 	listener net.Listener
17: 	addr     string
18: 	closed   bool
19: }
20: 
21: // RawAddress implements C.Listener
22: func (l *Listener) RawAddress() string {
23: 	return l.addr
24: }
25: 
26: // Address implements C.Listener
27: func (l *Listener) Address() string {
28: 	return l.listener.Addr().String()
29: }
30: 
31: // Close implements C.Listener
32: func (l *Listener) Close() error {
33: 	l.closed = true
34: 	return l.listener.Close()
35: }
36: 
37: func New(addr string, in chan<- C.ConnContext) (C.Listener, error) {
38: 	l, err := net.Listen("tcp", addr)
39: 	if err != nil {
40: 		return nil, err
41: 	}
42: 
43: 	sl := &Listener{
44: 		listener: l,
45: 		addr:     addr,
46: 	}
47: 	go func() {
48: 		for {
49: 			c, err := l.Accept()
50: 			if err != nil {
51: 				if sl.closed {
52: 					break
53: 				}
54: 				continue
55: 			}
56: 			go handleSocks(c, in)
57: 		}
58: 	}()
59: 
60: 	return sl, nil
61: }
62: 
63: func handleSocks(conn net.Conn, in chan<- C.ConnContext) {
64: 	conn.(*net.TCPConn).SetKeepAlive(true)
65: 	bufConn := N.NewBufferedConn(conn)
66: 	head, err := bufConn.Peek(1)
67: 	if err != nil {
68: 		conn.Close()
69: 		return
70: 	}
71: 
72: 	switch head[0] {
73: 	case socks4.Version:
74: 		HandleSocks4(bufConn, in)
75: 	case socks5.Version:
76: 		HandleSocks5(bufConn, in)
77: 	default:
78: 		conn.Close()
79: 	}
80: }
81: 
82: func HandleSocks4(conn net.Conn, in chan<- C.ConnContext) {
83: 	addr, _, err := socks4.ServerHandshake(conn, authStore.Authenticator())
84: 	if err != nil {
85: 		conn.Close()
86: 		return
87: 	}
88: 	in <- inbound.NewSocket(socks5.ParseAddr(addr), conn, C.SOCKS4)
89: }
90: 
91: func HandleSocks5(conn net.Conn, in chan<- C.ConnContext) {
92: 	target, command, err := socks5.ServerHandshake(conn, authStore.Authenticator())
93: 	if err != nil {
94: 		conn.Close()
95: 		return
96: 	}
97: 	if command == socks5.CmdUDPAssociate {
98: 		defer conn.Close()
99: 		io.Copy(io.Discard, conn)
100: 		return
101: 	}
102: 	in <- inbound.NewSocket(target, conn, C.SOCKS5)
103: }


./listener\socks\udp.go
1: package socks
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/adapter/inbound"
7: 	"github.com/Dreamacro/clash/common/pool"
8: 	"github.com/Dreamacro/clash/common/sockopt"
9: 	C "github.com/Dreamacro/clash/constant"
10: 	"github.com/Dreamacro/clash/log"
11: 	"github.com/Dreamacro/clash/transport/socks5"
12: )
13: 
14: type UDPListener struct {
15: 	packetConn net.PacketConn
16: 	addr       string
17: 	closed     bool
18: }
19: 
20: // RawAddress implements C.Listener
21: func (l *UDPListener) RawAddress() string {
22: 	return l.addr
23: }
24: 
25: // Address implements C.Listener
26: func (l *UDPListener) Address() string {
27: 	return l.packetConn.LocalAddr().String()
28: }
29: 
30: // Close implements C.Listener
31: func (l *UDPListener) Close() error {
32: 	l.closed = true
33: 	return l.packetConn.Close()
34: }
35: 
36: func NewUDP(addr string, in chan<- *inbound.PacketAdapter) (C.Listener, error) {
37: 	l, err := net.ListenPacket("udp", addr)
38: 	if err != nil {
39: 		return nil, err
40: 	}
41: 
42: 	if err := sockopt.UDPReuseaddr(l.(*net.UDPConn)); err != nil {
43: 		log.Warnln("Failed to Reuse UDP Address: %s", err)
44: 	}
45: 
46: 	sl := &UDPListener{
47: 		packetConn: l,
48: 		addr:       addr,
49: 	}
50: 	go func() {
51: 		for {
52: 			buf := pool.Get(pool.UDPBufferSize)
53: 			n, remoteAddr, err := l.ReadFrom(buf)
54: 			if err != nil {
55: 				pool.Put(buf)
56: 				if sl.closed {
57: 					break
58: 				}
59: 				continue
60: 			}
61: 			handleSocksUDP(l, in, buf[:n], remoteAddr)
62: 		}
63: 	}()
64: 
65: 	return sl, nil
66: }
67: 
68: func handleSocksUDP(pc net.PacketConn, in chan<- *inbound.PacketAdapter, buf []byte, addr net.Addr) {
69: 	target, payload, err := socks5.DecodeUDPPacket(buf)
70: 	if err != nil {
71: 		// Unresolved UDP packet, return buffer to the pool
72: 		pool.Put(buf)
73: 		return
74: 	}
75: 	packet := &packet{
76: 		pc:      pc,
77: 		rAddr:   addr,
78: 		payload: payload,
79: 		bufRef:  buf,
80: 	}
81: 	select {
82: 	case in <- inbound.NewPacket(target, pc.LocalAddr(), packet, C.SOCKS5):
83: 	default:
84: 	}
85: }


./listener\socks\utils.go
1: package socks
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/common/pool"
7: 	"github.com/Dreamacro/clash/transport/socks5"
8: )
9: 
10: type packet struct {
11: 	pc      net.PacketConn
12: 	rAddr   net.Addr
13: 	payload []byte
14: 	bufRef  []byte
15: }
16: 
17: func (c *packet) Data() []byte {
18: 	return c.payload
19: }
20: 
21: // WriteBack write UDP packet with source(ip, port) = `addr`
22: func (c *packet) WriteBack(b []byte, addr net.Addr) (n int, err error) {
23: 	packet, err := socks5.EncodeUDPPacket(socks5.ParseAddrToSocksAddr(addr), b)
24: 	if err != nil {
25: 		return
26: 	}
27: 	return c.pc.WriteTo(packet, c.rAddr)
28: }
29: 
30: // LocalAddr returns the source IP/Port of UDP Packet
31: func (c *packet) LocalAddr() net.Addr {
32: 	return c.rAddr
33: }
34: 
35: func (c *packet) Drop() {
36: 	pool.Put(c.bufRef)
37: }


./listener\tproxy\packet.go
1: package tproxy
2: 
3: import (
4: 	"net"
5: 	"net/netip"
6: 
7: 	"github.com/Dreamacro/clash/common/pool"
8: )
9: 
10: type packet struct {
11: 	lAddr netip.AddrPort
12: 	buf   []byte
13: }
14: 
15: func (c *packet) Data() []byte {
16: 	return c.buf
17: }
18: 
19: // WriteBack opens a new socket binding `addr` to write UDP packet back
20: func (c *packet) WriteBack(b []byte, addr net.Addr) (n int, err error) {
21: 	tc, err := dialUDP("udp", addr.(*net.UDPAddr).AddrPort(), c.lAddr)
22: 	if err != nil {
23: 		n = 0
24: 		return
25: 	}
26: 	n, err = tc.Write(b)
27: 	tc.Close()
28: 	return
29: }
30: 
31: // LocalAddr returns the source IP/Port of UDP Packet
32: func (c *packet) LocalAddr() net.Addr {
33: 	return &net.UDPAddr{IP: c.lAddr.Addr().AsSlice(), Port: int(c.lAddr.Port()), Zone: c.lAddr.Addr().Zone()}
34: }
35: 
36: func (c *packet) Drop() {
37: 	pool.Put(c.buf)
38: }


./listener\tproxy\setsockopt_linux.go
1: //go:build linux
2: 
3: package tproxy
4: 
5: import (
6: 	"net"
7: 	"syscall"
8: )
9: 
10: func setsockopt(rc syscall.RawConn, addr string) error {
11: 	isIPv6 := true
12: 	host, _, err := net.SplitHostPort(addr)
13: 	if err != nil {
14: 		return err
15: 	}
16: 	ip := net.ParseIP(host)
17: 	if ip != nil && ip.To4() != nil {
18: 		isIPv6 = false
19: 	}
20: 
21: 	rc.Control(func(fd uintptr) {
22: 		err = syscall.SetsockoptInt(int(fd), syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)
23: 
24: 		if err == nil {
25: 			err = syscall.SetsockoptInt(int(fd), syscall.SOL_IP, syscall.IP_TRANSPARENT, 1)
26: 		}
27: 		if err == nil && isIPv6 {
28: 			err = syscall.SetsockoptInt(int(fd), syscall.SOL_IPV6, IPV6_TRANSPARENT, 1)
29: 		}
30: 
31: 		if err == nil {
32: 			err = syscall.SetsockoptInt(int(fd), syscall.SOL_IP, syscall.IP_RECVORIGDSTADDR, 1)
33: 		}
34: 		if err == nil && isIPv6 {
35: 			err = syscall.SetsockoptInt(int(fd), syscall.SOL_IPV6, IPV6_RECVORIGDSTADDR, 1)
36: 		}
37: 	})
38: 
39: 	return err
40: }


./listener\tproxy\setsockopt_other.go
1: //go:build !linux
2: 
3: package tproxy
4: 
5: import (
6: 	"errors"
7: 	"syscall"
8: )
9: 
10: func setsockopt(rc syscall.RawConn, addr string) error {
11: 	return errors.New("not supported on current platform")
12: }


./listener\tproxy\tcp.go
1: package tproxy
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/adapter/inbound"
7: 	C "github.com/Dreamacro/clash/constant"
8: 	"github.com/Dreamacro/clash/transport/socks5"
9: )
10: 
11: type Listener struct {
12: 	listener net.Listener
13: 	addr     string
14: 	closed   bool
15: }
16: 
17: // RawAddress implements C.Listener
18: func (l *Listener) RawAddress() string {
19: 	return l.addr
20: }
21: 
22: // Address implements C.Listener
23: func (l *Listener) Address() string {
24: 	return l.listener.Addr().String()
25: }
26: 
27: // Close implements C.Listener
28: func (l *Listener) Close() error {
29: 	l.closed = true
30: 	return l.listener.Close()
31: }
32: 
33: func (l *Listener) handleTProxy(conn net.Conn, in chan<- C.ConnContext) {
34: 	target := socks5.ParseAddrToSocksAddr(conn.LocalAddr())
35: 	conn.(*net.TCPConn).SetKeepAlive(true)
36: 	in <- inbound.NewSocket(target, conn, C.TPROXY)
37: }
38: 
39: func New(addr string, in chan<- C.ConnContext) (C.Listener, error) {
40: 	l, err := net.Listen("tcp", addr)
41: 	if err != nil {
42: 		return nil, err
43: 	}
44: 
45: 	tl := l.(*net.TCPListener)
46: 	rc, err := tl.SyscallConn()
47: 	if err != nil {
48: 		return nil, err
49: 	}
50: 
51: 	err = setsockopt(rc, addr)
52: 	if err != nil {
53: 		return nil, err
54: 	}
55: 
56: 	rl := &Listener{
57: 		listener: l,
58: 		addr:     addr,
59: 	}
60: 
61: 	go func() {
62: 		for {
63: 			c, err := l.Accept()
64: 			if err != nil {
65: 				if rl.closed {
66: 					break
67: 				}
68: 				continue
69: 			}
70: 			go rl.handleTProxy(c, in)
71: 		}
72: 	}()
73: 
74: 	return rl, nil
75: }


./listener\tproxy\udp.go
1: package tproxy
2: 
3: import (
4: 	"net"
5: 	"net/netip"
6: 
7: 	"github.com/Dreamacro/clash/adapter/inbound"
8: 	"github.com/Dreamacro/clash/common/pool"
9: 	C "github.com/Dreamacro/clash/constant"
10: 	"github.com/Dreamacro/clash/transport/socks5"
11: )
12: 
13: type UDPListener struct {
14: 	packetConn net.PacketConn
15: 	addr       string
16: 	closed     bool
17: }
18: 
19: // RawAddress implements C.Listener
20: func (l *UDPListener) RawAddress() string {
21: 	return l.addr
22: }
23: 
24: // Address implements C.Listener
25: func (l *UDPListener) Address() string {
26: 	return l.packetConn.LocalAddr().String()
27: }
28: 
29: // Close implements C.Listener
30: func (l *UDPListener) Close() error {
31: 	l.closed = true
32: 	return l.packetConn.Close()
33: }
34: 
35: func NewUDP(addr string, in chan<- *inbound.PacketAdapter) (C.Listener, error) {
36: 	l, err := net.ListenPacket("udp", addr)
37: 	if err != nil {
38: 		return nil, err
39: 	}
40: 
41: 	rl := &UDPListener{
42: 		packetConn: l,
43: 		addr:       addr,
44: 	}
45: 
46: 	c := l.(*net.UDPConn)
47: 
48: 	rc, err := c.SyscallConn()
49: 	if err != nil {
50: 		return nil, err
51: 	}
52: 
53: 	err = setsockopt(rc, addr)
54: 	if err != nil {
55: 		return nil, err
56: 	}
57: 
58: 	go func() {
59: 		oob := make([]byte, 1024)
60: 		for {
61: 			buf := pool.Get(pool.UDPBufferSize)
62: 			n, oobn, _, lAddr, err := c.ReadMsgUDPAddrPort(buf, oob)
63: 			if err != nil {
64: 				pool.Put(buf)
65: 				if rl.closed {
66: 					break
67: 				}
68: 				continue
69: 			}
70: 
71: 			rAddr, err := getOrigDst(oob[:oobn])
72: 			if err != nil {
73: 				continue
74: 			}
75: 
76: 			if rAddr.Addr().Is4() {
77: 				// try to unmap 4in6 address
78: 				lAddr = netip.AddrPortFrom(lAddr.Addr().Unmap(), lAddr.Port())
79: 			}
80: 			handlePacketConn(in, buf[:n], lAddr, rAddr)
81: 		}
82: 	}()
83: 
84: 	return rl, nil
85: }
86: 
87: func handlePacketConn(in chan<- *inbound.PacketAdapter, buf []byte, lAddr, rAddr netip.AddrPort) {
88: 	target := socks5.AddrFromStdAddrPort(rAddr)
89: 	pkt := &packet{
90: 		lAddr: lAddr,
91: 		buf:   buf,
92: 	}
93: 	select {
94: 	case in <- inbound.NewPacket(target, target.UDPAddr(), pkt, C.TPROXY):
95: 	default:
96: 	}
97: }


./listener\tproxy\udp_linux.go
1: //go:build linux
2: 
3: package tproxy
4: 
5: import (
6: 	"fmt"
7: 	"net"
8: 	"net/netip"
9: 	"os"
10: 	"strconv"
11: 	"syscall"
12: 
13: 	"golang.org/x/sys/unix"
14: )
15: 
16: const (
17: 	IPV6_TRANSPARENT     = 0x4b
18: 	IPV6_RECVORIGDSTADDR = 0x4a
19: )
20: 
21: // dialUDP acts like net.DialUDP for transparent proxy.
22: // It binds to a non-local address(`lAddr`).
23: func dialUDP(network string, lAddr, rAddr netip.AddrPort) (uc *net.UDPConn, err error) {
24: 	rSockAddr, err := udpAddrToSockAddr(rAddr)
25: 	if err != nil {
26: 		return nil, err
27: 	}
28: 
29: 	lSockAddr, err := udpAddrToSockAddr(lAddr)
30: 	if err != nil {
31: 		return nil, err
32: 	}
33: 
34: 	fd, err := syscall.Socket(udpAddrFamily(network, lAddr, rAddr), syscall.SOCK_DGRAM, 0)
35: 	if err != nil {
36: 		return nil, err
37: 	}
38: 
39: 	defer func() {
40: 		if err != nil {
41: 			syscall.Close(fd)
42: 		}
43: 	}()
44: 
45: 	if err = syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1); err != nil {
46: 		return nil, err
47: 	}
48: 
49: 	if err = syscall.SetsockoptInt(fd, syscall.SOL_IP, syscall.IP_TRANSPARENT, 1); err != nil {
50: 		return nil, err
51: 	}
52: 
53: 	if err = syscall.Bind(fd, lSockAddr); err != nil {
54: 		return nil, err
55: 	}
56: 
57: 	if err = syscall.Connect(fd, rSockAddr); err != nil {
58: 		return nil, err
59: 	}
60: 
61: 	fdFile := os.NewFile(uintptr(fd), fmt.Sprintf("net-udp-dial-%s", rAddr.String()))
62: 	defer fdFile.Close()
63: 
64: 	c, err := net.FileConn(fdFile)
65: 	if err != nil {
66: 		return nil, err
67: 	}
68: 
69: 	return c.(*net.UDPConn), nil
70: }
71: 
72: func udpAddrToSockAddr(addr netip.AddrPort) (syscall.Sockaddr, error) {
73: 	if addr.Addr().Is4() {
74: 		return &syscall.SockaddrInet4{Addr: addr.Addr().As4(), Port: int(addr.Port())}, nil
75: 	}
76: 
77: 	zoneID, err := strconv.ParseUint(addr.Addr().Zone(), 10, 32)
78: 	if err != nil {
79: 		zoneID = 0
80: 	}
81: 
82: 	return &syscall.SockaddrInet6{Addr: addr.Addr().As16(), Port: int(addr.Port()), ZoneId: uint32(zoneID)}, nil
83: }
84: 
85: func udpAddrFamily(net string, lAddr, rAddr netip.AddrPort) int {
86: 	switch net[len(net)-1] {
87: 	case '4':
88: 		return syscall.AF_INET
89: 	case '6':
90: 		return syscall.AF_INET6
91: 	}
92: 
93: 	if lAddr.Addr().Is4() && rAddr.Addr().Is4() {
94: 		return syscall.AF_INET
95: 	}
96: 	return syscall.AF_INET6
97: }
98: 
99: func getOrigDst(oob []byte) (netip.AddrPort, error) {
100: 	// oob contains socket control messages which we need to parse.
101: 	scms, err := unix.ParseSocketControlMessage(oob)
102: 	if err != nil {
103: 		return netip.AddrPort{}, fmt.Errorf("parse control message: %w", err)
104: 	}
105: 
106: 	// retrieve the destination address from the SCM.
107: 	sa, err := unix.ParseOrigDstAddr(&scms[0])
108: 	if err != nil {
109: 		return netip.AddrPort{}, fmt.Errorf("retrieve destination: %w", err)
110: 	}
111: 
112: 	// encode the destination address into a cmsg.
113: 	var rAddr netip.AddrPort
114: 	switch v := sa.(type) {
115: 	case *unix.SockaddrInet4:
116: 		rAddr = netip.AddrPortFrom(netip.AddrFrom4(v.Addr), uint16(v.Port))
117: 	case *unix.SockaddrInet6:
118: 		rAddr = netip.AddrPortFrom(netip.AddrFrom16(v.Addr), uint16(v.Port))
119: 	default:
120: 		return netip.AddrPort{}, fmt.Errorf("unsupported address type: %T", v)
121: 	}
122: 
123: 	return rAddr, nil
124: }


./listener\tproxy\udp_other.go
1: //go:build !linux
2: 
3: package tproxy
4: 
5: import (
6: 	"errors"
7: 	"net"
8: 	"net/netip"
9: )
10: 
11: func getOrigDst(oob []byte) (netip.AddrPort, error) {
12: 	return netip.AddrPort{}, errors.New("UDP redir not supported on current platform")
13: }
14: 
15: func dialUDP(network string, lAddr, rAddr netip.AddrPort) (*net.UDPConn, error) {
16: 	return nil, errors.New("UDP redir not supported on current platform")
17: }


./listener\tunnel\packet.go
1: package tunnel
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/common/pool"
7: )
8: 
9: type packet struct {
10: 	pc      net.PacketConn
11: 	rAddr   net.Addr
12: 	payload []byte
13: }
14: 
15: func (c *packet) Data() []byte {
16: 	return c.payload
17: }
18: 
19: // WriteBack write UDP packet with source(ip, port) = `addr`
20: func (c *packet) WriteBack(b []byte, addr net.Addr) (n int, err error) {
21: 	return c.pc.WriteTo(b, c.rAddr)
22: }
23: 
24: // LocalAddr returns the source IP/Port of UDP Packet
25: func (c *packet) LocalAddr() net.Addr {
26: 	return c.rAddr
27: }
28: 
29: func (c *packet) Drop() {
30: 	pool.Put(c.payload)
31: }


./listener\tunnel\tcp.go
1: package tunnel
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 
7: 	"github.com/Dreamacro/clash/adapter/inbound"
8: 	C "github.com/Dreamacro/clash/constant"
9: 	"github.com/Dreamacro/clash/transport/socks5"
10: )
11: 
12: type Listener struct {
13: 	listener net.Listener
14: 	addr     string
15: 	target   socks5.Addr
16: 	proxy    string
17: 	closed   bool
18: }
19: 
20: // RawAddress implements C.Listener
21: func (l *Listener) RawAddress() string {
22: 	return l.addr
23: }
24: 
25: // Address implements C.Listener
26: func (l *Listener) Address() string {
27: 	return l.listener.Addr().String()
28: }
29: 
30: // Close implements C.Listener
31: func (l *Listener) Close() error {
32: 	l.closed = true
33: 	return l.listener.Close()
34: }
35: 
36: func (l *Listener) handleTCP(conn net.Conn, in chan<- C.ConnContext) {
37: 	conn.(*net.TCPConn).SetKeepAlive(true)
38: 	ctx := inbound.NewSocket(l.target, conn, C.TUNNEL)
39: 	ctx.Metadata().SpecialProxy = l.proxy
40: 	in <- ctx
41: }
42: 
43: func New(addr, target, proxy string, in chan<- C.ConnContext) (*Listener, error) {
44: 	l, err := net.Listen("tcp", addr)
45: 	if err != nil {
46: 		return nil, err
47: 	}
48: 
49: 	targetAddr := socks5.ParseAddr(target)
50: 	if targetAddr == nil {
51: 		return nil, fmt.Errorf("invalid target address %s", target)
52: 	}
53: 
54: 	rl := &Listener{
55: 		listener: l,
56: 		target:   targetAddr,
57: 		proxy:    proxy,
58: 		addr:     addr,
59: 	}
60: 
61: 	go func() {
62: 		for {
63: 			c, err := l.Accept()
64: 			if err != nil {
65: 				if rl.closed {
66: 					break
67: 				}
68: 				continue
69: 			}
70: 			go rl.handleTCP(c, in)
71: 		}
72: 	}()
73: 
74: 	return rl, nil
75: }


./listener\tunnel\udp.go
1: package tunnel
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 
7: 	"github.com/Dreamacro/clash/adapter/inbound"
8: 	"github.com/Dreamacro/clash/common/pool"
9: 	C "github.com/Dreamacro/clash/constant"
10: 	"github.com/Dreamacro/clash/transport/socks5"
11: )
12: 
13: type PacketConn struct {
14: 	conn   net.PacketConn
15: 	addr   string
16: 	target socks5.Addr
17: 	proxy  string
18: 	closed bool
19: }
20: 
21: // RawAddress implements C.Listener
22: func (l *PacketConn) RawAddress() string {
23: 	return l.addr
24: }
25: 
26: // Address implements C.Listener
27: func (l *PacketConn) Address() string {
28: 	return l.conn.LocalAddr().String()
29: }
30: 
31: // Close implements C.Listener
32: func (l *PacketConn) Close() error {
33: 	l.closed = true
34: 	return l.conn.Close()
35: }
36: 
37: func NewUDP(addr, target, proxy string, in chan<- *inbound.PacketAdapter) (*PacketConn, error) {
38: 	l, err := net.ListenPacket("udp", addr)
39: 	if err != nil {
40: 		return nil, err
41: 	}
42: 
43: 	targetAddr := socks5.ParseAddr(target)
44: 	if targetAddr == nil {
45: 		return nil, fmt.Errorf("invalid target address %s", target)
46: 	}
47: 
48: 	sl := &PacketConn{
49: 		conn:   l,
50: 		target: targetAddr,
51: 		proxy:  proxy,
52: 		addr:   addr,
53: 	}
54: 	go func() {
55: 		for {
56: 			buf := pool.Get(pool.UDPBufferSize)
57: 			n, remoteAddr, err := l.ReadFrom(buf)
58: 			if err != nil {
59: 				pool.Put(buf)
60: 				if sl.closed {
61: 					break
62: 				}
63: 				continue
64: 			}
65: 			sl.handleUDP(l, in, buf[:n], remoteAddr)
66: 		}
67: 	}()
68: 
69: 	return sl, nil
70: }
71: 
72: func (l *PacketConn) handleUDP(pc net.PacketConn, in chan<- *inbound.PacketAdapter, buf []byte, addr net.Addr) {
73: 	packet := &packet{
74: 		pc:      pc,
75: 		rAddr:   addr,
76: 		payload: buf,
77: 	}
78: 
79: 	ctx := inbound.NewPacket(l.target, pc.LocalAddr(), packet, C.TUNNEL)
80: 	ctx.Metadata().SpecialProxy = l.proxy
81: 	select {
82: 	case in <- ctx:
83: 	default:
84: 	}
85: }


./log\level.go
1: package log
2: 
3: import (
4: 	"encoding/json"
5: 	"errors"
6: )
7: 
8: // LogLevelMapping is a mapping for LogLevel enum
9: var LogLevelMapping = map[string]LogLevel{
10: 	ERROR.String():   ERROR,
11: 	WARNING.String(): WARNING,
12: 	INFO.String():    INFO,
13: 	DEBUG.String():   DEBUG,
14: 	SILENT.String():  SILENT,
15: }
16: 
17: const (
18: 	DEBUG LogLevel = iota
19: 	INFO
20: 	WARNING
21: 	ERROR
22: 	SILENT
23: )
24: 
25: type LogLevel int
26: 
27: // UnmarshalYAML unserialize LogLevel with yaml
28: func (l *LogLevel) UnmarshalYAML(unmarshal func(any) error) error {
29: 	var tp string
30: 	unmarshal(&tp)
31: 	level, exist := LogLevelMapping[tp]
32: 	if !exist {
33: 		return errors.New("invalid mode")
34: 	}
35: 	*l = level
36: 	return nil
37: }
38: 
39: // UnmarshalJSON unserialize LogLevel with json
40: func (l *LogLevel) UnmarshalJSON(data []byte) error {
41: 	var tp string
42: 	json.Unmarshal(data, &tp)
43: 	level, exist := LogLevelMapping[tp]
44: 	if !exist {
45: 		return errors.New("invalid mode")
46: 	}
47: 	*l = level
48: 	return nil
49: }
50: 
51: // MarshalJSON serialize LogLevel with json
52: func (l LogLevel) MarshalJSON() ([]byte, error) {
53: 	return json.Marshal(l.String())
54: }
55: 
56: // MarshalYAML serialize LogLevel with yaml
57: func (l LogLevel) MarshalYAML() (any, error) {
58: 	return l.String(), nil
59: }
60: 
61: func (l LogLevel) String() string {
62: 	switch l {
63: 	case INFO:
64: 		return "info"
65: 	case WARNING:
66: 		return "warning"
67: 	case ERROR:
68: 		return "error"
69: 	case DEBUG:
70: 		return "debug"
71: 	case SILENT:
72: 		return "silent"
73: 	default:
74: 		return "unknown"
75: 	}
76: }


./log\log.go
1: package log
2: 
3: import (
4: 	"fmt"
5: 	"os"
6: 
7: 	"github.com/Dreamacro/clash/common/observable"
8: 
9: 	log "github.com/sirupsen/logrus"
10: )
11: 
12: var (
13: 	logCh  = make(chan any)
14: 	source = observable.NewObservable(logCh)
15: 	level  = INFO
16: )
17: 
18: func init() {
19: 	log.SetOutput(os.Stdout)
20: 	log.SetLevel(log.DebugLevel)
21: }
22: 
23: type Event struct {
24: 	LogLevel LogLevel
25: 	Payload  string
26: }
27: 
28: func (e *Event) Type() string {
29: 	return e.LogLevel.String()
30: }
31: 
32: func Infoln(format string, v ...any) {
33: 	event := newLog(INFO, format, v...)
34: 	logCh <- event
35: 	print(event)
36: }
37: 
38: func Warnln(format string, v ...any) {
39: 	event := newLog(WARNING, format, v...)
40: 	logCh <- event
41: 	print(event)
42: }
43: 
44: func Errorln(format string, v ...any) {
45: 	event := newLog(ERROR, format, v...)
46: 	logCh <- event
47: 	print(event)
48: }
49: 
50: func Debugln(format string, v ...any) {
51: 	event := newLog(DEBUG, format, v...)
52: 	logCh <- event
53: 	print(event)
54: }
55: 
56: func Fatalln(format string, v ...any) {
57: 	log.Fatalf(format, v...)
58: }
59: 
60: func Subscribe() observable.Subscription {
61: 	sub, _ := source.Subscribe()
62: 	return sub
63: }
64: 
65: func UnSubscribe(sub observable.Subscription) {
66: 	source.UnSubscribe(sub)
67: }
68: 
69: func Level() LogLevel {
70: 	return level
71: }
72: 
73: func SetLevel(newLevel LogLevel) {
74: 	level = newLevel
75: }
76: 
77: func print(data Event) {
78: 	if data.LogLevel < level {
79: 		return
80: 	}
81: 
82: 	switch data.LogLevel {
83: 	case INFO:
84: 		log.Infoln(data.Payload)
85: 	case WARNING:
86: 		log.Warnln(data.Payload)
87: 	case ERROR:
88: 		log.Errorln(data.Payload)
89: 	case DEBUG:
90: 		log.Debugln(data.Payload)
91: 	case SILENT:
92: 		return
93: 	}
94: }
95: 
96: func newLog(logLevel LogLevel, format string, v ...any) Event {
97: 	return Event{
98: 		LogLevel: logLevel,
99: 		Payload:  fmt.Sprintf(format, v...),
100: 	}
101: }


./rule\base.go
1: package rules
2: 
3: import (
4: 	"errors"
5: )
6: 
7: var (
8: 	errPayload = errors.New("payload error")
9: 
10: 	noResolve = "no-resolve"
11: )
12: 
13: func HasNoResolve(params []string) bool {
14: 	for _, p := range params {
15: 		if p == noResolve {
16: 			return true
17: 		}
18: 	}
19: 	return false
20: }


./rule\domain.go
1: package rules
2: 
3: import (
4: 	"strings"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: )
8: 
9: // Implements C.Rule
10: var _ C.Rule = (*Domain)(nil)
11: 
12: type Domain struct {
13: 	domain  string
14: 	adapter string
15: }
16: 
17: func (d *Domain) RuleType() C.RuleType {
18: 	return C.Domain
19: }
20: 
21: func (d *Domain) Match(metadata *C.Metadata) bool {
22: 	return metadata.Host == d.domain
23: }
24: 
25: func (d *Domain) Adapter() string {
26: 	return d.adapter
27: }
28: 
29: func (d *Domain) Payload() string {
30: 	return d.domain
31: }
32: 
33: func (d *Domain) ShouldResolveIP() bool {
34: 	return false
35: }
36: 
37: func (d *Domain) ShouldFindProcess() bool {
38: 	return false
39: }
40: 
41: func NewDomain(domain string, adapter string) *Domain {
42: 	return &Domain{
43: 		domain:  strings.ToLower(domain),
44: 		adapter: adapter,
45: 	}
46: }


./rule\domain_keyword.go
1: package rules
2: 
3: import (
4: 	"strings"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: )
8: 
9: // Implements C.Rule
10: var _ C.Rule = (*DomainKeyword)(nil)
11: 
12: type DomainKeyword struct {
13: 	keyword string
14: 	adapter string
15: }
16: 
17: func (dk *DomainKeyword) RuleType() C.RuleType {
18: 	return C.DomainKeyword
19: }
20: 
21: func (dk *DomainKeyword) Match(metadata *C.Metadata) bool {
22: 	return strings.Contains(metadata.Host, dk.keyword)
23: }
24: 
25: func (dk *DomainKeyword) Adapter() string {
26: 	return dk.adapter
27: }
28: 
29: func (dk *DomainKeyword) Payload() string {
30: 	return dk.keyword
31: }
32: 
33: func (dk *DomainKeyword) ShouldResolveIP() bool {
34: 	return false
35: }
36: 
37: func (dk *DomainKeyword) ShouldFindProcess() bool {
38: 	return false
39: }
40: 
41: func NewDomainKeyword(keyword string, adapter string) *DomainKeyword {
42: 	return &DomainKeyword{
43: 		keyword: strings.ToLower(keyword),
44: 		adapter: adapter,
45: 	}
46: }


./rule\domain_suffix.go
1: package rules
2: 
3: import (
4: 	"strings"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: )
8: 
9: // Implements C.Rule
10: var _ C.Rule = (*DomainSuffix)(nil)
11: 
12: type DomainSuffix struct {
13: 	suffix  string
14: 	adapter string
15: }
16: 
17: func (ds *DomainSuffix) RuleType() C.RuleType {
18: 	return C.DomainSuffix
19: }
20: 
21: func (ds *DomainSuffix) Match(metadata *C.Metadata) bool {
22: 	domain := metadata.Host
23: 	return strings.HasSuffix(domain, "."+ds.suffix) || domain == ds.suffix
24: }
25: 
26: func (ds *DomainSuffix) Adapter() string {
27: 	return ds.adapter
28: }
29: 
30: func (ds *DomainSuffix) Payload() string {
31: 	return ds.suffix
32: }
33: 
34: func (ds *DomainSuffix) ShouldResolveIP() bool {
35: 	return false
36: }
37: 
38: func (ds *DomainSuffix) ShouldFindProcess() bool {
39: 	return false
40: }
41: 
42: func NewDomainSuffix(suffix string, adapter string) *DomainSuffix {
43: 	return &DomainSuffix{
44: 		suffix:  strings.ToLower(suffix),
45: 		adapter: adapter,
46: 	}
47: }


./rule\final.go
1: package rules
2: 
3: import (
4: 	C "github.com/Dreamacro/clash/constant"
5: )
6: 
7: // Implements C.Rule
8: var _ C.Rule = (*Match)(nil)
9: 
10: type Match struct {
11: 	adapter string
12: }
13: 
14: func (f *Match) RuleType() C.RuleType {
15: 	return C.MATCH
16: }
17: 
18: func (f *Match) Match(metadata *C.Metadata) bool {
19: 	return true
20: }
21: 
22: func (f *Match) Adapter() string {
23: 	return f.adapter
24: }
25: 
26: func (f *Match) Payload() string {
27: 	return ""
28: }
29: 
30: func (f *Match) ShouldResolveIP() bool {
31: 	return false
32: }
33: 
34: func (f *Match) ShouldFindProcess() bool {
35: 	return false
36: }
37: 
38: func NewMatch(adapter string) *Match {
39: 	return &Match{
40: 		adapter: adapter,
41: 	}
42: }


./rule\geoip.go
1: package rules
2: 
3: import (
4: 	"strings"
5: 
6: 	"github.com/Dreamacro/clash/component/mmdb"
7: 	C "github.com/Dreamacro/clash/constant"
8: )
9: 
10: // Implements C.Rule
11: var _ C.Rule = (*GEOIP)(nil)
12: 
13: type GEOIP struct {
14: 	country     string
15: 	adapter     string
16: 	noResolveIP bool
17: }
18: 
19: func (g *GEOIP) RuleType() C.RuleType {
20: 	return C.GEOIP
21: }
22: 
23: func (g *GEOIP) Match(metadata *C.Metadata) bool {
24: 	ip := metadata.DstIP
25: 	if ip == nil {
26: 		return false
27: 	}
28: 
29: 	if strings.EqualFold(g.country, "LAN") {
30: 		return ip.IsPrivate()
31: 	}
32: 	record, _ := mmdb.Instance().Country(ip)
33: 	return strings.EqualFold(record.Country.IsoCode, g.country)
34: }
35: 
36: func (g *GEOIP) Adapter() string {
37: 	return g.adapter
38: }
39: 
40: func (g *GEOIP) Payload() string {
41: 	return g.country
42: }
43: 
44: func (g *GEOIP) ShouldResolveIP() bool {
45: 	return !g.noResolveIP
46: }
47: 
48: func (g *GEOIP) ShouldFindProcess() bool {
49: 	return false
50: }
51: 
52: func NewGEOIP(country string, adapter string, noResolveIP bool) *GEOIP {
53: 	geoip := &GEOIP{
54: 		country:     country,
55: 		adapter:     adapter,
56: 		noResolveIP: noResolveIP,
57: 	}
58: 
59: 	return geoip
60: }


./rule\ipcidr.go
1: package rules
2: 
3: import (
4: 	"net"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: )
8: 
9: type IPCIDROption func(*IPCIDR)
10: 
11: func WithIPCIDRSourceIP(b bool) IPCIDROption {
12: 	return func(i *IPCIDR) {
13: 		i.isSourceIP = b
14: 	}
15: }
16: 
17: func WithIPCIDRNoResolve(noResolve bool) IPCIDROption {
18: 	return func(i *IPCIDR) {
19: 		i.noResolveIP = noResolve
20: 	}
21: }
22: 
23: // Implements C.Rule
24: var _ C.Rule = (*IPCIDR)(nil)
25: 
26: type IPCIDR struct {
27: 	ipnet       *net.IPNet
28: 	adapter     string
29: 	isSourceIP  bool
30: 	noResolveIP bool
31: }
32: 
33: func (i *IPCIDR) RuleType() C.RuleType {
34: 	if i.isSourceIP {
35: 		return C.SrcIPCIDR
36: 	}
37: 	return C.IPCIDR
38: }
39: 
40: func (i *IPCIDR) Match(metadata *C.Metadata) bool {
41: 	ip := metadata.DstIP
42: 	if i.isSourceIP {
43: 		ip = metadata.SrcIP
44: 	}
45: 	return ip != nil && i.ipnet.Contains(ip)
46: }
47: 
48: func (i *IPCIDR) Adapter() string {
49: 	return i.adapter
50: }
51: 
52: func (i *IPCIDR) Payload() string {
53: 	return i.ipnet.String()
54: }
55: 
56: func (i *IPCIDR) ShouldResolveIP() bool {
57: 	return !i.noResolveIP
58: }
59: 
60: func (i *IPCIDR) ShouldFindProcess() bool {
61: 	return false
62: }
63: 
64: func NewIPCIDR(s string, adapter string, opts ...IPCIDROption) (*IPCIDR, error) {
65: 	_, ipnet, err := net.ParseCIDR(s)
66: 	if err != nil {
67: 		return nil, errPayload
68: 	}
69: 
70: 	ipcidr := &IPCIDR{
71: 		ipnet:   ipnet,
72: 		adapter: adapter,
73: 	}
74: 
75: 	for _, o := range opts {
76: 		o(ipcidr)
77: 	}
78: 
79: 	return ipcidr, nil
80: }


./rule\ipset.go
1: package rules
2: 
3: import (
4: 	"github.com/Dreamacro/clash/component/ipset"
5: 	C "github.com/Dreamacro/clash/constant"
6: 	"github.com/Dreamacro/clash/log"
7: )
8: 
9: // Implements C.Rule
10: var _ C.Rule = (*IPSet)(nil)
11: 
12: type IPSet struct {
13: 	name        string
14: 	adapter     string
15: 	noResolveIP bool
16: }
17: 
18: func (f *IPSet) RuleType() C.RuleType {
19: 	return C.IPSet
20: }
21: 
22: func (f *IPSet) Match(metadata *C.Metadata) bool {
23: 	exist, err := ipset.Test(f.name, metadata.DstIP)
24: 	if err != nil {
25: 		log.Warnln("check ipset '%s' failed: %s", f.name, err.Error())
26: 		return false
27: 	}
28: 	return exist
29: }
30: 
31: func (f *IPSet) Adapter() string {
32: 	return f.adapter
33: }
34: 
35: func (f *IPSet) Payload() string {
36: 	return f.name
37: }
38: 
39: func (f *IPSet) ShouldResolveIP() bool {
40: 	return !f.noResolveIP
41: }
42: 
43: func (f *IPSet) ShouldFindProcess() bool {
44: 	return false
45: }
46: 
47: func NewIPSet(name string, adapter string, noResolveIP bool) (*IPSet, error) {
48: 	if err := ipset.Verify(name); err != nil {
49: 		return nil, err
50: 	}
51: 
52: 	return &IPSet{
53: 		name:        name,
54: 		adapter:     adapter,
55: 		noResolveIP: noResolveIP,
56: 	}, nil
57: }


./rule\parser.go
1: package rules
2: 
3: import (
4: 	"fmt"
5: 
6: 	C "github.com/Dreamacro/clash/constant"
7: )
8: 
9: func ParseRule(tp, payload, target string, params []string) (C.Rule, error) {
10: 	var (
11: 		parseErr error
12: 		parsed   C.Rule
13: 	)
14: 
15: 	ruleConfigType := C.RuleConfig(tp)
16: 
17: 	switch ruleConfigType {
18: 	case C.RuleConfigDomain:
19: 		parsed = NewDomain(payload, target)
20: 	case C.RuleConfigDomainSuffix:
21: 		parsed = NewDomainSuffix(payload, target)
22: 	case C.RuleConfigDomainKeyword:
23: 		parsed = NewDomainKeyword(payload, target)
24: 	case C.RuleConfigGeoIP:
25: 		noResolve := HasNoResolve(params)
26: 		parsed = NewGEOIP(payload, target, noResolve)
27: 	case C.RuleConfigIPCIDR, C.RuleConfigIPCIDR6:
28: 		noResolve := HasNoResolve(params)
29: 		parsed, parseErr = NewIPCIDR(payload, target, WithIPCIDRNoResolve(noResolve))
30: 	case C.RuleConfigSrcIPCIDR:
31: 		parsed, parseErr = NewIPCIDR(payload, target, WithIPCIDRSourceIP(true), WithIPCIDRNoResolve(true))
32: 	case C.RuleConfigSrcPort:
33: 		parsed, parseErr = NewPort(payload, target, PortTypeSrc)
34: 	case C.RuleConfigDstPort:
35: 		parsed, parseErr = NewPort(payload, target, PortTypeDest)
36: 	case C.RuleConfigInboundPort:
37: 		parsed, parseErr = NewPort(payload, target, PortTypeInbound)
38: 	case C.RuleConfigProcessName:
39: 		parsed, parseErr = NewProcess(payload, target, true)
40: 	case C.RuleConfigProcessPath:
41: 		parsed, parseErr = NewProcess(payload, target, false)
42: 	case C.RuleConfigIPSet:
43: 		noResolve := HasNoResolve(params)
44: 		parsed, parseErr = NewIPSet(payload, target, noResolve)
45: 	case C.RuleConfigMatch:
46: 		parsed = NewMatch(target)
47: 	case C.RuleConfigRuleSet, C.RuleConfigScript:
48: 		parseErr = fmt.Errorf("unsupported rule type %s", tp)
49: 	default:
50: 		parseErr = fmt.Errorf("unsupported rule type %s", tp)
51: 	}
52: 
53: 	return parsed, parseErr
54: }


./rule\parser_test.go
1: package rules
2: 
3: import (
4: 	"errors"
5: 	"fmt"
6: 	"testing"
7: 
8: 	C "github.com/Dreamacro/clash/constant"
9: 
10: 	"github.com/samber/lo"
11: 	"github.com/stretchr/testify/assert"
12: 	"github.com/stretchr/testify/require"
13: )
14: 
15: func TestParseRule(t *testing.T) {
16: 	type testCase struct {
17: 		tp            C.RuleConfig
18: 		payload       string
19: 		target        string
20: 		params        []string
21: 		expectedRule  C.Rule
22: 		expectedError error
23: 	}
24: 
25: 	policy := "DIRECT"
26: 
27: 	testCases := []testCase{
28: 		{
29: 			tp:           C.RuleConfigDomain,
30: 			payload:      "example.com",
31: 			target:       policy,
32: 			expectedRule: NewDomain("example.com", policy),
33: 		},
34: 		{
35: 			tp:           C.RuleConfigDomainSuffix,
36: 			payload:      "example.com",
37: 			target:       policy,
38: 			expectedRule: NewDomainSuffix("example.com", policy),
39: 		},
40: 		{
41: 			tp:           C.RuleConfigDomainKeyword,
42: 			payload:      "example.com",
43: 			target:       policy,
44: 			expectedRule: NewDomainKeyword("example.com", policy),
45: 		},
46: 		{
47: 			tp:      C.RuleConfigGeoIP,
48: 			payload: "CN",
49: 			target:  policy, params: []string{noResolve},
50: 			expectedRule: NewGEOIP("CN", policy, true),
51: 		},
52: 		{
53: 			tp:           C.RuleConfigIPCIDR,
54: 			payload:      "127.0.0.0/8",
55: 			target:       policy,
56: 			expectedRule: lo.Must(NewIPCIDR("127.0.0.0/8", policy, WithIPCIDRNoResolve(false))),
57: 		},
58: 		{
59: 			tp:      C.RuleConfigIPCIDR,
60: 			payload: "127.0.0.0/8",
61: 			target:  policy, params: []string{noResolve},
62: 			expectedRule: lo.Must(NewIPCIDR("127.0.0.0/8", policy, WithIPCIDRNoResolve(true))),
63: 		},
64: 		{
65: 			tp:           C.RuleConfigIPCIDR6,
66: 			payload:      "2001:db8::/32",
67: 			target:       policy,
68: 			expectedRule: lo.Must(NewIPCIDR("2001:db8::/32", policy, WithIPCIDRNoResolve(false))),
69: 		},
70: 		{
71: 			tp:      C.RuleConfigIPCIDR6,
72: 			payload: "2001:db8::/32",
73: 			target:  policy, params: []string{noResolve},
74: 			expectedRule: lo.Must(NewIPCIDR("2001:db8::/32", policy, WithIPCIDRNoResolve(true))),
75: 		},
76: 		{
77: 			tp:           C.RuleConfigSrcIPCIDR,
78: 			payload:      "192.168.1.201/32",
79: 			target:       policy,
80: 			expectedRule: lo.Must(NewIPCIDR("192.168.1.201/32", policy, WithIPCIDRSourceIP(true), WithIPCIDRNoResolve(true))),
81: 		},
82: 		{
83: 			tp:           C.RuleConfigSrcPort,
84: 			payload:      "80",
85: 			target:       policy,
86: 			expectedRule: lo.Must(NewPort("80", policy, PortTypeSrc)),
87: 		},
88: 		{
89: 			tp:           C.RuleConfigDstPort,
90: 			payload:      "80",
91: 			target:       policy,
92: 			expectedRule: lo.Must(NewPort("80", policy, PortTypeDest)),
93: 		},
94: 		{
95: 			tp:           C.RuleConfigInboundPort,
96: 			payload:      "80",
97: 			target:       policy,
98: 			expectedRule: lo.Must(NewPort("80", policy, PortTypeInbound)),
99: 		},
100: 		{
101: 			tp:           C.RuleConfigProcessName,
102: 			payload:      "example.exe",
103: 			target:       policy,
104: 			expectedRule: lo.Must(NewProcess("example.exe", policy, true)),
105: 		},
106: 		{
107: 			tp:           C.RuleConfigProcessPath,
108: 			payload:      "C:\\Program Files\\example.exe",
109: 			target:       policy,
110: 			expectedRule: lo.Must(NewProcess("C:\\Program Files\\example.exe", policy, false)),
111: 		},
112: 		{
113: 			tp:           C.RuleConfigProcessPath,
114: 			payload:      "/opt/example/example",
115: 			target:       policy,
116: 			expectedRule: lo.Must(NewProcess("/opt/example/example", policy, false)),
117: 		},
118: 		{
119: 			tp:      C.RuleConfigIPSet,
120: 			payload: "example",
121: 			target:  policy,
122: 			// unit test runs on Linux machine and NewIPSet(...) won't be available
123: 			expectedError: errors.New("operation not permitted"),
124: 		},
125: 		{
126: 			tp:      C.RuleConfigIPSet,
127: 			payload: "example",
128: 			target:  policy, params: []string{noResolve},
129: 			// unit test runs on Linux machine and NewIPSet(...) won't be available
130: 			expectedError: errors.New("operation not permitted"),
131: 		},
132: 		{
133: 			tp:           C.RuleConfigMatch,
134: 			payload:      "example",
135: 			target:       policy,
136: 			expectedRule: NewMatch(policy),
137: 		},
138: 		{
139: 			tp:            C.RuleConfigRuleSet,
140: 			payload:       "example",
141: 			target:        policy,
142: 			expectedError: fmt.Errorf("unsupported rule type %s", C.RuleConfigRuleSet),
143: 		},
144: 		{
145: 			tp:            C.RuleConfigScript,
146: 			payload:       "example",
147: 			target:        policy,
148: 			expectedError: fmt.Errorf("unsupported rule type %s", C.RuleConfigScript),
149: 		},
150: 		{
151: 			tp:            "UNKNOWN",
152: 			payload:       "example",
153: 			target:        policy,
154: 			expectedError: errors.New("unsupported rule type UNKNOWN"),
155: 		},
156: 		{
157: 			tp:            "ABCD",
158: 			payload:       "example",
159: 			target:        policy,
160: 			expectedError: errors.New("unsupported rule type ABCD"),
161: 		},
162: 	}
163: 
164: 	for _, tc := range testCases {
165: 		_, err := ParseRule(string(tc.tp), tc.payload, tc.target, tc.params)
166: 		if tc.expectedError != nil {
167: 			require.Error(t, err)
168: 			assert.EqualError(t, err, tc.expectedError.Error())
169: 		} else {
170: 			require.NoError(t, err)
171: 		}
172: 	}
173: }


./rule\port.go
1: package rules
2: 
3: import (
4: 	"fmt"
5: 	"strconv"
6: 
7: 	C "github.com/Dreamacro/clash/constant"
8: )
9: 
10: type PortType int
11: 
12: const (
13: 	PortTypeSrc PortType = iota
14: 	PortTypeDest
15: 	PortTypeInbound
16: )
17: 
18: // Implements C.Rule
19: var _ C.Rule = (*Port)(nil)
20: 
21: type Port struct {
22: 	adapter  string
23: 	port     C.Port
24: 	portType PortType
25: }
26: 
27: func (p *Port) RuleType() C.RuleType {
28: 	switch p.portType {
29: 	case PortTypeSrc:
30: 		return C.SrcPort
31: 	case PortTypeDest:
32: 		return C.DstPort
33: 	case PortTypeInbound:
34: 		return C.InboundPort
35: 	default:
36: 		panic(fmt.Errorf("unknown port type: %v", p.portType))
37: 	}
38: }
39: 
40: func (p *Port) Match(metadata *C.Metadata) bool {
41: 	switch p.portType {
42: 	case PortTypeSrc:
43: 		return metadata.SrcPort == p.port
44: 	case PortTypeDest:
45: 		return metadata.DstPort == p.port
46: 	case PortTypeInbound:
47: 		return metadata.OriginDst.Port() == uint16(p.port)
48: 	default:
49: 		panic(fmt.Errorf("unknown port type: %v", p.portType))
50: 	}
51: }
52: 
53: func (p *Port) Adapter() string {
54: 	return p.adapter
55: }
56: 
57: func (p *Port) Payload() string {
58: 	return p.port.String()
59: }
60: 
61: func (p *Port) ShouldResolveIP() bool {
62: 	return false
63: }
64: 
65: func (p *Port) ShouldFindProcess() bool {
66: 	return false
67: }
68: 
69: func NewPort(port string, adapter string, portType PortType) (*Port, error) {
70: 	p, err := strconv.ParseUint(port, 10, 16)
71: 	if err != nil {
72: 		return nil, errPayload
73: 	}
74: 	return &Port{
75: 		adapter:  adapter,
76: 		port:     C.Port(p),
77: 		portType: portType,
78: 	}, nil
79: }


./rule\process.go
1: package rules
2: 
3: import (
4: 	"path/filepath"
5: 	"strings"
6: 
7: 	C "github.com/Dreamacro/clash/constant"
8: )
9: 
10: // Implements C.Rule
11: var _ C.Rule = (*Process)(nil)
12: 
13: type Process struct {
14: 	adapter  string
15: 	process  string
16: 	nameOnly bool
17: }
18: 
19: func (ps *Process) RuleType() C.RuleType {
20: 	if ps.nameOnly {
21: 		return C.Process
22: 	}
23: 
24: 	return C.ProcessPath
25: }
26: 
27: func (ps *Process) Match(metadata *C.Metadata) bool {
28: 	if ps.nameOnly {
29: 		return strings.EqualFold(filepath.Base(metadata.ProcessPath), ps.process)
30: 	}
31: 
32: 	return strings.EqualFold(metadata.ProcessPath, ps.process)
33: }
34: 
35: func (ps *Process) Adapter() string {
36: 	return ps.adapter
37: }
38: 
39: func (ps *Process) Payload() string {
40: 	return ps.process
41: }
42: 
43: func (ps *Process) ShouldResolveIP() bool {
44: 	return false
45: }
46: 
47: func (ps *Process) ShouldFindProcess() bool {
48: 	return true
49: }
50: 
51: func NewProcess(process string, adapter string, nameOnly bool) (*Process, error) {
52: 	return &Process{
53: 		adapter:  adapter,
54: 		process:  process,
55: 		nameOnly: nameOnly,
56: 	}, nil
57: }


./test\.golangci.yaml
1: linters:
2:   disable-all: true
3:   enable:
4:     - gofumpt
5:     - govet
6:     - gci
7:     - staticcheck
8: 
9: linters-settings:
10:   gci:
11:     sections:
12:       - standard
13:       - default
14:       - prefix(github.com/Dreamacro/clash)
15:   staticcheck:
16:     go: '1.21'


./test\clash_test.go
1: package main
2: 
3: import (
4: 	"context"
5: 	"crypto/md5"
6: 	"crypto/rand"
7: 	"errors"
8: 	"fmt"
9: 	"io"
10: 	"net"
11: 	"net/netip"
12: 	"os"
13: 	"path/filepath"
14: 	"testing"
15: 	"time"
16: 
17: 	"github.com/docker/docker/api/types"
18: 	"github.com/docker/docker/client"
19: 	"github.com/docker/go-connections/nat"
20: 	"github.com/stretchr/testify/assert"
21: 	"github.com/stretchr/testify/require"
22: 
23: 	"github.com/Dreamacro/clash/adapter/outbound"
24: 	C "github.com/Dreamacro/clash/constant"
25: 	"github.com/Dreamacro/clash/hub/executor"
26: 	"github.com/Dreamacro/clash/transport/socks5"
27: )
28: 
29: const (
30: 	ImageShadowsocks     = "mritd/shadowsocks:latest"
31: 	ImageShadowsocksRust = "ghcr.io/shadowsocks/ssserver-rust:latest"
32: 	ImageVmess           = "v2fly/v2fly-core:latest"
33: 	ImageTrojan          = "trojangfw/trojan:latest"
34: 	ImageTrojanGo        = "p4gefau1t/trojan-go:latest"
35: 	ImageSnell           = "ghcr.io/icpz/snell-server:latest"
36: 	ImageXray            = "teddysun/xray:latest"
37: )
38: 
39: var (
40: 	waitTime = time.Second
41: 	localIP  = netip.MustParseAddr("127.0.0.1")
42: 
43: 	defaultExposedPorts = nat.PortSet{
44: 		"10002/tcp": struct{}{},
45: 		"10002/udp": struct{}{},
46: 	}
47: 	defaultPortBindings = nat.PortMap{
48: 		"10002/tcp": []nat.PortBinding{
49: 			{HostPort: "10002", HostIP: "0.0.0.0"},
50: 		},
51: 		"10002/udp": []nat.PortBinding{
52: 			{HostPort: "10002", HostIP: "0.0.0.0"},
53: 		},
54: 	}
55: )
56: 
57: func init() {
58: 	currentDir, err := os.Getwd()
59: 	if err != nil {
60: 		panic(err)
61: 	}
62: 	homeDir := filepath.Join(currentDir, "config")
63: 	C.SetHomeDir(homeDir)
64: 
65: 	c, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
66: 	if err != nil {
67: 		panic(err)
68: 	}
69: 	defer c.Close()
70: 
71: 	list, err := c.ImageList(context.Background(), types.ImageListOptions{All: true})
72: 	if err != nil {
73: 		panic(err)
74: 	}
75: 
76: 	imageExist := func(image string) bool {
77: 		for _, item := range list {
78: 			for _, tag := range item.RepoTags {
79: 				if image == tag {
80: 					return true
81: 				}
82: 			}
83: 		}
84: 		return false
85: 	}
86: 
87: 	images := []string{
88: 		ImageShadowsocks,
89: 		ImageShadowsocksRust,
90: 		ImageVmess,
91: 		ImageTrojan,
92: 		ImageTrojanGo,
93: 		ImageSnell,
94: 		ImageXray,
95: 	}
96: 
97: 	for _, image := range images {
98: 		if imageExist(image) {
99: 			continue
100: 		}
101: 
102: 		println("pulling image:", image)
103: 		imageStream, err := c.ImagePull(context.Background(), image, types.ImagePullOptions{})
104: 		if err != nil {
105: 			panic(err)
106: 		}
107: 
108: 		io.Copy(io.Discard, imageStream)
109: 	}
110: }
111: 
112: var clean = `
113: port: 0
114: socks-port: 0
115: mixed-port: 0
116: redir-port: 0
117: tproxy-port: 0
118: dns:
119: 	enable: false
120: `
121: 
122: func cleanup() {
123: 	parseAndApply(clean)
124: }
125: 
126: func parseAndApply(cfgStr string) error {
127: 	cfg, err := executor.ParseWithBytes([]byte(cfgStr))
128: 	if err != nil {
129: 		return err
130: 	}
131: 
132: 	executor.ApplyConfig(cfg, true)
133: 	return nil
134: }
135: 
136: func newPingPongPair() (chan []byte, chan []byte, func(t *testing.T) error) {
137: 	pingCh := make(chan []byte)
138: 	pongCh := make(chan []byte)
139: 	test := func(t *testing.T) error {
140: 		defer close(pingCh)
141: 		defer close(pongCh)
142: 		pingOpen := false
143: 		pongOpen := false
144: 		var recv []byte
145: 
146: 		for {
147: 			if pingOpen && pongOpen {
148: 				break
149: 			}
150: 
151: 			select {
152: 			case recv, pingOpen = <-pingCh:
153: 				assert.True(t, pingOpen)
154: 				assert.Equal(t, []byte("ping"), recv)
155: 			case recv, pongOpen = <-pongCh:
156: 				assert.True(t, pongOpen)
157: 				assert.Equal(t, []byte("pong"), recv)
158: 			case <-time.After(10 * time.Second):
159: 				return errors.New("timeout")
160: 			}
161: 		}
162: 		return nil
163: 	}
164: 
165: 	return pingCh, pongCh, test
166: }
167: 
168: func newLargeDataPair() (chan hashPair, chan hashPair, func(t *testing.T) error) {
169: 	pingCh := make(chan hashPair)
170: 	pongCh := make(chan hashPair)
171: 	test := func(t *testing.T) error {
172: 		defer close(pingCh)
173: 		defer close(pongCh)
174: 		pingOpen := false
175: 		pongOpen := false
176: 		var serverPair hashPair
177: 		var clientPair hashPair
178: 
179: 		for {
180: 			if pingOpen && pongOpen {
181: 				break
182: 			}
183: 
184: 			select {
185: 			case serverPair, pingOpen = <-pingCh:
186: 				assert.True(t, pingOpen)
187: 			case clientPair, pongOpen = <-pongCh:
188: 				assert.True(t, pongOpen)
189: 			case <-time.After(10 * time.Second):
190: 				return errors.New("timeout")
191: 			}
192: 		}
193: 
194: 		assert.Equal(t, serverPair.recvHash, clientPair.sendHash)
195: 		assert.Equal(t, serverPair.sendHash, clientPair.recvHash)
196: 
197: 		return nil
198: 	}
199: 
200: 	return pingCh, pongCh, test
201: }
202: 
203: func testPingPongWithSocksPort(t *testing.T, port int) error {
204: 	l, err := Listen("tcp", ":10001")
205: 	require.NoError(t, err)
206: 	defer l.Close()
207: 
208: 	pingCh, pongCh, test := newPingPongPair()
209: 	go func() {
210: 		c, err := l.Accept()
211: 		if err != nil {
212: 			return
213: 		}
214: 
215: 		buf := make([]byte, 4)
216: 		if _, err = io.ReadFull(c, buf); err != nil {
217: 			return
218: 		}
219: 
220: 		pingCh <- buf
221: 		if _, err = c.Write([]byte("pong")); err != nil {
222: 			return
223: 		}
224: 	}()
225: 
226: 	go func() {
227: 		c, err := net.Dial("tcp", fmt.Sprintf("127.0.0.1:%d", port))
228: 		require.NoError(t, err)
229: 		defer c.Close()
230: 
231: 		if _, err = socks5.ClientHandshake(c, socks5.ParseAddr("127.0.0.1:10001"), socks5.CmdConnect, nil); err != nil {
232: 			return
233: 		}
234: 
235: 		if _, err = c.Write([]byte("ping")); err != nil {
236: 			return
237: 		}
238: 
239: 		buf := make([]byte, 4)
240: 		if _, err = io.ReadFull(c, buf); err != nil {
241: 			return
242: 		}
243: 
244: 		pongCh <- buf
245: 	}()
246: 
247: 	return test(t)
248: }
249: 
250: func testPingPongWithConn(t *testing.T, c net.Conn) error {
251: 	l, err := Listen("tcp", ":10001")
252: 	if err != nil {
253: 		return err
254: 	}
255: 	defer l.Close()
256: 
257: 	pingCh, pongCh, test := newPingPongPair()
258: 	go func() {
259: 		c, err := l.Accept()
260: 		if err != nil {
261: 			return
262: 		}
263: 
264: 		buf := make([]byte, 4)
265: 		if _, err := io.ReadFull(c, buf); err != nil {
266: 			return
267: 		}
268: 
269: 		pingCh <- buf
270: 		if _, err := c.Write([]byte("pong")); err != nil {
271: 			return
272: 		}
273: 	}()
274: 
275: 	go func() {
276: 		if _, err := c.Write([]byte("ping")); err != nil {
277: 			return
278: 		}
279: 
280: 		buf := make([]byte, 4)
281: 		if _, err := io.ReadFull(c, buf); err != nil {
282: 			return
283: 		}
284: 
285: 		pongCh <- buf
286: 	}()
287: 
288: 	return test(t)
289: }
290: 
291: func testPingPongWithPacketConn(t *testing.T, pc net.PacketConn) error {
292: 	l, err := ListenPacket("udp", ":10001")
293: 	require.NoError(t, err)
294: 	defer l.Close()
295: 
296: 	rAddr := &net.UDPAddr{IP: localIP.AsSlice(), Port: 10001}
297: 
298: 	pingCh, pongCh, test := newPingPongPair()
299: 	go func() {
300: 		buf := make([]byte, 1024)
301: 		n, rAddr, err := l.ReadFrom(buf)
302: 		if err != nil {
303: 			return
304: 		}
305: 
306: 		pingCh <- buf[:n]
307: 		if _, err := l.WriteTo([]byte("pong"), rAddr); err != nil {
308: 			return
309: 		}
310: 	}()
311: 
312: 	go func() {
313: 		if _, err := pc.WriteTo([]byte("ping"), rAddr); err != nil {
314: 			return
315: 		}
316: 
317: 		buf := make([]byte, 1024)
318: 		n, _, err := pc.ReadFrom(buf)
319: 		if err != nil {
320: 			return
321: 		}
322: 
323: 		pongCh <- buf[:n]
324: 	}()
325: 
326: 	return test(t)
327: }
328: 
329: type hashPair struct {
330: 	sendHash map[int][]byte
331: 	recvHash map[int][]byte
332: }
333: 
334: func testLargeDataWithConn(t *testing.T, c net.Conn) error {
335: 	l, err := Listen("tcp", ":10001")
336: 	require.NoError(t, err)
337: 	defer l.Close()
338: 
339: 	times := 100
340: 	chunkSize := int64(64 * 1024)
341: 
342: 	pingCh, pongCh, test := newLargeDataPair()
343: 	writeRandData := func(conn net.Conn) (map[int][]byte, error) {
344: 		buf := make([]byte, chunkSize)
345: 		hashMap := map[int][]byte{}
346: 		for i := 0; i < times; i++ {
347: 			if _, err := rand.Read(buf[1:]); err != nil {
348: 				return nil, err
349: 			}
350: 			buf[0] = byte(i)
351: 
352: 			hash := md5.Sum(buf)
353: 			hashMap[i] = hash[:]
354: 
355: 			if _, err := conn.Write(buf); err != nil {
356: 				return nil, err
357: 			}
358: 		}
359: 
360: 		return hashMap, nil
361: 	}
362: 
363: 	go func() {
364: 		c, err := l.Accept()
365: 		if err != nil {
366: 			return
367: 		}
368: 		defer c.Close()
369: 
370: 		hashMap := map[int][]byte{}
371: 		buf := make([]byte, chunkSize)
372: 
373: 		for i := 0; i < times; i++ {
374: 			_, err := io.ReadFull(c, buf)
375: 			if err != nil {
376: 				t.Log(err.Error())
377: 				return
378: 			}
379: 
380: 			hash := md5.Sum(buf)
381: 			hashMap[int(buf[0])] = hash[:]
382: 		}
383: 
384: 		sendHash, err := writeRandData(c)
385: 		if err != nil {
386: 			t.Log(err.Error())
387: 			return
388: 		}
389: 
390: 		pingCh <- hashPair{
391: 			sendHash: sendHash,
392: 			recvHash: hashMap,
393: 		}
394: 	}()
395: 
396: 	go func() {
397: 		sendHash, err := writeRandData(c)
398: 		if err != nil {
399: 			t.Log(err.Error())
400: 			return
401: 		}
402: 
403: 		hashMap := map[int][]byte{}
404: 		buf := make([]byte, chunkSize)
405: 
406: 		for i := 0; i < times; i++ {
407: 			_, err := io.ReadFull(c, buf)
408: 			if err != nil {
409: 				t.Log(err.Error())
410: 				return
411: 			}
412: 
413: 			hash := md5.Sum(buf)
414: 			hashMap[int(buf[0])] = hash[:]
415: 		}
416: 
417: 		pongCh <- hashPair{
418: 			sendHash: sendHash,
419: 			recvHash: hashMap,
420: 		}
421: 	}()
422: 
423: 	return test(t)
424: }
425: 
426: func testLargeDataWithPacketConn(t *testing.T, pc net.PacketConn) error {
427: 	l, err := ListenPacket("udp", ":10001")
428: 	require.NoError(t, err)
429: 	defer l.Close()
430: 
431: 	rAddr := &net.UDPAddr{IP: localIP.AsSlice(), Port: 10001}
432: 
433: 	times := 50
434: 	chunkSize := int64(1024)
435: 
436: 	pingCh, pongCh, test := newLargeDataPair()
437: 	writeRandData := func(pc net.PacketConn, addr net.Addr) (map[int][]byte, error) {
438: 		hashMap := map[int][]byte{}
439: 		bufs := [][]byte{}
440: 
441: 		for i := 0; i < times; i++ {
442: 			idx := i
443: 			buf := make([]byte, chunkSize)
444: 			rand.Read(buf[1:])
445: 			buf[0] = byte(idx)
446: 
447: 			hash := md5.Sum(buf)
448: 			hashMap[idx] = hash[:]
449: 			bufs = append(bufs, buf)
450: 		}
451: 
452: 		go func() {
453: 			cursor := 0
454: 			for {
455: 				idx := cursor % times
456: 				buf := bufs[idx]
457: 				if _, err := pc.WriteTo(buf, addr); err != nil {
458: 					return
459: 				}
460: 				cursor++
461: 			}
462: 		}()
463: 
464: 		return hashMap, nil
465: 	}
466: 
467: 	go func() {
468: 		var rAddr net.Addr
469: 		hashMap := map[int][]byte{}
470: 		buf := make([]byte, 64*1024)
471: 
472: 		for len(hashMap) != times {
473: 			_, rAddr, err = l.ReadFrom(buf)
474: 			if err != nil {
475: 				return
476: 			}
477: 
478: 			if _, ok := hashMap[int(buf[0])]; !ok {
479: 				hash := md5.Sum(buf[:chunkSize])
480: 				hashMap[int(buf[0])] = hash[:]
481: 			}
482: 		}
483: 
484: 		sendHash, err := writeRandData(l, rAddr)
485: 		if err != nil {
486: 			t.Log(err.Error())
487: 			return
488: 		}
489: 
490: 		pingCh <- hashPair{
491: 			sendHash: sendHash,
492: 			recvHash: hashMap,
493: 		}
494: 	}()
495: 
496: 	go func() {
497: 		sendHash, err := writeRandData(pc, rAddr)
498: 		if err != nil {
499: 			t.Log(err.Error())
500: 			return
501: 		}
502: 
503: 		hashMap := map[int][]byte{}
504: 		buf := make([]byte, 64*1024)
505: 
506: 		for len(hashMap) != times {
507: 			_, _, err := pc.ReadFrom(buf)
508: 			if err != nil {
509: 				return
510: 			}
511: 
512: 			if _, ok := hashMap[int(buf[0])]; !ok {
513: 				hash := md5.Sum(buf[:chunkSize])
514: 				hashMap[int(buf[0])] = hash[:]
515: 			}
516: 		}
517: 
518: 		pongCh <- hashPair{
519: 			sendHash: sendHash,
520: 			recvHash: hashMap,
521: 		}
522: 	}()
523: 
524: 	return test(t)
525: }
526: 
527: func testPacketConnTimeout(t *testing.T, pc net.PacketConn) error {
528: 	err := pc.SetReadDeadline(time.Now().Add(time.Millisecond * 300))
529: 	require.NoError(t, err)
530: 
531: 	errCh := make(chan error, 1)
532: 	go func() {
533: 		buf := make([]byte, 1024)
534: 		_, _, err := pc.ReadFrom(buf)
535: 		errCh <- err
536: 	}()
537: 
538: 	select {
539: 	case <-errCh:
540: 		return nil
541: 	case <-time.After(time.Second * 10):
542: 		return errors.New("timeout")
543: 	}
544: }
545: 
546: func testSuit(t *testing.T, proxy C.ProxyAdapter) {
547: 	conn, err := proxy.DialContext(context.Background(), &C.Metadata{
548: 		Host:    localIP.String(),
549: 		DstPort: 10001,
550: 	})
551: 	require.NoError(t, err)
552: 	defer conn.Close()
553: 	assert.NoError(t, testPingPongWithConn(t, conn))
554: 
555: 	conn, err = proxy.DialContext(context.Background(), &C.Metadata{
556: 		Host:    localIP.String(),
557: 		DstPort: 10001,
558: 	})
559: 	require.NoError(t, err)
560: 	defer conn.Close()
561: 	assert.NoError(t, testLargeDataWithConn(t, conn))
562: 
563: 	if !proxy.SupportUDP() {
564: 		return
565: 	}
566: 
567: 	pc, err := proxy.ListenPacketContext(context.Background(), &C.Metadata{
568: 		NetWork: C.UDP,
569: 		DstIP:   localIP.AsSlice(),
570: 		DstPort: 10001,
571: 	})
572: 	require.NoError(t, err)
573: 	defer pc.Close()
574: 
575: 	assert.NoError(t, testPingPongWithPacketConn(t, pc))
576: 
577: 	pc, err = proxy.ListenPacketContext(context.Background(), &C.Metadata{
578: 		NetWork: C.UDP,
579: 		DstIP:   localIP.AsSlice(),
580: 		DstPort: 10001,
581: 	})
582: 	require.NoError(t, err)
583: 	defer pc.Close()
584: 
585: 	assert.NoError(t, testLargeDataWithPacketConn(t, pc))
586: 
587: 	pc, err = proxy.ListenPacketContext(context.Background(), &C.Metadata{
588: 		NetWork: C.UDP,
589: 		DstIP:   localIP.AsSlice(),
590: 		DstPort: 10001,
591: 	})
592: 	require.NoError(t, err)
593: 	defer pc.Close()
594: 
595: 	assert.NoError(t, testPacketConnTimeout(t, pc))
596: }
597: 
598: func benchmarkProxy(b *testing.B, proxy C.ProxyAdapter) {
599: 	l, err := Listen("tcp", ":10001")
600: 	require.NoError(b, err)
601: 	defer l.Close()
602: 
603: 	chunkSize := int64(16 * 1024)
604: 	chunk := make([]byte, chunkSize)
605: 	rand.Read(chunk)
606: 
607: 	go func() {
608: 		c, err := l.Accept()
609: 		if err != nil {
610: 			return
611: 		}
612: 		defer c.Close()
613: 
614: 		go func() {
615: 			for {
616: 				_, err := c.Write(chunk)
617: 				if err != nil {
618: 					return
619: 				}
620: 			}
621: 		}()
622: 		io.Copy(io.Discard, c)
623: 	}()
624: 
625: 	conn, err := proxy.DialContext(context.Background(), &C.Metadata{
626: 		Host:    localIP.String(),
627: 		DstPort: 10001,
628: 	})
629: 	require.NoError(b, err)
630: 
631: 	_, err = conn.Write([]byte("skip protocol handshake"))
632: 	require.NoError(b, err)
633: 
634: 	b.Run("Write", func(b *testing.B) {
635: 		b.SetBytes(chunkSize)
636: 		for i := 0; i < b.N; i++ {
637: 			conn.Write(chunk)
638: 		}
639: 	})
640: 
641: 	b.Run("Read", func(b *testing.B) {
642: 		b.SetBytes(chunkSize)
643: 		buf := make([]byte, chunkSize)
644: 		for i := 0; i < b.N; i++ {
645: 			io.ReadFull(conn, buf)
646: 		}
647: 	})
648: }
649: 
650: func TestClash_Basic(t *testing.T) {
651: 	basic := `
652: mixed-port: 10000
653: log-level: silent
654: `
655: 
656: 	err := parseAndApply(basic)
657: 	require.NoError(t, err)
658: 	defer cleanup()
659: 
660: 	require.True(t, TCPing(net.JoinHostPort("127.0.0.1", "10000")))
661: 	require.NoError(t, testPingPongWithSocksPort(t, 10000))
662: }
663: 
664: func Benchmark_Direct(b *testing.B) {
665: 	proxy := outbound.NewDirect()
666: 	benchmarkProxy(b, proxy)
667: }


./test\dns_test.go
1: package main
2: 
3: import (
4: 	"testing"
5: 	"time"
6: 
7: 	"github.com/miekg/dns"
8: 	"github.com/stretchr/testify/assert"
9: 	"github.com/stretchr/testify/require"
10: )
11: 
12: func exchange(address, domain string, tp uint16) ([]dns.RR, error) {
13: 	client := dns.Client{}
14: 	query := &dns.Msg{}
15: 	query.SetQuestion(dns.Fqdn(domain), tp)
16: 
17: 	r, _, err := client.Exchange(query, address)
18: 	if err != nil {
19: 		return nil, err
20: 	}
21: 	return r.Answer, nil
22: }
23: 
24: func TestClash_DNS(t *testing.T) {
25: 	basic := `
26: log-level: silent
27: dns:
28:   enable: true
29:   listen: 0.0.0.0:8553
30:   nameserver:
31:     - 119.29.29.29
32: `
33: 
34: 	err := parseAndApply(basic)
35: 	require.NoError(t, err)
36: 	defer cleanup()
37: 
38: 	time.Sleep(waitTime)
39: 
40: 	rr, err := exchange("127.0.0.1:8553", "1.1.1.1.nip.io", dns.TypeA)
41: 	assert.NoError(t, err)
42: 	assert.NotEmptyf(t, rr, "record empty")
43: 
44: 	record := rr[0].(*dns.A)
45: 	assert.Equal(t, record.A.String(), "1.1.1.1")
46: 
47: 	rr, err = exchange("127.0.0.1:8553", "2606-4700-4700--1111.sslip.io", dns.TypeAAAA)
48: 	assert.NoError(t, err)
49: 	assert.Empty(t, rr)
50: }
51: 
52: func TestClash_DNSHostAndFakeIP(t *testing.T) {
53: 	basic := `
54: log-level: silent
55: hosts:
56:   foo.clash.dev: 1.1.1.1
57: dns:
58:   enable: true
59:   listen: 0.0.0.0:8553
60:   ipv6: true
61:   enhanced-mode: fake-ip
62:   fake-ip-range: 198.18.0.1/16
63:   fake-ip-filter:
64:     - .sslip.io
65:   nameserver:
66:     - https://doh.pub/dns-query
67: `
68: 
69: 	err := parseAndApply(basic)
70: 	require.NoError(t, err)
71: 	defer cleanup()
72: 
73: 	time.Sleep(waitTime)
74: 
75: 	type domainPair struct {
76: 		domain string
77: 		ip     string
78: 	}
79: 
80: 	list := []domainPair{
81: 		{"foo.org", "198.18.0.2"},
82: 		{"bar.org", "198.18.0.3"},
83: 		{"foo.org", "198.18.0.2"},
84: 		{"foo.clash.dev", "1.1.1.1"},
85: 	}
86: 
87: 	for _, pair := range list {
88: 		rr, err := exchange("127.0.0.1:8553", pair.domain, dns.TypeA)
89: 		assert.NoError(t, err)
90: 		assert.NotEmpty(t, rr)
91: 
92: 		record := rr[0].(*dns.A)
93: 		assert.Equal(t, record.A.String(), pair.ip)
94: 	}
95: 
96: 	rr, err := exchange("127.0.0.1:8553", "2606-4700-4700--1111.sslip.io", dns.TypeAAAA)
97: 	assert.NoError(t, err)
98: 	assert.NotEmpty(t, rr)
99: 	assert.Equal(t, rr[0].(*dns.AAAA).AAAA.String(), "2606:4700:4700::1111")
100: }


./test\docker_test.go
1: package main
2: 
3: import (
4: 	"context"
5: 
6: 	"github.com/docker/docker/api/types"
7: 	"github.com/docker/docker/api/types/container"
8: 	"github.com/docker/docker/client"
9: )
10: 
11: func startContainer(cfg *container.Config, hostCfg *container.HostConfig, name string) (string, error) {
12: 	c, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
13: 	if err != nil {
14: 		return "", err
15: 	}
16: 	defer c.Close()
17: 
18: 	hostCfg.NetworkMode = "host"
19: 	container, err := c.ContainerCreate(context.Background(), cfg, hostCfg, nil, nil, name)
20: 	if err != nil {
21: 		return "", err
22: 	}
23: 
24: 	if err = c.ContainerStart(context.Background(), container.ID, types.ContainerStartOptions{}); err != nil {
25: 		return "", err
26: 	}
27: 
28: 	return container.ID, nil
29: }
30: 
31: func cleanContainer(id string) error {
32: 	c, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
33: 	if err != nil {
34: 		return err
35: 	}
36: 	defer c.Close()
37: 
38: 	removeOpts := types.ContainerRemoveOptions{Force: true}
39: 	return c.ContainerRemove(context.Background(), id, removeOpts)
40: }


./test\go.mod
1: module clash-test
2: 
3: go 1.21
4: 
5: require (
6: 	github.com/Dreamacro/clash v1.12.0
7: 	github.com/docker/docker v24.0.5+incompatible
8: 	github.com/docker/go-connections v0.4.0
9: 	github.com/miekg/dns v1.1.55
10: 	github.com/stretchr/testify v1.8.4
11: 	go.uber.org/automaxprocs v1.5.3
12: )
13: 
14: replace github.com/Dreamacro/clash => ../
15: 
16: require (
17: 	github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158 // indirect
18: 	github.com/Microsoft/go-winio v0.6.1 // indirect
19: 	github.com/davecgh/go-spew v1.1.1 // indirect
20: 	github.com/dlclark/regexp2 v1.10.0 // indirect
21: 	github.com/docker/distribution v2.8.2+incompatible // indirect
22: 	github.com/docker/go-units v0.5.0 // indirect
23: 	github.com/gofrs/uuid/v5 v5.0.0 // indirect
24: 	github.com/gogo/protobuf v1.3.2 // indirect
25: 	github.com/google/go-cmp v0.5.9 // indirect
26: 	github.com/gorilla/websocket v1.5.0 // indirect
27: 	github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d // indirect
28: 	github.com/josharian/native v1.1.0 // indirect
29: 	github.com/mdlayher/netlink v1.7.2 // indirect
30: 	github.com/mdlayher/socket v0.4.1 // indirect
31: 	github.com/moby/term v0.5.0 // indirect
32: 	github.com/morikuni/aec v1.0.0 // indirect
33: 	github.com/opencontainers/go-digest v1.0.0 // indirect
34: 	github.com/opencontainers/image-spec v1.0.2 // indirect
35: 	github.com/oschwald/geoip2-golang v1.9.0 // indirect
36: 	github.com/oschwald/maxminddb-golang v1.11.0 // indirect
37: 	github.com/pierrec/lz4/v4 v4.1.14 // indirect
38: 	github.com/pkg/errors v0.9.1 // indirect
39: 	github.com/pmezard/go-difflib v1.0.0 // indirect
40: 	github.com/samber/lo v1.38.1 // indirect
41: 	github.com/sirupsen/logrus v1.9.3 // indirect
42: 	github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923 // indirect
43: 	github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01 // indirect
44: 	github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae // indirect
45: 	go.etcd.io/bbolt v1.3.7 // indirect
46: 	go.uber.org/atomic v1.11.0 // indirect
47: 	golang.org/x/crypto v0.12.0 // indirect
48: 	golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 // indirect
49: 	golang.org/x/mod v0.8.0 // indirect
50: 	golang.org/x/net v0.14.0 // indirect
51: 	golang.org/x/sync v0.3.0 // indirect
52: 	golang.org/x/sys v0.11.0 // indirect
53: 	golang.org/x/text v0.12.0 // indirect
54: 	golang.org/x/time v0.3.0 // indirect
55: 	golang.org/x/tools v0.6.0 // indirect
56: 	gopkg.in/yaml.v3 v3.0.1 // indirect
57: 	gotest.tools/v3 v3.4.0 // indirect
58: )


./test\go.sum
1: github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=
2: github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
3: github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158 h1:JFnwKplz9hj8ubqYjm8HkgZS1Rvz9yW+u/XCNNTxr0k=
4: github.com/Dreamacro/protobytes v0.0.0-20230617041236-6500a9f4f158/go.mod h1:QvmEZ/h6KXszPOr2wUFl7Zn3hfFNYdfbXwPVDTyZs6k=
5: github.com/Microsoft/go-winio v0.6.1 h1:9/kr64B9VUZrLm5YYwbGtUJnMgqWVOdUAXu6Migciow=
6: github.com/Microsoft/go-winio v0.6.1/go.mod h1:LRdKpFKfdobln8UmuiYcKPot9D2v6svN5+sAH+4kjUM=
7: github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
8: github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
9: github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
10: github.com/dlclark/regexp2 v1.10.0 h1:+/GIL799phkJqYW+3YbOd8LCcbHzT0Pbo8zl70MHsq0=
11: github.com/dlclark/regexp2 v1.10.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=
12: github.com/docker/distribution v2.8.2+incompatible h1:T3de5rq0dB1j30rp0sA2rER+m322EBzniBPB6ZIzuh8=
13: github.com/docker/distribution v2.8.2+incompatible/go.mod h1:J2gT2udsDAN96Uj4KfcMRqY0/ypR+oyYUYmja8H+y+w=
14: github.com/docker/docker v24.0.5+incompatible h1:WmgcE4fxyI6EEXxBRxsHnZXrO1pQ3smi0k/jho4HLeY=
15: github.com/docker/docker v24.0.5+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
16: github.com/docker/go-connections v0.4.0 h1:El9xVISelRB7BuFusrZozjnkIM5YnzCViNKohAFqRJQ=
17: github.com/docker/go-connections v0.4.0/go.mod h1:Gbd7IOopHjR8Iph03tsViu4nIes5XhDvyHbTtUxmeec=
18: github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
19: github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
20: github.com/gofrs/uuid/v5 v5.0.0 h1:p544++a97kEL+svbcFbCQVM9KFu0Yo25UoISXGNNH9M=
21: github.com/gofrs/uuid/v5 v5.0.0/go.mod h1:CDOjlDMVAtN56jqyRUZh58JT31Tiw7/oQyEXZV+9bD8=
22: github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
23: github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
24: github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
25: github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=
26: github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
27: github.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=
28: github.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
29: github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d h1:Ka64cclWedOkGzm9M2/XYuwJUdmWRUozmsxW0PyKA3A=
30: github.com/insomniacslk/dhcp v0.0.0-20230816195147-b3ca2534940d/go.mod h1:7474bZ1YNCvarT6WFKie4kEET6J0KYRDC4XJqqXzQW4=
31: github.com/josharian/native v1.0.1-0.20221213033349-c1e37c09b531/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=
32: github.com/josharian/native v1.1.0 h1:uuaP0hAbW7Y4l0ZRQ6C9zfb7Mg1mbFKry/xzDAfmtLA=
33: github.com/josharian/native v1.1.0/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=
34: github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
35: github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
36: github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
37: github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
38: github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
39: github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
40: github.com/mdlayher/netlink v1.7.2 h1:/UtM3ofJap7Vl4QWCPDGXY8d3GIY2UGSDbK+QWmY8/g=
41: github.com/mdlayher/netlink v1.7.2/go.mod h1:xraEF7uJbxLhc5fpHL4cPe221LI2bdttWlU+ZGLfQSw=
42: github.com/mdlayher/socket v0.4.1 h1:eM9y2/jlbs1M615oshPQOHZzj6R6wMT7bX5NPiQvn2U=
43: github.com/mdlayher/socket v0.4.1/go.mod h1:cAqeGjoufqdxWkD7DkpyS+wcefOtmu5OQ8KuoJGIReA=
44: github.com/miekg/dns v1.1.55 h1:GoQ4hpsj0nFLYe+bWiCToyrBEJXkQfOOIvFGFy0lEgo=
45: github.com/miekg/dns v1.1.55/go.mod h1:uInx36IzPl7FYnDcMeVWxj9byh7DutNykX4G9Sj60FY=
46: github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
47: github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
48: github.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=
49: github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
50: github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
51: github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
52: github.com/opencontainers/image-spec v1.0.2 h1:9yCKha/T5XdGtO0q9Q9a6T5NUCsTn/DrBg0D7ufOcFM=
53: github.com/opencontainers/image-spec v1.0.2/go.mod h1:BtxoFyWECRxE4U/7sNtV5W15zMzWCbyJoFRP3s7yZA0=
54: github.com/oschwald/geoip2-golang v1.9.0 h1:uvD3O6fXAXs+usU+UGExshpdP13GAqp4GBrzN7IgKZc=
55: github.com/oschwald/geoip2-golang v1.9.0/go.mod h1:BHK6TvDyATVQhKNbQBdrj9eAvuwOMi2zSFXizL3K81Y=
56: github.com/oschwald/maxminddb-golang v1.11.0 h1:aSXMqYR/EPNjGE8epgqwDay+P30hCBZIveY0WZbAWh0=
57: github.com/oschwald/maxminddb-golang v1.11.0/go.mod h1:YmVI+H0zh3ySFR3w+oz8PCfglAFj3PuCmui13+P9zDg=
58: github.com/pierrec/lz4/v4 v4.1.14 h1:+fL8AQEZtz/ijeNnpduH0bROTu0O3NZAlPjQxGn8LwE=
59: github.com/pierrec/lz4/v4 v4.1.14/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=
60: github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
61: github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
62: github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
63: github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
64: github.com/prashantv/gostub v1.1.0 h1:BTyx3RfQjRHnUWaGF9oQos79AlQ5k8WNktv7VGvVH4g=
65: github.com/prashantv/gostub v1.1.0/go.mod h1:A5zLQHz7ieHGG7is6LLXLz7I8+3LZzsrV0P1IAHhP5U=
66: github.com/samber/lo v1.38.1 h1:j2XEAqXKb09Am4ebOg31SpvzUTTs6EN3VfgeLUhPdXM=
67: github.com/samber/lo v1.38.1/go.mod h1:+m/ZKRl6ClXCE2Lgf3MsQlWfh4bn1bz6CXEOxnEXnEA=
68: github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
69: github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
70: github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
71: github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
72: github.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=
73: github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
74: github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923 h1:tHNk7XK9GkmKUR6Gh8gVBKXc2MVSZ4G/NnWLtzw4gNA=
75: github.com/u-root/uio v0.0.0-20230220225925-ffce2a382923/go.mod h1:eLL9Nub3yfAho7qB0MzZizFhTU2QkLeoVsWdHtDW264=
76: github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01 h1:F9xjJm4IH8VjcqG4ujciOF+GIM4mjPkHhWLLzOghPtM=
77: github.com/vishvananda/netlink v1.2.1-beta.2.0.20230420174744-55c8b9515a01/go.mod h1:cAAsePK2e15YDAMJNyOpGYEWNe4sIghTY7gpz4cX/Ik=
78: github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae h1:4hwBBUfQCFe3Cym0ZtKyq7L16eZUtYKs+BaHDN6mAns=
79: github.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae/go.mod h1:DD4vA1DwXk04H54A1oHXtwZmA0grkVMdPxx/VGLCah0=
80: github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
81: github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
82: go.etcd.io/bbolt v1.3.7 h1:j+zJOnnEjF/kyHlDDgGnVL/AIqIJPq8UoB2GSNfkUfQ=
83: go.etcd.io/bbolt v1.3.7/go.mod h1:N9Mkw9X8x5fupy0IKsmuqVtoGDyxsaDlbk4Rd05IAQw=
84: go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
85: go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
86: go.uber.org/automaxprocs v1.5.3 h1:kWazyxZUrS3Gs4qUpbwo5kEIMGe/DAvi5Z4tl2NW4j8=
87: go.uber.org/automaxprocs v1.5.3/go.mod h1:eRbA25aqJrxAbsLO0xy5jVwPt7FQnRgjW+efnwa1WM0=
88: golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
89: golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
90: golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
91: golang.org/x/crypto v0.12.0 h1:tFM/ta59kqch6LlvYnPa0yx5a83cL2nHflFhYKvv9Yk=
92: golang.org/x/crypto v0.12.0/go.mod h1:NF0Gs7EO5K4qLn+Ylc+fih8BSTeIjAP05siRnAh98yw=
93: golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 h1:3MTrJm4PyNL9NBqvYDSj3DHl46qQakyfqfWo4jgfaEM=
94: golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17/go.mod h1:lgLbSvA5ygNOMpwM/9anMpWVlVJ7Z+cHWq/eFuinpGE=
95: golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
96: golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
97: golang.org/x/mod v0.8.0 h1:LUYupSeNrTNCGzR/hVBk2NHZO4hXcVaW1k4Qx7rjPx8=
98: golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
99: golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
100: golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
101: golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
102: golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
103: golang.org/x/net v0.14.0 h1:BONx9s002vGdD9umnlX1Po8vOZmrgH34qlHcD1MfK14=
104: golang.org/x/net v0.14.0/go.mod h1:PpSgVXXLK0OxS0F31C1/tv6XNguvCrnXIDrFMspZIUI=
105: golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
106: golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
107: golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
108: golang.org/x/sync v0.3.0 h1:ftCYgMx6zT/asHUrPw8BLLscYtGznsLAnjq5RH9P66E=
109: golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
110: golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
111: golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
112: golang.org/x/sys v0.0.0-20200217220822-9197077df867/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
113: golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
114: golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
115: golang.org/x/sys v0.0.0-20220622161953-175b2fd9d664/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
116: golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
117: golang.org/x/sys v0.0.0-20220804214406-8e32c043e418/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
118: golang.org/x/sys v0.11.0 h1:eG7RXZHdqOJ1i+0lgLgCpSXAp6M3LYlAo6osgSi0xOM=
119: golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
120: golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
121: golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
122: golang.org/x/text v0.12.0 h1:k+n5B8goJNdU7hSvEtMUz3d1Q6D/XW4COJSJR6fN0mc=
123: golang.org/x/text v0.12.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
124: golang.org/x/time v0.3.0 h1:rg5rLMjNzMS1RkNLzCG38eapWhnYLFYXDXj2gOlr8j4=
125: golang.org/x/time v0.3.0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
126: golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
127: golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
128: golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
129: golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
130: golang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=
131: golang.org/x/tools v0.6.0 h1:BOw41kyTf3PuCW1pVQf8+Cyg8pMlkYB1oo9iJ6D/lKM=
132: golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
133: golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
134: golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
135: golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
136: golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
137: gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
138: gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
139: gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
140: gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
141: gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
142: gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
143: gotest.tools/v3 v3.4.0 h1:ZazjZUfuVeZGLAmlKKuyv3IKP5orXcwtOwDQH6YVr6o=
144: gotest.tools/v3 v3.4.0/go.mod h1:CtbdzLSsqVhDgMtKsx03ird5YTGB3ar27v0u/yKBW5g=


./test\listener_test.go
1: package main
2: 
3: import (
4: 	"net"
5: 	"strconv"
6: 	"testing"
7: 	"time"
8: 
9: 	C "github.com/Dreamacro/clash/constant"
10: 	"github.com/Dreamacro/clash/listener"
11: 	"github.com/Dreamacro/clash/tunnel"
12: 
13: 	"github.com/stretchr/testify/require"
14: )
15: 
16: func TestClash_Listener(t *testing.T) {
17: 	basic := `
18: log-level: silent
19: port: 7890
20: socks-port: 7891
21: redir-port: 7892
22: tproxy-port: 7893
23: mixed-port: 7894
24: `
25: 
26: 	err := parseAndApply(basic)
27: 	require.NoError(t, err)
28: 	defer cleanup()
29: 
30: 	time.Sleep(waitTime)
31: 
32: 	for i := 7890; i <= 7894; i++ {
33: 		require.True(t, TCPing(net.JoinHostPort("127.0.0.1", strconv.Itoa(i))), "tcp port %d", i)
34: 	}
35: }
36: 
37: func TestClash_ListenerCreate(t *testing.T) {
38: 	basic := `
39: log-level: silent
40: `
41: 	err := parseAndApply(basic)
42: 	require.NoError(t, err)
43: 	defer cleanup()
44: 
45: 	time.Sleep(waitTime)
46: 	tcpIn := tunnel.TCPIn()
47: 	udpIn := tunnel.UDPIn()
48: 
49: 	ports := listener.Ports{
50: 		Port: 7890,
51: 	}
52: 	listener.ReCreatePortsListeners(ports, tcpIn, udpIn)
53: 	require.True(t, TCPing("127.0.0.1:7890"))
54: 	require.Equal(t, ports, *listener.GetPorts())
55: 
56: 	inbounds := []C.Inbound{
57: 		{
58: 			Type:        C.InboundTypeHTTP,
59: 			BindAddress: "127.0.0.1:7891",
60: 		},
61: 	}
62: 	listener.ReCreateListeners(inbounds, tcpIn, udpIn)
63: 	require.True(t, TCPing("127.0.0.1:7890"))
64: 	require.Equal(t, ports, *listener.GetPorts())
65: 
66: 	require.True(t, TCPing("127.0.0.1:7891"))
67: 	require.Equal(t, len(inbounds), len(listener.GetInbounds()))
68: 
69: 	ports.Port = 0
70: 	ports.SocksPort = 7892
71: 	listener.ReCreatePortsListeners(ports, tcpIn, udpIn)
72: 	require.False(t, TCPing("127.0.0.1:7890"))
73: 	require.True(t, TCPing("127.0.0.1:7892"))
74: 	require.Equal(t, ports, *listener.GetPorts())
75: 
76: 	require.True(t, TCPing("127.0.0.1:7891"))
77: 	require.Equal(t, len(inbounds), len(listener.GetInbounds()))
78: }


./test\main.go
1: package main
2: 
3: import (
4: 	"os"
5: 	"runtime"
6: 	"strconv"
7: 
8: 	"go.uber.org/automaxprocs/maxprocs"
9: )
10: 
11: func main() {
12: 	maxprocs.Set(maxprocs.Logger(func(string, ...any) {}))
13: 	os.Stdout.Write([]byte(strconv.FormatInt(int64(runtime.GOMAXPROCS(0)), 10)))
14: }


./test\Makefile
1: lint:
2: 	GOOS=darwin golangci-lint run --fix ./...
3: 	GOOS=linux golangci-lint run --fix ./...
4: 
5: test:
6: 	go test -p 1 -v ./...
7: 
8: benchmark:
9: 	go test -benchmem -run=^$$ -bench .


./test\README.md
1: ## Clash testing suit
2: 
3: ### Protocol testing suit
4: 
5: * TCP pingpong test
6: * UDP pingpong test
7: * TCP large data test
8: * UDP large data test
9: 
10: ### Protocols
11: 
12: - [x] Shadowsocks
13:   - [x] Normal
14:   - [x] ObfsHTTP
15:   - [x] ObfsTLS
16:   - [x] ObfsV2rayPlugin
17: - [x] Vmess
18:   - [x] Normal
19:   - [x] AEAD
20:   - [x] HTTP
21:   - [x] HTTP2
22:   - [x] TLS
23:   - [x] Websocket
24:   - [x] Websocket TLS
25:   - [x] gRPC
26: - [x] Trojan
27:   - [x] Normal
28:   - [x] gRPC
29: - [x] Snell
30:   - [x] Normal
31:   - [x] ObfsHTTP
32:   - [x] ObfsTLS
33: 
34: ### Features
35: 
36: - [ ] DNS
37:   - [x] DNS Server
38:   - [x] FakeIP
39:   - [x] Host
40: 
41: ### Command
42: 
43: Prerequisite
44: 
45: * docker (support Linux and macOS)
46: 
47: ```
48: $ make test
49: ```
50: 
51: benchmark (Linux)
52: 
53: > Cannot represent the throughput of the protocol on your machine
54: > but you can compare the corresponding throughput of the protocol on clash
55: > (change chunkSize to measure the maximum throughput of clash on your machine)
56: 
57: ```
58: $ make benchmark
59: ```


./test\rule_test.go
1: package main
2: 
3: import (
4: 	"net"
5: 	"testing"
6: 
7: 	"github.com/stretchr/testify/require"
8: )
9: 
10: func TestClash_RuleInbound(t *testing.T) {
11: 	basic := `
12: socks-port: 7890
13: inbounds:
14:   - socks://127.0.0.1:7891
15:   - type: socks
16:     bind-address: 127.0.0.1:7892
17: rules:
18:   - INBOUND-PORT,7891,REJECT
19: log-level: silent
20: `
21: 
22: 	err := parseAndApply(basic)
23: 	require.NoError(t, err)
24: 	defer cleanup()
25: 
26: 	require.True(t, TCPing(net.JoinHostPort("127.0.0.1", "7890")))
27: 	require.True(t, TCPing(net.JoinHostPort("127.0.0.1", "7891")))
28: 	require.True(t, TCPing(net.JoinHostPort("127.0.0.1", "7892")))
29: 
30: 	require.Error(t, testPingPongWithSocksPort(t, 7891))
31: 	require.NoError(t, testPingPongWithSocksPort(t, 7890))
32: 	require.NoError(t, testPingPongWithSocksPort(t, 7892))
33: }


./test\snell_test.go
1: package main
2: 
3: import (
4: 	"fmt"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/docker/docker/api/types/container"
9: 	"github.com/stretchr/testify/require"
10: 
11: 	"github.com/Dreamacro/clash/adapter/outbound"
12: 	C "github.com/Dreamacro/clash/constant"
13: )
14: 
15: func TestClash_SnellObfsHTTP(t *testing.T) {
16: 	cfg := &container.Config{
17: 		Image:        ImageSnell,
18: 		ExposedPorts: defaultExposedPorts,
19: 		Cmd:          []string{"-c", "/config.conf"},
20: 	}
21: 	hostCfg := &container.HostConfig{
22: 		PortBindings: defaultPortBindings,
23: 		Binds:        []string{fmt.Sprintf("%s:/config.conf", C.Path.Resolve("snell-http.conf"))},
24: 	}
25: 
26: 	id, err := startContainer(cfg, hostCfg, "snell-http")
27: 	require.NoError(t, err)
28: 
29: 	t.Cleanup(func() {
30: 		cleanContainer(id)
31: 	})
32: 
33: 	proxy, err := outbound.NewSnell(outbound.SnellOption{
34: 		Name:   "snell",
35: 		Server: localIP.String(),
36: 		Port:   10002,
37: 		Psk:    "password",
38: 		ObfsOpts: map[string]any{
39: 			"mode": "http",
40: 		},
41: 	})
42: 	require.NoError(t, err)
43: 
44: 	time.Sleep(waitTime)
45: 	testSuit(t, proxy)
46: }
47: 
48: func TestClash_SnellObfsTLS(t *testing.T) {
49: 	cfg := &container.Config{
50: 		Image:        ImageSnell,
51: 		ExposedPorts: defaultExposedPorts,
52: 		Cmd:          []string{"-c", "/config.conf"},
53: 	}
54: 	hostCfg := &container.HostConfig{
55: 		PortBindings: defaultPortBindings,
56: 		Binds:        []string{fmt.Sprintf("%s:/config.conf", C.Path.Resolve("snell-tls.conf"))},
57: 	}
58: 
59: 	id, err := startContainer(cfg, hostCfg, "snell-tls")
60: 	require.NoError(t, err)
61: 
62: 	t.Cleanup(func() {
63: 		cleanContainer(id)
64: 	})
65: 
66: 	proxy, err := outbound.NewSnell(outbound.SnellOption{
67: 		Name:   "snell",
68: 		Server: localIP.String(),
69: 		Port:   10002,
70: 		Psk:    "password",
71: 		ObfsOpts: map[string]any{
72: 			"mode": "tls",
73: 		},
74: 	})
75: 	require.NoError(t, err)
76: 
77: 	time.Sleep(waitTime)
78: 	testSuit(t, proxy)
79: }
80: 
81: func TestClash_Snell(t *testing.T) {
82: 	cfg := &container.Config{
83: 		Image:        ImageSnell,
84: 		ExposedPorts: defaultExposedPorts,
85: 		Cmd:          []string{"-c", "/config.conf"},
86: 	}
87: 	hostCfg := &container.HostConfig{
88: 		PortBindings: defaultPortBindings,
89: 		Binds:        []string{fmt.Sprintf("%s:/config.conf", C.Path.Resolve("snell.conf"))},
90: 	}
91: 
92: 	id, err := startContainer(cfg, hostCfg, "snell")
93: 	require.NoError(t, err)
94: 
95: 	t.Cleanup(func() {
96: 		cleanContainer(id)
97: 	})
98: 
99: 	proxy, err := outbound.NewSnell(outbound.SnellOption{
100: 		Name:   "snell",
101: 		Server: localIP.String(),
102: 		Port:   10002,
103: 		Psk:    "password",
104: 	})
105: 	require.NoError(t, err)
106: 
107: 	time.Sleep(waitTime)
108: 	testSuit(t, proxy)
109: }
110: 
111: func TestClash_Snellv3(t *testing.T) {
112: 	cfg := &container.Config{
113: 		Image:        ImageSnell,
114: 		ExposedPorts: defaultExposedPorts,
115: 		Cmd:          []string{"-c", "/config.conf"},
116: 	}
117: 	hostCfg := &container.HostConfig{
118: 		PortBindings: defaultPortBindings,
119: 		Binds:        []string{fmt.Sprintf("%s:/config.conf", C.Path.Resolve("snell.conf"))},
120: 	}
121: 
122: 	id, err := startContainer(cfg, hostCfg, "snell")
123: 	require.NoError(t, err)
124: 
125: 	t.Cleanup(func() {
126: 		cleanContainer(id)
127: 	})
128: 
129: 	proxy, err := outbound.NewSnell(outbound.SnellOption{
130: 		Name:    "snell",
131: 		Server:  localIP.String(),
132: 		Port:    10002,
133: 		Psk:     "password",
134: 		UDP:     true,
135: 		Version: 3,
136: 	})
137: 	require.NoError(t, err)
138: 
139: 	time.Sleep(waitTime)
140: 	testSuit(t, proxy)
141: }
142: 
143: func Benchmark_Snell(b *testing.B) {
144: 	cfg := &container.Config{
145: 		Image:        ImageSnell,
146: 		ExposedPorts: defaultExposedPorts,
147: 		Cmd:          []string{"-c", "/config.conf"},
148: 	}
149: 	hostCfg := &container.HostConfig{
150: 		PortBindings: defaultPortBindings,
151: 		Binds:        []string{fmt.Sprintf("%s:/config.conf", C.Path.Resolve("snell-http.conf"))},
152: 	}
153: 
154: 	id, err := startContainer(cfg, hostCfg, "snell-bench")
155: 	require.NoError(b, err)
156: 
157: 	b.Cleanup(func() {
158: 		cleanContainer(id)
159: 	})
160: 
161: 	proxy, err := outbound.NewSnell(outbound.SnellOption{
162: 		Name:   "snell",
163: 		Server: localIP.String(),
164: 		Port:   10002,
165: 		Psk:    "password",
166: 		ObfsOpts: map[string]any{
167: 			"mode": "http",
168: 		},
169: 	})
170: 	require.NoError(b, err)
171: 
172: 	time.Sleep(waitTime)
173: 	benchmarkProxy(b, proxy)
174: }


./test\ss_test.go
1: package main
2: 
3: import (
4: 	"net"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/docker/docker/api/types/container"
9: 	"github.com/stretchr/testify/require"
10: 
11: 	"github.com/Dreamacro/clash/adapter/outbound"
12: )
13: 
14: func TestClash_Shadowsocks(t *testing.T) {
15: 	cfg := &container.Config{
16: 		Image:        ImageShadowsocksRust,
17: 		Entrypoint:   []string{"ssserver"},
18: 		Cmd:          []string{"-s", "0.0.0.0:10002", "-m", "chacha20-ietf-poly1305", "-k", "FzcLbKs2dY9mhL", "-U"},
19: 		ExposedPorts: defaultExposedPorts,
20: 	}
21: 	hostCfg := &container.HostConfig{
22: 		PortBindings: defaultPortBindings,
23: 	}
24: 
25: 	id, err := startContainer(cfg, hostCfg, "ss")
26: 	require.NoError(t, err)
27: 
28: 	t.Cleanup(func() {
29: 		cleanContainer(id)
30: 	})
31: 
32: 	proxy, err := outbound.NewShadowSocks(outbound.ShadowSocksOption{
33: 		Name:     "ss",
34: 		Server:   localIP.String(),
35: 		Port:     10002,
36: 		Password: "FzcLbKs2dY9mhL",
37: 		Cipher:   "chacha20-ietf-poly1305",
38: 		UDP:      true,
39: 	})
40: 	require.NoError(t, err)
41: 
42: 	time.Sleep(waitTime)
43: 	testSuit(t, proxy)
44: }
45: 
46: func TestClash_ShadowsocksObfsHTTP(t *testing.T) {
47: 	cfg := &container.Config{
48: 		Image: ImageShadowsocks,
49: 		Env: []string{
50: 			"SS_MODULE=ss-server",
51: 			"SS_CONFIG=-s 0.0.0.0 -u -p 10002 -m chacha20-ietf-poly1305 -k FzcLbKs2dY9mhL --plugin obfs-server --plugin-opts obfs=http",
52: 		},
53: 		ExposedPorts: defaultExposedPorts,
54: 	}
55: 	hostCfg := &container.HostConfig{
56: 		PortBindings: defaultPortBindings,
57: 	}
58: 
59: 	id, err := startContainer(cfg, hostCfg, "ss-obfs-http")
60: 	require.NoError(t, err)
61: 
62: 	t.Cleanup(func() {
63: 		cleanContainer(id)
64: 	})
65: 
66: 	proxy, err := outbound.NewShadowSocks(outbound.ShadowSocksOption{
67: 		Name:     "ss",
68: 		Server:   localIP.String(),
69: 		Port:     10002,
70: 		Password: "FzcLbKs2dY9mhL",
71: 		Cipher:   "chacha20-ietf-poly1305",
72: 		UDP:      true,
73: 		Plugin:   "obfs",
74: 		PluginOpts: map[string]any{
75: 			"mode": "http",
76: 		},
77: 	})
78: 	require.NoError(t, err)
79: 
80: 	time.Sleep(waitTime)
81: 	testSuit(t, proxy)
82: }
83: 
84: func TestClash_ShadowsocksObfsTLS(t *testing.T) {
85: 	cfg := &container.Config{
86: 		Image: ImageShadowsocks,
87: 		Env: []string{
88: 			"SS_MODULE=ss-server",
89: 			"SS_CONFIG=-s 0.0.0.0 -u -p 10002 -m chacha20-ietf-poly1305 -k FzcLbKs2dY9mhL --plugin obfs-server --plugin-opts obfs=tls",
90: 		},
91: 		ExposedPorts: defaultExposedPorts,
92: 	}
93: 	hostCfg := &container.HostConfig{
94: 		PortBindings: defaultPortBindings,
95: 	}
96: 
97: 	id, err := startContainer(cfg, hostCfg, "ss-obfs-tls")
98: 	require.NoError(t, err)
99: 
100: 	t.Cleanup(func() {
101: 		cleanContainer(id)
102: 	})
103: 
104: 	proxy, err := outbound.NewShadowSocks(outbound.ShadowSocksOption{
105: 		Name:     "ss",
106: 		Server:   localIP.String(),
107: 		Port:     10002,
108: 		Password: "FzcLbKs2dY9mhL",
109: 		Cipher:   "chacha20-ietf-poly1305",
110: 		UDP:      true,
111: 		Plugin:   "obfs",
112: 		PluginOpts: map[string]any{
113: 			"mode": "tls",
114: 		},
115: 	})
116: 	require.NoError(t, err)
117: 
118: 	time.Sleep(waitTime)
119: 	testSuit(t, proxy)
120: }
121: 
122: func TestClash_ShadowsocksV2RayPlugin(t *testing.T) {
123: 	cfg := &container.Config{
124: 		Image: ImageShadowsocks,
125: 		Env: []string{
126: 			"SS_MODULE=ss-server",
127: 			"SS_CONFIG=-s 0.0.0.0 -u -p 10002 -m chacha20-ietf-poly1305 -k FzcLbKs2dY9mhL --plugin v2ray-plugin --plugin-opts=server",
128: 		},
129: 		ExposedPorts: defaultExposedPorts,
130: 	}
131: 	hostCfg := &container.HostConfig{
132: 		PortBindings: defaultPortBindings,
133: 	}
134: 
135: 	id, err := startContainer(cfg, hostCfg, "ss-v2ray-plugin")
136: 	require.NoError(t, err)
137: 
138: 	t.Cleanup(func() {
139: 		cleanContainer(id)
140: 	})
141: 
142: 	proxy, err := outbound.NewShadowSocks(outbound.ShadowSocksOption{
143: 		Name:     "ss",
144: 		Server:   localIP.String(),
145: 		Port:     10002,
146: 		Password: "FzcLbKs2dY9mhL",
147: 		Cipher:   "chacha20-ietf-poly1305",
148: 		UDP:      true,
149: 		Plugin:   "v2ray-plugin",
150: 		PluginOpts: map[string]any{
151: 			"mode": "websocket",
152: 		},
153: 	})
154: 	require.NoError(t, err)
155: 
156: 	time.Sleep(waitTime)
157: 	testSuit(t, proxy)
158: }
159: 
160: func Benchmark_Shadowsocks(b *testing.B) {
161: 	cfg := &container.Config{
162: 		Image:        ImageShadowsocksRust,
163: 		Entrypoint:   []string{"ssserver"},
164: 		Cmd:          []string{"-s", "0.0.0.0:10002", "-m", "aes-256-gcm", "-k", "FzcLbKs2dY9mhL", "-U"},
165: 		ExposedPorts: defaultExposedPorts,
166: 	}
167: 	hostCfg := &container.HostConfig{
168: 		PortBindings: defaultPortBindings,
169: 	}
170: 
171: 	id, err := startContainer(cfg, hostCfg, "ss-bench")
172: 	require.NoError(b, err)
173: 
174: 	b.Cleanup(func() {
175: 		cleanContainer(id)
176: 	})
177: 
178: 	proxy, err := outbound.NewShadowSocks(outbound.ShadowSocksOption{
179: 		Name:     "ss",
180: 		Server:   localIP.String(),
181: 		Port:     10002,
182: 		Password: "FzcLbKs2dY9mhL",
183: 		Cipher:   "aes-256-gcm",
184: 		UDP:      true,
185: 	})
186: 	require.NoError(b, err)
187: 
188: 	require.True(b, TCPing(net.JoinHostPort(localIP.String(), "10002")))
189: 	benchmarkProxy(b, proxy)
190: }


./test\trojan_test.go
1: package main
2: 
3: import (
4: 	"fmt"
5: 	"net"
6: 	"testing"
7: 	"time"
8: 
9: 	"github.com/docker/docker/api/types/container"
10: 	"github.com/stretchr/testify/require"
11: 
12: 	"github.com/Dreamacro/clash/adapter/outbound"
13: 	C "github.com/Dreamacro/clash/constant"
14: )
15: 
16: func TestClash_Trojan(t *testing.T) {
17: 	cfg := &container.Config{
18: 		Image:        ImageTrojan,
19: 		ExposedPorts: defaultExposedPorts,
20: 	}
21: 	hostCfg := &container.HostConfig{
22: 		PortBindings: defaultPortBindings,
23: 		Binds: []string{
24: 			fmt.Sprintf("%s:/config/config.json", C.Path.Resolve("trojan.json")),
25: 			fmt.Sprintf("%s:/path/to/certificate.crt", C.Path.Resolve("example.org.pem")),
26: 			fmt.Sprintf("%s:/path/to/private.key", C.Path.Resolve("example.org-key.pem")),
27: 		},
28: 	}
29: 
30: 	id, err := startContainer(cfg, hostCfg, "trojan")
31: 	require.NoError(t, err)
32: 
33: 	t.Cleanup(func() {
34: 		cleanContainer(id)
35: 	})
36: 
37: 	proxy, err := outbound.NewTrojan(outbound.TrojanOption{
38: 		Name:           "trojan",
39: 		Server:         localIP.String(),
40: 		Port:           10002,
41: 		Password:       "password",
42: 		SNI:            "example.org",
43: 		SkipCertVerify: true,
44: 		UDP:            true,
45: 	})
46: 	require.NoError(t, err)
47: 
48: 	time.Sleep(waitTime)
49: 	testSuit(t, proxy)
50: }
51: 
52: func TestClash_TrojanGrpc(t *testing.T) {
53: 	cfg := &container.Config{
54: 		Image:        ImageXray,
55: 		ExposedPorts: defaultExposedPorts,
56: 	}
57: 	hostCfg := &container.HostConfig{
58: 		PortBindings: defaultPortBindings,
59: 		Binds: []string{
60: 			fmt.Sprintf("%s:/etc/xray/config.json", C.Path.Resolve("trojan-grpc.json")),
61: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
62: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
63: 		},
64: 	}
65: 
66: 	id, err := startContainer(cfg, hostCfg, "trojan-grpc")
67: 	require.NoError(t, err)
68: 	t.Cleanup(func() {
69: 		cleanContainer(id)
70: 	})
71: 
72: 	proxy, err := outbound.NewTrojan(outbound.TrojanOption{
73: 		Name:           "trojan",
74: 		Server:         localIP.String(),
75: 		Port:           10002,
76: 		Password:       "example",
77: 		SNI:            "example.org",
78: 		SkipCertVerify: true,
79: 		UDP:            true,
80: 		Network:        "grpc",
81: 		GrpcOpts: outbound.GrpcOptions{
82: 			GrpcServiceName: "example",
83: 		},
84: 	})
85: 	require.NoError(t, err)
86: 
87: 	time.Sleep(waitTime)
88: 	testSuit(t, proxy)
89: }
90: 
91: func TestClash_TrojanWebsocket(t *testing.T) {
92: 	cfg := &container.Config{
93: 		Image:        ImageTrojanGo,
94: 		ExposedPorts: defaultExposedPorts,
95: 	}
96: 	hostCfg := &container.HostConfig{
97: 		PortBindings: defaultPortBindings,
98: 		Binds: []string{
99: 			fmt.Sprintf("%s:/etc/trojan-go/config.json", C.Path.Resolve("trojan-ws.json")),
100: 			fmt.Sprintf("%s:/fullchain.pem", C.Path.Resolve("example.org.pem")),
101: 			fmt.Sprintf("%s:/privkey.pem", C.Path.Resolve("example.org-key.pem")),
102: 		},
103: 	}
104: 
105: 	id, err := startContainer(cfg, hostCfg, "trojan-ws")
106: 	require.NoError(t, err)
107: 	t.Cleanup(func() {
108: 		cleanContainer(id)
109: 	})
110: 
111: 	proxy, err := outbound.NewTrojan(outbound.TrojanOption{
112: 		Name:           "trojan",
113: 		Server:         localIP.String(),
114: 		Port:           10002,
115: 		Password:       "example",
116: 		SNI:            "example.org",
117: 		SkipCertVerify: true,
118: 		UDP:            true,
119: 		Network:        "ws",
120: 	})
121: 	require.NoError(t, err)
122: 
123: 	time.Sleep(waitTime)
124: 	testSuit(t, proxy)
125: }
126: 
127: func Benchmark_Trojan(b *testing.B) {
128: 	cfg := &container.Config{
129: 		Image:        ImageTrojan,
130: 		ExposedPorts: defaultExposedPorts,
131: 	}
132: 	hostCfg := &container.HostConfig{
133: 		PortBindings: defaultPortBindings,
134: 		Binds: []string{
135: 			fmt.Sprintf("%s:/config/config.json", C.Path.Resolve("trojan.json")),
136: 			fmt.Sprintf("%s:/path/to/certificate.crt", C.Path.Resolve("example.org.pem")),
137: 			fmt.Sprintf("%s:/path/to/private.key", C.Path.Resolve("example.org-key.pem")),
138: 		},
139: 	}
140: 
141: 	id, err := startContainer(cfg, hostCfg, "trojan-bench")
142: 	require.NoError(b, err)
143: 
144: 	b.Cleanup(func() {
145: 		cleanContainer(id)
146: 	})
147: 
148: 	proxy, err := outbound.NewTrojan(outbound.TrojanOption{
149: 		Name:           "trojan",
150: 		Server:         localIP.String(),
151: 		Port:           10002,
152: 		Password:       "password",
153: 		SNI:            "example.org",
154: 		SkipCertVerify: true,
155: 		UDP:            true,
156: 	})
157: 	require.NoError(b, err)
158: 
159: 	require.True(b, TCPing(net.JoinHostPort(localIP.String(), "10002")))
160: 	benchmarkProxy(b, proxy)
161: }


./test\util.go
1: package main
2: 
3: import (
4: 	"context"
5: 	"net"
6: 	"time"
7: )
8: 
9: func Listen(network, address string) (net.Listener, error) {
10: 	lc := net.ListenConfig{}
11: 
12: 	var lastErr error
13: 	for i := 0; i < 5; i++ {
14: 		l, err := lc.Listen(context.Background(), network, address)
15: 		if err == nil {
16: 			return l, nil
17: 		}
18: 
19: 		lastErr = err
20: 		time.Sleep(time.Millisecond * 200)
21: 	}
22: 	return nil, lastErr
23: }
24: 
25: func ListenPacket(network, address string) (net.PacketConn, error) {
26: 	var lastErr error
27: 	for i := 0; i < 5; i++ {
28: 		l, err := net.ListenPacket(network, address)
29: 		if err == nil {
30: 			return l, nil
31: 		}
32: 
33: 		lastErr = err
34: 		time.Sleep(time.Millisecond * 200)
35: 	}
36: 	return nil, lastErr
37: }
38: 
39: func TCPing(addr string) bool {
40: 	for i := 0; i < 10; i++ {
41: 		conn, err := net.Dial("tcp", addr)
42: 		if err == nil {
43: 			conn.Close()
44: 			return true
45: 		}
46: 		time.Sleep(time.Millisecond * 500)
47: 	}
48: 
49: 	return false
50: }


./test\vless_test.go
1: package main
2: 
3: import (
4: 	"fmt"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/docker/docker/api/types/container"
9: 	"github.com/stretchr/testify/require"
10: 
11: 	"github.com/Dreamacro/clash/adapter/outbound"
12: 	C "github.com/Dreamacro/clash/constant"
13: )
14: 
15: func TestClash_Vless(t *testing.T) {
16: 	configPath := C.Path.Resolve("vless.json")
17: 
18: 	cfg := &container.Config{
19: 		Image:        ImageVmess,
20: 		ExposedPorts: defaultExposedPorts,
21: 		Entrypoint:   []string{"/usr/bin/v2ray"},
22: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
23: 	}
24: 	hostCfg := &container.HostConfig{
25: 		PortBindings: defaultPortBindings,
26: 		Binds:        []string{fmt.Sprintf("%s:/etc/v2ray/config.json", configPath)},
27: 	}
28: 
29: 	id, err := startContainer(cfg, hostCfg, "vless")
30: 	require.NoError(t, err)
31: 
32: 	t.Cleanup(func() {
33: 		cleanContainer(id)
34: 	})
35: 
36: 	proxy, err := outbound.NewVless(outbound.VlessOption{
37: 		Name:   "vless",
38: 		Server: localIP.String(),
39: 		Port:   10002,
40: 		UUID:   "b831381d-6324-4d53-ad4f-8cda48b30811",
41: 		Cipher: "auto",
42: 		UDP:    true,
43: 	})
44: 	require.NoError(t, err)
45: 
46: 	time.Sleep(waitTime)
47: 	testSuit(t, proxy)
48: }
49: 
50: func TestClash_VlessTLS(t *testing.T) {
51: 	cfg := &container.Config{
52: 		Image:        ImageVmess,
53: 		ExposedPorts: defaultExposedPorts,
54: 		Entrypoint:   []string{"/usr/bin/v2ray"},
55: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
56: 	}
57: 	hostCfg := &container.HostConfig{
58: 		PortBindings: defaultPortBindings,
59: 		Binds: []string{
60: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-tls.json")),
61: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
62: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
63: 		},
64: 	}
65: 
66: 	id, err := startContainer(cfg, hostCfg, "vless-tls")
67: 	require.NoError(t, err)
68: 	t.Cleanup(func() {
69: 		cleanContainer(id)
70: 	})
71: 
72: 	proxy, err := outbound.NewVless(outbound.VlessOption{
73: 		Name:           "vless",
74: 		Server:         localIP.String(),
75: 		Port:           10002,
76: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
77: 		Cipher:         "auto",
78: 		TLS:            true,
79: 		SkipCertVerify: true,
80: 		ServerName:     "example.org",
81: 		UDP:            true,
82: 	})
83: 	require.NoError(t, err)
84: 
85: 	time.Sleep(waitTime)
86: 	testSuit(t, proxy)
87: }
88: 
89: func TestClash_VlessHTTP2(t *testing.T) {
90: 	cfg := &container.Config{
91: 		Image:        ImageVmess,
92: 		ExposedPorts: defaultExposedPorts,
93: 		Entrypoint:   []string{"/usr/bin/v2ray"},
94: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
95: 	}
96: 	hostCfg := &container.HostConfig{
97: 		PortBindings: defaultPortBindings,
98: 		Binds: []string{
99: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-http2.json")),
100: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
101: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
102: 		},
103: 	}
104: 
105: 	id, err := startContainer(cfg, hostCfg, "vless-http2")
106: 	require.NoError(t, err)
107: 	t.Cleanup(func() {
108: 		cleanContainer(id)
109: 	})
110: 
111: 	proxy, err := outbound.NewVless(outbound.VlessOption{
112: 		Name:           "vless",
113: 		Server:         localIP.String(),
114: 		Port:           10002,
115: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
116: 		Cipher:         "auto",
117: 		Network:        "h2",
118: 		TLS:            true,
119: 		SkipCertVerify: true,
120: 		ServerName:     "example.org",
121: 		UDP:            true,
122: 		HTTP2Opts: outbound.HTTP2Options{
123: 			Host: []string{"example.org"},
124: 			Path: "/test",
125: 		},
126: 	})
127: 	require.NoError(t, err)
128: 
129: 	time.Sleep(waitTime)
130: 	testSuit(t, proxy)
131: }
132: 
133: func TestClash_VlessHTTP(t *testing.T) {
134: 	cfg := &container.Config{
135: 		Image:        ImageVmess,
136: 		ExposedPorts: defaultExposedPorts,
137: 		Entrypoint:   []string{"/usr/bin/v2ray"},
138: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
139: 	}
140: 	hostCfg := &container.HostConfig{
141: 		PortBindings: defaultPortBindings,
142: 		Binds: []string{
143: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-http.json")),
144: 		},
145: 	}
146: 
147: 	id, err := startContainer(cfg, hostCfg, "vless-http")
148: 	require.NoError(t, err)
149: 	t.Cleanup(func() {
150: 		cleanContainer(id)
151: 	})
152: 
153: 	proxy, err := outbound.NewVless(outbound.VlessOption{
154: 		Name:    "vless",
155: 		Server:  localIP.String(),
156: 		Port:    10002,
157: 		UUID:    "b831381d-6324-4d53-ad4f-8cda48b30811",
158: 		Cipher:  "auto",
159: 		Network: "http",
160: 		UDP:     true,
161: 		HTTPOpts: outbound.HTTPOptions{
162: 			Method: "GET",
163: 			Path:   []string{"/"},
164: 			Headers: map[string][]string{
165: 				"Host": {"www.amazon.com"},
166: 				"User-Agent": {
167: 					"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Edg/84.0.522.49",
168: 				},
169: 				"Accept-Encoding": {
170: 					"gzip, deflate",
171: 				},
172: 				"Connection": {
173: 					"keep-alive",
174: 				},
175: 				"Pragma": {"no-cache"},
176: 			},
177: 		},
178: 	})
179: 	require.NoError(t, err)
180: 
181: 	time.Sleep(waitTime)
182: 	testSuit(t, proxy)
183: }
184: 
185: func TestClash_VlessWebsocket(t *testing.T) {
186: 	cfg := &container.Config{
187: 		Image:        ImageVmess,
188: 		ExposedPorts: defaultExposedPorts,
189: 		Entrypoint:   []string{"/usr/bin/v2ray"},
190: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
191: 	}
192: 	hostCfg := &container.HostConfig{
193: 		PortBindings: defaultPortBindings,
194: 		Binds: []string{
195: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-ws.json")),
196: 		},
197: 	}
198: 
199: 	id, err := startContainer(cfg, hostCfg, "vless-ws")
200: 	require.NoError(t, err)
201: 	t.Cleanup(func() {
202: 		cleanContainer(id)
203: 	})
204: 
205: 	proxy, err := outbound.NewVless(outbound.VlessOption{
206: 		Name:    "vless",
207: 		Server:  localIP.String(),
208: 		Port:    10002,
209: 		UUID:    "b831381d-6324-4d53-ad4f-8cda48b30811",
210: 		Cipher:  "auto",
211: 		Network: "ws",
212: 		UDP:     true,
213: 	})
214: 	require.NoError(t, err)
215: 
216: 	time.Sleep(waitTime)
217: 	testSuit(t, proxy)
218: }
219: 
220: func TestClash_VlessWebsocketTLS(t *testing.T) {
221: 	cfg := &container.Config{
222: 		Image:        ImageVmess,
223: 		ExposedPorts: defaultExposedPorts,
224: 		Entrypoint:   []string{"/usr/bin/v2ray"},
225: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
226: 	}
227: 	hostCfg := &container.HostConfig{
228: 		PortBindings: defaultPortBindings,
229: 		Binds: []string{
230: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-ws-tls.json")),
231: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
232: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
233: 		},
234: 	}
235: 
236: 	id, err := startContainer(cfg, hostCfg, "vless-ws-tls")
237: 	require.NoError(t, err)
238: 	t.Cleanup(func() {
239: 		cleanContainer(id)
240: 	})
241: 
242: 	proxy, err := outbound.NewVless(outbound.VlessOption{
243: 		Name:           "vless",
244: 		Server:         localIP.String(),
245: 		Port:           10002,
246: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
247: 		Cipher:         "auto",
248: 		Network:        "ws",
249: 		TLS:            true,
250: 		SkipCertVerify: true,
251: 		UDP:            true,
252: 	})
253: 	require.NoError(t, err)
254: 
255: 	time.Sleep(waitTime)
256: 	testSuit(t, proxy)
257: }
258: 
259: func TestClash_VlessWebsocketTLSZero(t *testing.T) {
260: 	cfg := &container.Config{
261: 		Image:        ImageVmess,
262: 		ExposedPorts: defaultExposedPorts,
263: 		Entrypoint:   []string{"/usr/bin/v2ray"},
264: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
265: 	}
266: 	hostCfg := &container.HostConfig{
267: 		PortBindings: defaultPortBindings,
268: 		Binds: []string{
269: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-ws-tls-zero.json")),
270: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
271: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
272: 		},
273: 	}
274: 
275: 	id, err := startContainer(cfg, hostCfg, "vless-ws-tls-zero")
276: 	require.NoError(t, err)
277: 	t.Cleanup(func() {
278: 		cleanContainer(id)
279: 	})
280: 
281: 	proxy, err := outbound.NewVless(outbound.VlessOption{
282: 		Name:           "vless",
283: 		Server:         localIP.String(),
284: 		Port:           10002,
285: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
286: 		Cipher:         "zero",
287: 		Network:        "ws",
288: 		TLS:            true,
289: 		SkipCertVerify: true,
290: 		UDP:            true,
291: 	})
292: 	require.NoError(t, err)
293: 
294: 	time.Sleep(waitTime)
295: 	testSuit(t, proxy)
296: }
297: 
298: func TestClash_VlessGrpc(t *testing.T) {
299: 	cfg := &container.Config{
300: 		Image:        ImageVmess,
301: 		ExposedPorts: defaultExposedPorts,
302: 		Entrypoint:   []string{"/usr/bin/v2ray"},
303: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
304: 	}
305: 	hostCfg := &container.HostConfig{
306: 		PortBindings: defaultPortBindings,
307: 		Binds: []string{
308: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-grpc.json")),
309: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
310: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
311: 		},
312: 	}
313: 
314: 	id, err := startContainer(cfg, hostCfg, "vless-grpc")
315: 	require.NoError(t, err)
316: 	t.Cleanup(func() {
317: 		cleanContainer(id)
318: 	})
319: 
320: 	proxy, err := outbound.NewVless(outbound.VlessOption{
321: 		Name:           "vless",
322: 		Server:         localIP.String(),
323: 		Port:           10002,
324: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
325: 		Cipher:         "auto",
326: 		Network:        "grpc",
327: 		TLS:            true,
328: 		SkipCertVerify: true,
329: 		UDP:            true,
330: 		ServerName:     "example.org",
331: 		GrpcOpts: outbound.GrpcOptions{
332: 			GrpcServiceName: "example!",
333: 		},
334: 	})
335: 	require.NoError(t, err)
336: 
337: 	time.Sleep(waitTime)
338: 	testSuit(t, proxy)
339: }
340: 
341: func TestClash_VlessWebsocket0RTT(t *testing.T) {
342: 	cfg := &container.Config{
343: 		Image:        ImageVmess,
344: 		ExposedPorts: defaultExposedPorts,
345: 		Entrypoint:   []string{"/usr/bin/v2ray"},
346: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
347: 	}
348: 	hostCfg := &container.HostConfig{
349: 		PortBindings: defaultPortBindings,
350: 		Binds: []string{
351: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vless-ws-0rtt.json")),
352: 		},
353: 	}
354: 
355: 	id, err := startContainer(cfg, hostCfg, "vless-ws-0rtt")
356: 	require.NoError(t, err)
357: 	t.Cleanup(func() {
358: 		cleanContainer(id)
359: 	})
360: 
361: 	proxy, err := outbound.NewVless(outbound.VlessOption{
362: 		Name:       "vless",
363: 		Server:     localIP.String(),
364: 		Port:       10002,
365: 		UUID:       "b831381d-6324-4d53-ad4f-8cda48b30811",
366: 		Cipher:     "auto",
367: 		Network:    "ws",
368: 		UDP:        true,
369: 		ServerName: "example.org",
370: 		WSOpts: outbound.WSOptions{
371: 			MaxEarlyData:        2048,
372: 			EarlyDataHeaderName: "Sec-WebSocket-Protocol",
373: 		},
374: 	})
375: 	require.NoError(t, err)
376: 
377: 	time.Sleep(waitTime)
378: 	testSuit(t, proxy)
379: }
380: 
381: func TestClash_VlessWebsocketXray0RTT(t *testing.T) {
382: 	cfg := &container.Config{
383: 		Image:        ImageXray,
384: 		ExposedPorts: defaultExposedPorts,
385: 	}
386: 	hostCfg := &container.HostConfig{
387: 		PortBindings: defaultPortBindings,
388: 		Binds: []string{
389: 			fmt.Sprintf("%s:/etc/xray/config.json", C.Path.Resolve("vless-ws-0rtt.json")),
390: 		},
391: 	}
392: 
393: 	id, err := startContainer(cfg, hostCfg, "vless-xray-ws-0rtt")
394: 	require.NoError(t, err)
395: 	t.Cleanup(func() {
396: 		cleanContainer(id)
397: 	})
398: 
399: 	proxy, err := outbound.NewVless(outbound.VlessOption{
400: 		Name:       "vless",
401: 		Server:     localIP.String(),
402: 		Port:       10002,
403: 		UUID:       "b831381d-6324-4d53-ad4f-8cda48b30811",
404: 		Cipher:     "auto",
405: 		Network:    "ws",
406: 		UDP:        true,
407: 		ServerName: "example.org",
408: 		WSOpts: outbound.WSOptions{
409: 			Path: "/?ed=2048",
410: 		},
411: 	})
412: 	require.NoError(t, err)
413: 
414: 	time.Sleep(waitTime)
415: 	testSuit(t, proxy)
416: }
417: 
418: func Benchmark_Vless(b *testing.B) {
419: 	configPath := C.Path.Resolve("vless.json")
420: 
421: 	cfg := &container.Config{
422: 		Image:        ImageVmess,
423: 		ExposedPorts: defaultExposedPorts,
424: 		Entrypoint:   []string{"/usr/bin/v2ray"},
425: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
426: 	}
427: 	hostCfg := &container.HostConfig{
428: 		PortBindings: defaultPortBindings,
429: 		Binds:        []string{fmt.Sprintf("%s:/etc/v2ray/config.json", configPath)},
430: 	}
431: 
432: 	id, err := startContainer(cfg, hostCfg, "vless-bench")
433: 	require.NoError(b, err)
434: 
435: 	b.Cleanup(func() {
436: 		cleanContainer(id)
437: 	})
438: 
439: 	proxy, err := outbound.NewVless(outbound.VlessOption{
440: 		Name:    "vless",
441: 		Server:  localIP.String(),
442: 		Port:    10002,
443: 		UUID:    "b831381d-6324-4d53-ad4f-8cda48b30811",
444: 		Cipher:  "auto",
445: 		AlterID: 0,
446: 		UDP:     true,
447: 	})
448: 	require.NoError(b, err)
449: 
450: 	time.Sleep(waitTime)
451: 	benchmarkProxy(b, proxy)
452: }


./test\vmess_test.go
1: package main
2: 
3: import (
4: 	"fmt"
5: 	"testing"
6: 	"time"
7: 
8: 	"github.com/docker/docker/api/types/container"
9: 	"github.com/stretchr/testify/require"
10: 
11: 	"github.com/Dreamacro/clash/adapter/outbound"
12: 	C "github.com/Dreamacro/clash/constant"
13: )
14: 
15: func TestClash_Vmess(t *testing.T) {
16: 	configPath := C.Path.Resolve("vmess.json")
17: 
18: 	cfg := &container.Config{
19: 		Image:        ImageVmess,
20: 		ExposedPorts: defaultExposedPorts,
21: 		Entrypoint:   []string{"/usr/bin/v2ray"},
22: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
23: 	}
24: 	hostCfg := &container.HostConfig{
25: 		PortBindings: defaultPortBindings,
26: 		Binds:        []string{fmt.Sprintf("%s:/etc/v2ray/config.json", configPath)},
27: 	}
28: 
29: 	id, err := startContainer(cfg, hostCfg, "vmess")
30: 	require.NoError(t, err)
31: 
32: 	t.Cleanup(func() {
33: 		cleanContainer(id)
34: 	})
35: 
36: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
37: 		Name:   "vmess",
38: 		Server: localIP.String(),
39: 		Port:   10002,
40: 		UUID:   "b831381d-6324-4d53-ad4f-8cda48b30811",
41: 		Cipher: "auto",
42: 		UDP:    true,
43: 	})
44: 	require.NoError(t, err)
45: 
46: 	time.Sleep(waitTime)
47: 	testSuit(t, proxy)
48: }
49: 
50: func TestClash_VmessTLS(t *testing.T) {
51: 	cfg := &container.Config{
52: 		Image:        ImageVmess,
53: 		ExposedPorts: defaultExposedPorts,
54: 		Entrypoint:   []string{"/usr/bin/v2ray"},
55: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
56: 	}
57: 	hostCfg := &container.HostConfig{
58: 		PortBindings: defaultPortBindings,
59: 		Binds: []string{
60: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-tls.json")),
61: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
62: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
63: 		},
64: 	}
65: 
66: 	id, err := startContainer(cfg, hostCfg, "vmess-tls")
67: 	require.NoError(t, err)
68: 	t.Cleanup(func() {
69: 		cleanContainer(id)
70: 	})
71: 
72: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
73: 		Name:           "vmess",
74: 		Server:         localIP.String(),
75: 		Port:           10002,
76: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
77: 		Cipher:         "auto",
78: 		TLS:            true,
79: 		SkipCertVerify: true,
80: 		ServerName:     "example.org",
81: 		UDP:            true,
82: 	})
83: 	require.NoError(t, err)
84: 
85: 	time.Sleep(waitTime)
86: 	testSuit(t, proxy)
87: }
88: 
89: func TestClash_VmessHTTP2(t *testing.T) {
90: 	cfg := &container.Config{
91: 		Image:        ImageVmess,
92: 		ExposedPorts: defaultExposedPorts,
93: 		Entrypoint:   []string{"/usr/bin/v2ray"},
94: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
95: 	}
96: 	hostCfg := &container.HostConfig{
97: 		PortBindings: defaultPortBindings,
98: 		Binds: []string{
99: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-http2.json")),
100: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
101: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
102: 		},
103: 	}
104: 
105: 	id, err := startContainer(cfg, hostCfg, "vmess-http2")
106: 	require.NoError(t, err)
107: 	t.Cleanup(func() {
108: 		cleanContainer(id)
109: 	})
110: 
111: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
112: 		Name:           "vmess",
113: 		Server:         localIP.String(),
114: 		Port:           10002,
115: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
116: 		Cipher:         "auto",
117: 		Network:        "h2",
118: 		TLS:            true,
119: 		SkipCertVerify: true,
120: 		ServerName:     "example.org",
121: 		UDP:            true,
122: 		HTTP2Opts: outbound.HTTP2Options{
123: 			Host: []string{"example.org"},
124: 			Path: "/test",
125: 		},
126: 	})
127: 	require.NoError(t, err)
128: 
129: 	time.Sleep(waitTime)
130: 	testSuit(t, proxy)
131: }
132: 
133: func TestClash_VmessHTTP(t *testing.T) {
134: 	cfg := &container.Config{
135: 		Image:        ImageVmess,
136: 		ExposedPorts: defaultExposedPorts,
137: 		Entrypoint:   []string{"/usr/bin/v2ray"},
138: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
139: 	}
140: 	hostCfg := &container.HostConfig{
141: 		PortBindings: defaultPortBindings,
142: 		Binds: []string{
143: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-http.json")),
144: 		},
145: 	}
146: 
147: 	id, err := startContainer(cfg, hostCfg, "vmess-http")
148: 	require.NoError(t, err)
149: 	t.Cleanup(func() {
150: 		cleanContainer(id)
151: 	})
152: 
153: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
154: 		Name:    "vmess",
155: 		Server:  localIP.String(),
156: 		Port:    10002,
157: 		UUID:    "b831381d-6324-4d53-ad4f-8cda48b30811",
158: 		Cipher:  "auto",
159: 		Network: "http",
160: 		UDP:     true,
161: 		HTTPOpts: outbound.HTTPOptions{
162: 			Method: "GET",
163: 			Path:   []string{"/"},
164: 			Headers: map[string][]string{
165: 				"Host": {"www.amazon.com"},
166: 				"User-Agent": {
167: 					"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Edg/84.0.522.49",
168: 				},
169: 				"Accept-Encoding": {
170: 					"gzip, deflate",
171: 				},
172: 				"Connection": {
173: 					"keep-alive",
174: 				},
175: 				"Pragma": {"no-cache"},
176: 			},
177: 		},
178: 	})
179: 	require.NoError(t, err)
180: 
181: 	time.Sleep(waitTime)
182: 	testSuit(t, proxy)
183: }
184: 
185: func TestClash_VmessWebsocket(t *testing.T) {
186: 	cfg := &container.Config{
187: 		Image:        ImageVmess,
188: 		ExposedPorts: defaultExposedPorts,
189: 		Entrypoint:   []string{"/usr/bin/v2ray"},
190: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
191: 	}
192: 	hostCfg := &container.HostConfig{
193: 		PortBindings: defaultPortBindings,
194: 		Binds: []string{
195: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-ws.json")),
196: 		},
197: 	}
198: 
199: 	id, err := startContainer(cfg, hostCfg, "vmess-ws")
200: 	require.NoError(t, err)
201: 	t.Cleanup(func() {
202: 		cleanContainer(id)
203: 	})
204: 
205: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
206: 		Name:    "vmess",
207: 		Server:  localIP.String(),
208: 		Port:    10002,
209: 		UUID:    "b831381d-6324-4d53-ad4f-8cda48b30811",
210: 		Cipher:  "auto",
211: 		Network: "ws",
212: 		UDP:     true,
213: 	})
214: 	require.NoError(t, err)
215: 
216: 	time.Sleep(waitTime)
217: 	testSuit(t, proxy)
218: }
219: 
220: func TestClash_VmessWebsocketTLS(t *testing.T) {
221: 	cfg := &container.Config{
222: 		Image:        ImageVmess,
223: 		ExposedPorts: defaultExposedPorts,
224: 		Entrypoint:   []string{"/usr/bin/v2ray"},
225: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
226: 	}
227: 	hostCfg := &container.HostConfig{
228: 		PortBindings: defaultPortBindings,
229: 		Binds: []string{
230: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-ws-tls.json")),
231: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
232: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
233: 		},
234: 	}
235: 
236: 	id, err := startContainer(cfg, hostCfg, "vmess-ws-tls")
237: 	require.NoError(t, err)
238: 	t.Cleanup(func() {
239: 		cleanContainer(id)
240: 	})
241: 
242: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
243: 		Name:           "vmess",
244: 		Server:         localIP.String(),
245: 		Port:           10002,
246: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
247: 		Cipher:         "auto",
248: 		Network:        "ws",
249: 		TLS:            true,
250: 		SkipCertVerify: true,
251: 		UDP:            true,
252: 	})
253: 	require.NoError(t, err)
254: 
255: 	time.Sleep(waitTime)
256: 	testSuit(t, proxy)
257: }
258: 
259: func TestClash_VmessWebsocketTLSZero(t *testing.T) {
260: 	cfg := &container.Config{
261: 		Image:        ImageVmess,
262: 		ExposedPorts: defaultExposedPorts,
263: 		Entrypoint:   []string{"/usr/bin/v2ray"},
264: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
265: 	}
266: 	hostCfg := &container.HostConfig{
267: 		PortBindings: defaultPortBindings,
268: 		Binds: []string{
269: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-ws-tls-zero.json")),
270: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
271: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
272: 		},
273: 	}
274: 
275: 	id, err := startContainer(cfg, hostCfg, "vmess-ws-tls-zero")
276: 	require.NoError(t, err)
277: 	t.Cleanup(func() {
278: 		cleanContainer(id)
279: 	})
280: 
281: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
282: 		Name:           "vmess",
283: 		Server:         localIP.String(),
284: 		Port:           10002,
285: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
286: 		Cipher:         "zero",
287: 		Network:        "ws",
288: 		TLS:            true,
289: 		SkipCertVerify: true,
290: 		UDP:            true,
291: 	})
292: 	require.NoError(t, err)
293: 
294: 	time.Sleep(waitTime)
295: 	testSuit(t, proxy)
296: }
297: 
298: func TestClash_VmessGrpc(t *testing.T) {
299: 	cfg := &container.Config{
300: 		Image:        ImageVmess,
301: 		ExposedPorts: defaultExposedPorts,
302: 		Entrypoint:   []string{"/usr/bin/v2ray"},
303: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
304: 	}
305: 	hostCfg := &container.HostConfig{
306: 		PortBindings: defaultPortBindings,
307: 		Binds: []string{
308: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-grpc.json")),
309: 			fmt.Sprintf("%s:/etc/ssl/v2ray/fullchain.pem", C.Path.Resolve("example.org.pem")),
310: 			fmt.Sprintf("%s:/etc/ssl/v2ray/privkey.pem", C.Path.Resolve("example.org-key.pem")),
311: 		},
312: 	}
313: 
314: 	id, err := startContainer(cfg, hostCfg, "vmess-grpc")
315: 	require.NoError(t, err)
316: 	t.Cleanup(func() {
317: 		cleanContainer(id)
318: 	})
319: 
320: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
321: 		Name:           "vmess",
322: 		Server:         localIP.String(),
323: 		Port:           10002,
324: 		UUID:           "b831381d-6324-4d53-ad4f-8cda48b30811",
325: 		Cipher:         "auto",
326: 		Network:        "grpc",
327: 		TLS:            true,
328: 		SkipCertVerify: true,
329: 		UDP:            true,
330: 		ServerName:     "example.org",
331: 		GrpcOpts: outbound.GrpcOptions{
332: 			GrpcServiceName: "example!",
333: 		},
334: 	})
335: 	require.NoError(t, err)
336: 
337: 	time.Sleep(waitTime)
338: 	testSuit(t, proxy)
339: }
340: 
341: func TestClash_VmessWebsocket0RTT(t *testing.T) {
342: 	cfg := &container.Config{
343: 		Image:        ImageVmess,
344: 		ExposedPorts: defaultExposedPorts,
345: 		Entrypoint:   []string{"/usr/bin/v2ray"},
346: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
347: 	}
348: 	hostCfg := &container.HostConfig{
349: 		PortBindings: defaultPortBindings,
350: 		Binds: []string{
351: 			fmt.Sprintf("%s:/etc/v2ray/config.json", C.Path.Resolve("vmess-ws-0rtt.json")),
352: 		},
353: 	}
354: 
355: 	id, err := startContainer(cfg, hostCfg, "vmess-ws-0rtt")
356: 	require.NoError(t, err)
357: 	t.Cleanup(func() {
358: 		cleanContainer(id)
359: 	})
360: 
361: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
362: 		Name:       "vmess",
363: 		Server:     localIP.String(),
364: 		Port:       10002,
365: 		UUID:       "b831381d-6324-4d53-ad4f-8cda48b30811",
366: 		Cipher:     "auto",
367: 		Network:    "ws",
368: 		UDP:        true,
369: 		ServerName: "example.org",
370: 		WSOpts: outbound.WSOptions{
371: 			MaxEarlyData:        2048,
372: 			EarlyDataHeaderName: "Sec-WebSocket-Protocol",
373: 		},
374: 	})
375: 	require.NoError(t, err)
376: 
377: 	time.Sleep(waitTime)
378: 	testSuit(t, proxy)
379: }
380: 
381: func TestClash_VmessWebsocketXray0RTT(t *testing.T) {
382: 	cfg := &container.Config{
383: 		Image:        ImageXray,
384: 		ExposedPorts: defaultExposedPorts,
385: 	}
386: 	hostCfg := &container.HostConfig{
387: 		PortBindings: defaultPortBindings,
388: 		Binds: []string{
389: 			fmt.Sprintf("%s:/etc/xray/config.json", C.Path.Resolve("vmess-ws-0rtt.json")),
390: 		},
391: 	}
392: 
393: 	id, err := startContainer(cfg, hostCfg, "vmess-xray-ws-0rtt")
394: 	require.NoError(t, err)
395: 	t.Cleanup(func() {
396: 		cleanContainer(id)
397: 	})
398: 
399: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
400: 		Name:       "vmess",
401: 		Server:     localIP.String(),
402: 		Port:       10002,
403: 		UUID:       "b831381d-6324-4d53-ad4f-8cda48b30811",
404: 		Cipher:     "auto",
405: 		Network:    "ws",
406: 		UDP:        true,
407: 		ServerName: "example.org",
408: 		WSOpts: outbound.WSOptions{
409: 			Path: "/?ed=2048",
410: 		},
411: 	})
412: 	require.NoError(t, err)
413: 
414: 	time.Sleep(waitTime)
415: 	testSuit(t, proxy)
416: }
417: 
418: func Benchmark_Vmess(b *testing.B) {
419: 	configPath := C.Path.Resolve("vmess.json")
420: 
421: 	cfg := &container.Config{
422: 		Image:        ImageVmess,
423: 		ExposedPorts: defaultExposedPorts,
424: 		Entrypoint:   []string{"/usr/bin/v2ray"},
425: 		Cmd:          []string{"run", "-c", "/etc/v2ray/config.json"},
426: 	}
427: 	hostCfg := &container.HostConfig{
428: 		PortBindings: defaultPortBindings,
429: 		Binds:        []string{fmt.Sprintf("%s:/etc/v2ray/config.json", configPath)},
430: 	}
431: 
432: 	id, err := startContainer(cfg, hostCfg, "vmess-bench")
433: 	require.NoError(b, err)
434: 
435: 	b.Cleanup(func() {
436: 		cleanContainer(id)
437: 	})
438: 
439: 	proxy, err := outbound.NewVmess(outbound.VmessOption{
440: 		Name:    "vmess",
441: 		Server:  localIP.String(),
442: 		Port:    10002,
443: 		UUID:    "b831381d-6324-4d53-ad4f-8cda48b30811",
444: 		Cipher:  "auto",
445: 		AlterID: 0,
446: 		UDP:     true,
447: 	})
448: 	require.NoError(b, err)
449: 
450: 	time.Sleep(waitTime)
451: 	benchmarkProxy(b, proxy)
452: }


./test\config\example.org-key.pem
1: -----BEGIN PRIVATE KEY-----
2: MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDQ+c++LkDTdaw5
3: 5spCu9MWMcvVdrYBZZ5qZy7DskphSUSQp25cIu34GJXVPNxtbWx1CQCmdLlwqXvo
4: PfUt5/pz9qsfhdAbzFduZQgGd7GTQOTJBDrAhm2+iVsQyGHHhF68muN+SgT+AtRE
5: sJyZoHNYtjjWEIHQ++FHEDqwUVnj6Ut99LHlyfCjOZ5+WyBiKCjyMNots/gDep7R
6: i4X2kMTqNMIIqPUcAaP5EQk41bJbFhKe915qN9b1dRISKFKmiWeOsxgTB/O/EaL5
7: LsBYwZ/BiIMDk30aZvzRJeloasIR3z4hrKQqBfB0lfeIdiPpJIs5rXJQEiWH89ge
8: gplsLbfrAgMBAAECggEBAKpMGaZzDPMF/v8Ee6lcZM2+cMyZPALxa+JsCakCvyh+
9: y7hSKVY+RM0cQ+YM/djTBkJtvrDniEMuasI803PAitI7nwJGSuyMXmehP6P9oKFO
10: jeLeZn6ETiSqzKJlmYE89vMeCevdqCnT5mW/wy5Smg0eGj0gIJpM2S3PJPSQpv9Z
11: ots0JXkwooJcpGWzlwPkjSouY2gDbE4Coi+jmYLNjA1k5RbggcutnUCZZkJ6yMNv
12: H52VjnkffpAFHRouK/YgF+5nbMyyw5YTLOyTWBq7qfBMsXynkWLU73GC/xDZa3yG
13: o/Ph2knXCjgLmCRessTOObdOXedjnGWIjiqF8fVboDECgYEA6x5CteYiwthDBULZ
14: CG5nE9VKkRHJYdArm+VjmGbzK51tKli112avmU4r3ol907+mEa4tWLkPqdZrrL49
15: aHltuHizZJixJcw0rcI302ot/Ov0gkF9V55gnAQS/Kemvx9FHWm5NHdYvbObzj33
16: bYRLJBtJWzYg9M8Bw9ZrUnegc/MCgYEA44kq5OSYCbyu3eaX8XHTtFhuQHNFjwl7
17: Xk/Oel6PVZzmt+oOlDHnOfGSB/KpR3YXxFRngiiPZzbrOwFyPGe7HIfg03HAXiJh
18: ivEfrPHbQqQUI/4b44GpDy6bhNtz777ivFGYEt21vpwd89rFiye+RkqF8eL/evxO
19: pUayDZYvwikCgYEA07wFoZ/lkAiHmpZPsxsRcrfzFd+pto9splEWtumHdbCo3ajT
20: 4W5VFr9iHF8/VFDT8jokFjFaXL1/bCpKTOqFl8oC68XiSkKy8gPkmFyXm5y2LhNi
21: GGTFZdr5alRkgttbN5i9M/WCkhvMZRhC2Xp43MRB9IUzeqNtWHqhXbvjYGcCgYEA
22: vTMOztviLJ6PjYa0K5lp31l0+/SeD21j/y0/VPOSHi9kjeN7EfFZAw6DTkaSShDB
23: fIhutYVCkSHSgfMW6XGb3gKCiW/Z9KyEDYOowicuGgDTmoYu7IOhbzVjLhtJET7Z
24: zJvQZ0eiW4f3RBFTF/4JMuu+6z7FD6ADSV06qx+KQNkCgYBw26iQxmT5e/4kVv8X
25: DzBJ1HuliKBnnzZA1YRjB4H8F6Yrq+9qur1Lurez4YlbkGV8yPFt+Iu82ViUWL28
26: 9T7Jgp3TOpf8qOqsWFv8HldpEZbE0Tcib4x6s+zOg/aw0ac/xOPY1sCVFB81VODP
27: XCar+uxMBXI1zbXqd9QdEwy4Ig==
28: -----END PRIVATE KEY-----


./test\config\example.org.pem
1: -----BEGIN CERTIFICATE-----
2: MIIESzCCArOgAwIBAgIQIi5xRZvFZaSweWU9Y5mExjANBgkqhkiG9w0BAQsFADCB
3: hzEeMBwGA1UEChMVbWtjZXJ0IGRldmVsb3BtZW50IENBMS4wLAYDVQQLDCVkcmVh
4: bWFjcm9ARHJlYW1hY3JvLmxvY2FsIChEcmVhbWFjcm8pMTUwMwYDVQQDDCxta2Nl
5: cnQgZHJlYW1hY3JvQERyZWFtYWNyby5sb2NhbCAoRHJlYW1hY3JvKTAeFw0yMTAz
6: MTcxNDQwMzZaFw0yMzA2MTcxNDQwMzZaMFkxJzAlBgNVBAoTHm1rY2VydCBkZXZl
7: bG9wbWVudCBjZXJ0aWZpY2F0ZTEuMCwGA1UECwwlZHJlYW1hY3JvQERyZWFtYWNy
8: by5sb2NhbCAoRHJlYW1hY3JvKTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
9: ggEBAND5z74uQNN1rDnmykK70xYxy9V2tgFlnmpnLsOySmFJRJCnblwi7fgYldU8
10: 3G1tbHUJAKZ0uXCpe+g99S3n+nP2qx+F0BvMV25lCAZ3sZNA5MkEOsCGbb6JWxDI
11: YceEXrya435KBP4C1ESwnJmgc1i2ONYQgdD74UcQOrBRWePpS330seXJ8KM5nn5b
12: IGIoKPIw2i2z+AN6ntGLhfaQxOo0wgio9RwBo/kRCTjVslsWEp73Xmo31vV1EhIo
13: UqaJZ46zGBMH878RovkuwFjBn8GIgwOTfRpm/NEl6WhqwhHfPiGspCoF8HSV94h2
14: I+kkizmtclASJYfz2B6CmWwtt+sCAwEAAaNgMF4wDgYDVR0PAQH/BAQDAgWgMBMG
15: A1UdJQQMMAoGCCsGAQUFBwMBMB8GA1UdIwQYMBaAFO800LQ6Pa85RH4EbMmFH6ln
16: F150MBYGA1UdEQQPMA2CC2V4YW1wbGUub3JnMA0GCSqGSIb3DQEBCwUAA4IBgQAP
17: TsF53h7bvJcUXT3Y9yZ2vnW6xr9r92tNnM1Gfo3D2Yyn9oLf2YrfJng6WZ04Fhqa
18: Wh0HOvE0n6yPNpm/Q7mh64DrgolZ8Ce5H4RTJDAabHU9XhEzfGSVtzRSFsz+szu1
19: Y30IV+08DxxqMmNPspYdpAET2Lwyk2WhnARGiGw11CRkQCEkVEe6d702vS9UGBUz
20: Du6lmCYCm0SbFrZ0CGgmHSHoTcCtf3EjVam7dPg3yWiPbWjvhXxgip6hz9sCqkhG
21: WA5f+fPgSZ1I9U4i+uYnqjfrzwgC08RwUYordm15F6gPvXw+KVwDO8yUYQoEH0b6
22: AFJtbzoAXDysvBC6kWYFFOr62EaisaEkELTS/NrPD9ux1eKbxcxHCwEtVjgC0CL6
23: gAxEAQ+9maJMbrAFhsOBbGGFC+mMCGg4eEyx6+iMB0oQe0W7QFeRUAFi7Ptc/ocS
24: tZ9lbrfX1/wrcTTWIYWE+xH6oeb4fhs29kxjHcf2l+tQzmpl0aP3Z/bMW4BSB+w=
25: -----END CERTIFICATE-----


./test\config\snell-http.conf
1: [snell-server]
2: listen = 0.0.0.0:10002
3: psk = password
4: obfs = http


./test\config\snell-tls.conf
1: [snell-server]
2: listen = 0.0.0.0:10002
3: psk = password
4: obfs = tls


./test\config\snell.conf
1: [snell-server]
2: listen = 0.0.0.0:10002
3: psk = password


./test\config\trojan-grpc.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "trojan",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "password": "example",
11:                         "email": "grpc@example.com"
12:                     }
13:                 ]
14:             },
15:             "streamSettings": {
16:                 "network": "grpc",
17:                 "security": "tls",
18:                 "tlsSettings": {
19:                     "certificates": [
20:                         {
21:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
22:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
23:                         }
24:                     ]
25:                 },
26:                 "grpcSettings": {
27:                     "serviceName": "example"
28:                 }
29:             }
30:         }
31:     ],
32:     "outbounds": [
33:         {
34:             "protocol": "freedom"
35:         }
36:     ],
37:     "log": {
38:         "loglevel": "debug"
39:     }
40: }

./test\config\trojan-ws.json
1: {
2:     "run_type": "server",
3:     "local_addr": "0.0.0.0",
4:     "local_port": 10002,
5:     "disable_http_check": true,
6:     "password": [
7:         "example"
8:     ],
9:     "websocket": {
10:         "enabled": true,
11:         "path": "/",
12:         "host": "example.org"
13:     },
14:     "ssl": {
15:         "verify": true,
16:         "cert": "/fullchain.pem",
17:         "key": "/privkey.pem",
18:         "sni": "example.org"
19:     }
20: }

./test\config\trojan.json
1: {
2:     "run_type": "server",
3:     "local_addr": "0.0.0.0",
4:     "local_port": 10002,
5:     "password": [
6:         "password"
7:     ],
8:     "log_level": 1,
9:     "ssl": {
10:         "cert": "/path/to/certificate.crt",
11:         "key": "/path/to/private.key",
12:         "key_password": "",
13:         "cipher": "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384",
14:         "cipher_tls13": "TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384",
15:         "prefer_server_cipher": true,
16:         "alpn": [
17:             "http/1.1"
18:         ],
19:         "alpn_port_override": {
20:             "h2": 81
21:         },
22:         "reuse_session": true,
23:         "session_ticket": false,
24:         "session_timeout": 600,
25:         "plain_http_response": "",
26:         "curves": "",
27:         "dhparam": ""
28:     },
29:     "tcp": {
30:         "prefer_ipv4": false,
31:         "no_delay": true,
32:         "keep_alive": true,
33:         "reuse_port": false,
34:         "fast_open": false,
35:         "fast_open_qlen": 20
36:     },
37:     "mysql": {
38:         "enabled": false
39:     }
40: }

./test\config\vless-grpc.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "grpc",
17:                 "security": "tls",
18:                 "tlsSettings": {
19:                     "certificates": [
20:                         {
21:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
22:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
23:                         }
24:                     ]
25:                 },
26:                 "grpcSettings": {
27:                     "serviceName": "example!"
28:                 }
29:             }
30:         }
31:     ],
32:     "outbounds": [
33:         {
34:             "protocol": "freedom"
35:         }
36:     ],
37:     "log": {
38:         "loglevel": "debug"
39:     }
40: }


./test\config\vless-http.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "tcp",
17:                 "tcpSettings": {
18:                     "header": {
19:                         "type": "http",
20:                         "response": {
21:                             "version": "1.1",
22:                             "status": "200",
23:                             "reason": "OK",
24:                             "headers": {
25:                                 "Content-Type": [
26:                                     "application/octet-stream",
27:                                     "video/mpeg",
28:                                     "application/x-msdownload",
29:                                     "text/html",
30:                                     "application/x-shockwave-flash"
31:                                 ],
32:                                 "Transfer-Encoding": [
33:                                     "chunked"
34:                                 ],
35:                                 "Connection": [
36:                                     "keep-alive"
37:                                 ],
38:                                 "Pragma": "no-cache"
39:                             }
40:                         }
41:                     }
42:                 },
43:                 "security": "none"
44:             }
45:         }
46:     ],
47:     "outbounds": [
48:         {
49:             "protocol": "freedom"
50:         }
51:     ],
52:     "log": {
53:         "loglevel": "debug"
54:     }
55: }


./test\config\vless-http2.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "http",
17:                 "security": "tls",
18:                 "tlsSettings": {
19:                     "certificates": [
20:                         {
21:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
22:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
23:                         }
24:                     ]
25:                 },
26:                 "httpSettings": {
27:                     "host": [
28:                         "example.org"
29:                     ],
30:                     "path": "/test"
31:                 }
32:             }
33:         }
34:     ],
35:     "outbounds": [
36:         {
37:             "protocol": "freedom"
38:         }
39:     ],
40:     "log": {
41:         "loglevel": "debug"
42:     }
43: }


./test\config\vless-tls.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "tcp",
17:                 "security": "tls",
18:                 "tlsSettings": {
19:                     "certificates": [
20:                         {
21:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
22:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
23:                         }
24:                     ]
25:                 }
26:             }
27:         }
28:     ],
29:     "outbounds": [
30:         {
31:             "protocol": "freedom"
32:         }
33:     ],
34:     "log": {
35:         "loglevel": "debug"
36:     }
37: }


./test\config\vless-ws-0rtt.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "ws",
17:                 "security": "none",
18:                 "wsSettings": {
19:                     "maxEarlyData": 128,
20:                     "earlyDataHeaderName": "Sec-WebSocket-Protocol"
21:                 }
22:             }
23:         }
24:     ],
25:     "outbounds": [
26:         {
27:             "protocol": "freedom"
28:         }
29:     ]
30: }


./test\config\vless-ws-tls-zero.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "ws",
17:                 "security": "tls",
18:                 "tlsSettings": {
19:                     "certificates": [
20:                         {
21:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
22:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
23:                         }
24:                     ]
25:                 }
26:             }
27:         }
28:     ],
29:     "outbounds": [
30:         {
31:             "protocol": "freedom"
32:         }
33:     ]
34: }


./test\config\vless-ws-tls.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "ws",
17:                 "security": "tls",
18:                 "tlsSettings": {
19:                     "certificates": [
20:                         {
21:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
22:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
23:                         }
24:                     ]
25:                 }
26:             }
27:         }
28:     ],
29:     "outbounds": [
30:         {
31:             "protocol": "freedom"
32:         }
33:     ]
34: }


./test\config\vless-ws.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "ws",
17:                 "security": "none"
18:             }
19:         }
20:     ],
21:     "outbounds": [
22:         {
23:             "protocol": "freedom"
24:         }
25:     ]
26: }


./test\config\vless.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vless",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ],
13:                 "decryption": "none"
14:             },
15:             "streamSettings": {
16:                 "network": "tcp"
17:             }
18:         }
19:     ],
20:     "outbounds": [
21:         {
22:             "protocol": "freedom"
23:         }
24:     ],
25:     "log": {
26:         "loglevel": "debug"
27:     }
28: }


./test\config\vmess-grpc.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "grpc",
16:                 "security": "tls",
17:                 "tlsSettings": {
18:                     "certificates": [
19:                         {
20:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
21:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
22:                         }
23:                     ]
24:                 },
25:                 "grpcSettings": {
26:                     "serviceName": "example!"
27:                 }
28:             }
29:         }
30:     ],
31:     "outbounds": [
32:         {
33:             "protocol": "freedom"
34:         }
35:     ],
36:     "log": {
37:         "loglevel": "debug"
38:     }
39: }

./test\config\vmess-http.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "tcp",
16:                 "tcpSettings": {
17:                     "header": {
18:                         "type": "http",
19:                         "response": {
20:                             "version": "1.1",
21:                             "status": "200",
22:                             "reason": "OK",
23:                             "headers": {
24:                                 "Content-Type": [
25:                                     "application/octet-stream",
26:                                     "video/mpeg",
27:                                     "application/x-msdownload",
28:                                     "text/html",
29:                                     "application/x-shockwave-flash"
30:                                 ],
31:                                 "Transfer-Encoding": [
32:                                     "chunked"
33:                                 ],
34:                                 "Connection": [
35:                                     "keep-alive"
36:                                 ],
37:                                 "Pragma": "no-cache"
38:                             }
39:                         }
40:                     }
41:                 },
42:                 "security": "none"
43:             }
44:         }
45:     ],
46:     "outbounds": [
47:         {
48:             "protocol": "freedom"
49:         }
50:     ],
51:     "log": {
52:         "loglevel": "debug"
53:     }
54: }

./test\config\vmess-http2.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "http",
16:                 "security": "tls",
17:                 "tlsSettings": {
18:                     "certificates": [
19:                         {
20:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
21:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
22:                         }
23:                     ]
24:                 },
25:                 "httpSettings": {
26:                     "host": [
27:                         "example.org"
28:                     ],
29:                     "path": "/test"
30:                 }
31:             }
32:         }
33:     ],
34:     "outbounds": [
35:         {
36:             "protocol": "freedom"
37:         }
38:     ],
39:     "log": {
40:         "loglevel": "debug"
41:     }
42: }

./test\config\vmess-tls.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "tcp",
16:                 "security": "tls",
17:                 "tlsSettings": {
18:                     "certificates": [
19:                         {
20:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
21:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
22:                         }
23:                     ]
24:                 }
25:             }
26:         }
27:     ],
28:     "outbounds": [
29:         {
30:             "protocol": "freedom"
31:         }
32:     ],
33:     "log": {
34:         "loglevel": "debug"
35:     }
36: }

./test\config\vmess-ws-0rtt.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "ws",
16:                 "security": "none",
17:                 "wsSettings": {
18:                     "maxEarlyData": 128,
19:                     "earlyDataHeaderName": "Sec-WebSocket-Protocol"
20:                 }
21:             }
22:         }
23:     ],
24:     "outbounds": [
25:         {
26:             "protocol": "freedom"
27:         }
28:     ]
29: }

./test\config\vmess-ws-tls-zero.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811",
11:                         "alterId": 0,
12:                         "security": "zero"
13:                     }
14:                 ]
15:             },
16:             "streamSettings": {
17:                 "network": "ws",
18:                 "security": "tls",
19:                 "tlsSettings": {
20:                     "certificates": [
21:                         {
22:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
23:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
24:                         }
25:                     ]
26:                 }
27:             }
28:         }
29:     ],
30:     "outbounds": [
31:         {
32:             "protocol": "freedom"
33:         }
34:     ]
35: }

./test\config\vmess-ws-tls.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "ws",
16:                 "security": "tls",
17:                 "tlsSettings": {
18:                     "certificates": [
19:                         {
20:                             "certificateFile": "/etc/ssl/v2ray/fullchain.pem",
21:                             "keyFile": "/etc/ssl/v2ray/privkey.pem"
22:                         }
23:                     ]
24:                 }
25:             }
26:         }
27:     ],
28:     "outbounds": [
29:         {
30:             "protocol": "freedom"
31:         }
32:     ]
33: }

./test\config\vmess-ws.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "ws",
16:                 "security": "none"
17:             }
18:         }
19:     ],
20:     "outbounds": [
21:         {
22:             "protocol": "freedom"
23:         }
24:     ]
25: }

./test\config\vmess.json
1: {
2:     "inbounds": [
3:         {
4:             "port": 10002,
5:             "listen": "0.0.0.0",
6:             "protocol": "vmess",
7:             "settings": {
8:                 "clients": [
9:                     {
10:                         "id": "b831381d-6324-4d53-ad4f-8cda48b30811"
11:                     }
12:                 ]
13:             },
14:             "streamSettings": {
15:                 "network": "tcp"
16:             }
17:         }
18:     ],
19:     "outbounds": [
20:         {
21:             "protocol": "freedom"
22:         }
23:     ],
24:     "log": {
25:         "loglevel": "debug"
26:     }
27: }

./transport\gun\gun.go
1: // Modified from: https://github.com/Qv2ray/gun-lite
2: // License: MIT
3: 
4: package gun
5: 
6: import (
7: 	"bufio"
8: 	"context"
9: 	"crypto/tls"
10: 	"encoding/binary"
11: 	"errors"
12: 	"fmt"
13: 	"io"
14: 	"net"
15: 	"net/http"
16: 	"net/url"
17: 	"sync"
18: 	"time"
19: 
20: 	"github.com/Dreamacro/clash/common/pool"
21: 
22: 	"go.uber.org/atomic"
23: 	"golang.org/x/net/http2"
24: )
25: 
26: var (
27: 	ErrInvalidLength = errors.New("invalid length")
28: 	ErrSmallBuffer   = errors.New("buffer too small")
29: )
30: 
31: var defaultHeader = http.Header{
32: 	"content-type": []string{"application/grpc"},
33: 	"user-agent":   []string{"grpc-go/1.36.0"},
34: }
35: 
36: type DialFn = func(network, addr string) (net.Conn, error)
37: 
38: type Conn struct {
39: 	response  *http.Response
40: 	request   *http.Request
41: 	transport *http2.Transport
42: 	writer    *io.PipeWriter
43: 	once      sync.Once
44: 	close     *atomic.Bool
45: 	err       error
46: 	remain    int
47: 	br        *bufio.Reader
48: 
49: 	// deadlines
50: 	deadline *time.Timer
51: }
52: 
53: type Config struct {
54: 	ServiceName string
55: 	Host        string
56: }
57: 
58: func (g *Conn) initRequest() {
59: 	response, err := g.transport.RoundTrip(g.request)
60: 	if err != nil {
61: 		g.err = err
62: 		g.writer.Close()
63: 		return
64: 	}
65: 
66: 	if !g.close.Load() {
67: 		g.response = response
68: 		g.br = bufio.NewReader(response.Body)
69: 	} else {
70: 		response.Body.Close()
71: 	}
72: }
73: 
74: func (g *Conn) Read(b []byte) (n int, err error) {
75: 	g.once.Do(g.initRequest)
76: 	if g.err != nil {
77: 		return 0, g.err
78: 	}
79: 
80: 	if g.remain > 0 {
81: 		size := g.remain
82: 		if len(b) < size {
83: 			size = len(b)
84: 		}
85: 
86: 		n, err = io.ReadFull(g.br, b[:size])
87: 		g.remain -= n
88: 		return
89: 	} else if g.response == nil {
90: 		return 0, net.ErrClosed
91: 	}
92: 
93: 	// 0x00 grpclength(uint32) 0x0A uleb128 payload
94: 	_, err = g.br.Discard(6)
95: 	if err != nil {
96: 		return 0, err
97: 	}
98: 
99: 	protobufPayloadLen, err := binary.ReadUvarint(g.br)
100: 	if err != nil {
101: 		return 0, ErrInvalidLength
102: 	}
103: 
104: 	size := int(protobufPayloadLen)
105: 	if len(b) < size {
106: 		size = len(b)
107: 	}
108: 
109: 	n, err = io.ReadFull(g.br, b[:size])
110: 	if err != nil {
111: 		return
112: 	}
113: 
114: 	remain := int(protobufPayloadLen) - n
115: 	if remain > 0 {
116: 		g.remain = remain
117: 	}
118: 
119: 	return n, nil
120: }
121: 
122: func (g *Conn) Write(b []byte) (n int, err error) {
123: 	protobufHeader := [binary.MaxVarintLen64 + 1]byte{0x0A}
124: 	varuintSize := binary.PutUvarint(protobufHeader[1:], uint64(len(b)))
125: 	grpcHeader := make([]byte, 5)
126: 	grpcPayloadLen := uint32(varuintSize + 1 + len(b))
127: 	binary.BigEndian.PutUint32(grpcHeader[1:5], grpcPayloadLen)
128: 
129: 	buf := pool.GetBytesBuffer()
130: 	defer pool.PutBytesBuffer(buf)
131: 	buf.PutSlice(grpcHeader)
132: 	buf.PutSlice(protobufHeader[:varuintSize+1])
133: 	buf.PutSlice(b)
134: 
135: 	_, err = g.writer.Write(buf.Bytes())
136: 	if err == io.ErrClosedPipe && g.err != nil {
137: 		err = g.err
138: 	}
139: 
140: 	return len(b), err
141: }
142: 
143: func (g *Conn) Close() error {
144: 	g.close.Store(true)
145: 	if r := g.response; r != nil {
146: 		r.Body.Close()
147: 	}
148: 
149: 	return g.writer.Close()
150: }
151: 
152: func (g *Conn) LocalAddr() net.Addr                { return &net.TCPAddr{IP: net.IPv4zero, Port: 0} }
153: func (g *Conn) RemoteAddr() net.Addr               { return &net.TCPAddr{IP: net.IPv4zero, Port: 0} }
154: func (g *Conn) SetReadDeadline(t time.Time) error  { return g.SetDeadline(t) }
155: func (g *Conn) SetWriteDeadline(t time.Time) error { return g.SetDeadline(t) }
156: 
157: func (g *Conn) SetDeadline(t time.Time) error {
158: 	d := time.Until(t)
159: 	if g.deadline != nil {
160: 		g.deadline.Reset(d)
161: 		return nil
162: 	}
163: 	g.deadline = time.AfterFunc(d, func() {
164: 		g.Close()
165: 	})
166: 	return nil
167: }
168: 
169: func NewHTTP2Client(dialFn DialFn, tlsConfig *tls.Config) *http2.Transport {
170: 	dialFunc := func(ctx context.Context, network, addr string, cfg *tls.Config) (net.Conn, error) {
171: 		pconn, err := dialFn(network, addr)
172: 		if err != nil {
173: 			return nil, err
174: 		}
175: 
176: 		cn := tls.Client(pconn, cfg)
177: 		if err := cn.HandshakeContext(ctx); err != nil {
178: 			pconn.Close()
179: 			return nil, err
180: 		}
181: 		state := cn.ConnectionState()
182: 		if p := state.NegotiatedProtocol; p != http2.NextProtoTLS {
183: 			cn.Close()
184: 			return nil, fmt.Errorf("http2: unexpected ALPN protocol %s, want %s", p, http2.NextProtoTLS)
185: 		}
186: 		return cn, nil
187: 	}
188: 
189: 	return &http2.Transport{
190: 		DialTLSContext:     dialFunc,
191: 		TLSClientConfig:    tlsConfig,
192: 		AllowHTTP:          false,
193: 		DisableCompression: true,
194: 		PingTimeout:        0,
195: 	}
196: }
197: 
198: func StreamGunWithTransport(transport *http2.Transport, cfg *Config) (net.Conn, error) {
199: 	serviceName := "GunService"
200: 	if cfg.ServiceName != "" {
201: 		serviceName = cfg.ServiceName
202: 	}
203: 
204: 	reader, writer := io.Pipe()
205: 	request := &http.Request{
206: 		Method: http.MethodPost,
207: 		Body:   reader,
208: 		URL: &url.URL{
209: 			Scheme: "https",
210: 			Host:   cfg.Host,
211: 			Path:   fmt.Sprintf("/%s/Tun", serviceName),
212: 			// for unescape path
213: 			Opaque: fmt.Sprintf("//%s/%s/Tun", cfg.Host, serviceName),
214: 		},
215: 		Proto:      "HTTP/2",
216: 		ProtoMajor: 2,
217: 		ProtoMinor: 0,
218: 		Header:     defaultHeader,
219: 	}
220: 
221: 	conn := &Conn{
222: 		request:   request,
223: 		transport: transport,
224: 		writer:    writer,
225: 		close:     atomic.NewBool(false),
226: 	}
227: 
228: 	go conn.once.Do(conn.initRequest)
229: 	return conn, nil
230: }
231: 
232: func StreamGunWithConn(conn net.Conn, tlsConfig *tls.Config, cfg *Config) (net.Conn, error) {
233: 	dialFn := func(network, addr string) (net.Conn, error) {
234: 		return conn, nil
235: 	}
236: 
237: 	transport := NewHTTP2Client(dialFn, tlsConfig)
238: 	return StreamGunWithTransport(transport, cfg)
239: }


./transport\shadowsocks\README.md
1: ## Embedded go-shadowsocks2
2: 
3: from https://github.com/Dreamacro/go-shadowsocks2
4: 
5: origin https://github.com/riobard/go-shadowsocks2


./transport\shadowsocks\core\cipher.go
1: package core
2: 
3: import (
4: 	"crypto/md5"
5: 	"errors"
6: 	"net"
7: 	"sort"
8: 	"strings"
9: 
10: 	"github.com/Dreamacro/clash/transport/shadowsocks/shadowaead"
11: 	"github.com/Dreamacro/clash/transport/shadowsocks/shadowstream"
12: )
13: 
14: type Cipher interface {
15: 	StreamConnCipher
16: 	PacketConnCipher
17: }
18: 
19: type StreamConnCipher interface {
20: 	StreamConn(net.Conn) net.Conn
21: }
22: 
23: type PacketConnCipher interface {
24: 	PacketConn(net.PacketConn) net.PacketConn
25: }
26: 
27: // ErrCipherNotSupported occurs when a cipher is not supported (likely because of security concerns).
28: var ErrCipherNotSupported = errors.New("cipher not supported")
29: 
30: const (
31: 	aeadAes128Gcm         = "AEAD_AES_128_GCM"
32: 	aeadAes192Gcm         = "AEAD_AES_192_GCM"
33: 	aeadAes256Gcm         = "AEAD_AES_256_GCM"
34: 	aeadChacha20Poly1305  = "AEAD_CHACHA20_POLY1305"
35: 	aeadXChacha20Poly1305 = "AEAD_XCHACHA20_POLY1305"
36: )
37: 
38: // List of AEAD ciphers: key size in bytes and constructor
39: var aeadList = map[string]struct {
40: 	KeySize int
41: 	New     func([]byte) (shadowaead.Cipher, error)
42: }{
43: 	aeadAes128Gcm:         {16, shadowaead.AESGCM},
44: 	aeadAes192Gcm:         {24, shadowaead.AESGCM},
45: 	aeadAes256Gcm:         {32, shadowaead.AESGCM},
46: 	aeadChacha20Poly1305:  {32, shadowaead.Chacha20Poly1305},
47: 	aeadXChacha20Poly1305: {32, shadowaead.XChacha20Poly1305},
48: }
49: 
50: // List of stream ciphers: key size in bytes and constructor
51: var streamList = map[string]struct {
52: 	KeySize int
53: 	New     func(key []byte) (shadowstream.Cipher, error)
54: }{
55: 	"RC4-MD5":       {16, shadowstream.RC4MD5},
56: 	"AES-128-CTR":   {16, shadowstream.AESCTR},
57: 	"AES-192-CTR":   {24, shadowstream.AESCTR},
58: 	"AES-256-CTR":   {32, shadowstream.AESCTR},
59: 	"AES-128-CFB":   {16, shadowstream.AESCFB},
60: 	"AES-192-CFB":   {24, shadowstream.AESCFB},
61: 	"AES-256-CFB":   {32, shadowstream.AESCFB},
62: 	"CHACHA20-IETF": {32, shadowstream.Chacha20IETF},
63: 	"XCHACHA20":     {32, shadowstream.Xchacha20},
64: }
65: 
66: // ListCipher returns a list of available cipher names sorted alphabetically.
67: func ListCipher() []string {
68: 	var l []string
69: 	for k := range aeadList {
70: 		l = append(l, k)
71: 	}
72: 	for k := range streamList {
73: 		l = append(l, k)
74: 	}
75: 	sort.Strings(l)
76: 	return l
77: }
78: 
79: // PickCipher returns a Cipher of the given name. Derive key from password if given key is empty.
80: func PickCipher(name string, key []byte, password string) (Cipher, error) {
81: 	name = strings.ToUpper(name)
82: 
83: 	switch name {
84: 	case "DUMMY":
85: 		return &dummy{}, nil
86: 	case "CHACHA20-IETF-POLY1305":
87: 		name = aeadChacha20Poly1305
88: 	case "XCHACHA20-IETF-POLY1305":
89: 		name = aeadXChacha20Poly1305
90: 	case "AES-128-GCM":
91: 		name = aeadAes128Gcm
92: 	case "AES-192-GCM":
93: 		name = aeadAes192Gcm
94: 	case "AES-256-GCM":
95: 		name = aeadAes256Gcm
96: 	}
97: 
98: 	if choice, ok := aeadList[name]; ok {
99: 		if len(key) == 0 {
100: 			key = Kdf(password, choice.KeySize)
101: 		}
102: 		if len(key) != choice.KeySize {
103: 			return nil, shadowaead.KeySizeError(choice.KeySize)
104: 		}
105: 		aead, err := choice.New(key)
106: 		return &AeadCipher{Cipher: aead, Key: key}, err
107: 	}
108: 
109: 	if choice, ok := streamList[name]; ok {
110: 		if len(key) == 0 {
111: 			key = Kdf(password, choice.KeySize)
112: 		}
113: 		if len(key) != choice.KeySize {
114: 			return nil, shadowstream.KeySizeError(choice.KeySize)
115: 		}
116: 		ciph, err := choice.New(key)
117: 		return &StreamCipher{Cipher: ciph, Key: key}, err
118: 	}
119: 
120: 	return nil, ErrCipherNotSupported
121: }
122: 
123: type AeadCipher struct {
124: 	shadowaead.Cipher
125: 
126: 	Key []byte
127: }
128: 
129: func (aead *AeadCipher) StreamConn(c net.Conn) net.Conn { return shadowaead.NewConn(c, aead) }
130: func (aead *AeadCipher) PacketConn(c net.PacketConn) net.PacketConn {
131: 	return shadowaead.NewPacketConn(c, aead)
132: }
133: 
134: type StreamCipher struct {
135: 	shadowstream.Cipher
136: 
137: 	Key []byte
138: }
139: 
140: func (ciph *StreamCipher) StreamConn(c net.Conn) net.Conn { return shadowstream.NewConn(c, ciph) }
141: func (ciph *StreamCipher) PacketConn(c net.PacketConn) net.PacketConn {
142: 	return shadowstream.NewPacketConn(c, ciph)
143: }
144: 
145: // dummy cipher does not encrypt
146: 
147: type dummy struct{}
148: 
149: func (dummy) StreamConn(c net.Conn) net.Conn             { return c }
150: func (dummy) PacketConn(c net.PacketConn) net.PacketConn { return c }
151: 
152: // key-derivation function from original Shadowsocks
153: func Kdf(password string, keyLen int) []byte {
154: 	var b, prev []byte
155: 	h := md5.New()
156: 	for len(b) < keyLen {
157: 		h.Write(prev)
158: 		h.Write([]byte(password))
159: 		b = h.Sum(b)
160: 		prev = b[len(b)-h.Size():]
161: 		h.Reset()
162: 	}
163: 	return b[:keyLen]
164: }


./transport\shadowsocks\shadowaead\cipher.go
1: package shadowaead
2: 
3: import (
4: 	"crypto/aes"
5: 	"crypto/cipher"
6: 	"crypto/sha1"
7: 	"io"
8: 	"strconv"
9: 
10: 	"golang.org/x/crypto/chacha20poly1305"
11: 	"golang.org/x/crypto/hkdf"
12: )
13: 
14: type Cipher interface {
15: 	KeySize() int
16: 	SaltSize() int
17: 	Encrypter(salt []byte) (cipher.AEAD, error)
18: 	Decrypter(salt []byte) (cipher.AEAD, error)
19: }
20: 
21: type KeySizeError int
22: 
23: func (e KeySizeError) Error() string {
24: 	return "key size error: need " + strconv.Itoa(int(e)) + " bytes"
25: }
26: 
27: func hkdfSHA1(secret, salt, info, outkey []byte) {
28: 	r := hkdf.New(sha1.New, secret, salt, info)
29: 	if _, err := io.ReadFull(r, outkey); err != nil {
30: 		panic(err) // should never happen
31: 	}
32: }
33: 
34: type metaCipher struct {
35: 	psk      []byte
36: 	makeAEAD func(key []byte) (cipher.AEAD, error)
37: }
38: 
39: func (a *metaCipher) KeySize() int { return len(a.psk) }
40: func (a *metaCipher) SaltSize() int {
41: 	if ks := a.KeySize(); ks > 16 {
42: 		return ks
43: 	}
44: 	return 16
45: }
46: 
47: func (a *metaCipher) Encrypter(salt []byte) (cipher.AEAD, error) {
48: 	subkey := make([]byte, a.KeySize())
49: 	hkdfSHA1(a.psk, salt, []byte("ss-subkey"), subkey)
50: 	return a.makeAEAD(subkey)
51: }
52: 
53: func (a *metaCipher) Decrypter(salt []byte) (cipher.AEAD, error) {
54: 	subkey := make([]byte, a.KeySize())
55: 	hkdfSHA1(a.psk, salt, []byte("ss-subkey"), subkey)
56: 	return a.makeAEAD(subkey)
57: }
58: 
59: func aesGCM(key []byte) (cipher.AEAD, error) {
60: 	blk, err := aes.NewCipher(key)
61: 	if err != nil {
62: 		return nil, err
63: 	}
64: 	return cipher.NewGCM(blk)
65: }
66: 
67: // AESGCM creates a new Cipher with a pre-shared key. len(psk) must be
68: // one of 16, 24, or 32 to select AES-128/196/256-GCM.
69: func AESGCM(psk []byte) (Cipher, error) {
70: 	switch l := len(psk); l {
71: 	case 16, 24, 32: // AES 128/196/256
72: 	default:
73: 		return nil, aes.KeySizeError(l)
74: 	}
75: 	return &metaCipher{psk: psk, makeAEAD: aesGCM}, nil
76: }
77: 
78: // Chacha20Poly1305 creates a new Cipher with a pre-shared key. len(psk)
79: // must be 32.
80: func Chacha20Poly1305(psk []byte) (Cipher, error) {
81: 	if len(psk) != chacha20poly1305.KeySize {
82: 		return nil, KeySizeError(chacha20poly1305.KeySize)
83: 	}
84: 	return &metaCipher{psk: psk, makeAEAD: chacha20poly1305.New}, nil
85: }
86: 
87: // XChacha20Poly1305 creates a new Cipher with a pre-shared key. len(psk)
88: // must be 32.
89: func XChacha20Poly1305(psk []byte) (Cipher, error) {
90: 	if len(psk) != chacha20poly1305.KeySize {
91: 		return nil, KeySizeError(chacha20poly1305.KeySize)
92: 	}
93: 	return &metaCipher{psk: psk, makeAEAD: chacha20poly1305.NewX}, nil
94: }


./transport\shadowsocks\shadowaead\packet.go
1: package shadowaead
2: 
3: import (
4: 	"crypto/rand"
5: 	"errors"
6: 	"io"
7: 	"net"
8: 
9: 	"github.com/Dreamacro/clash/common/pool"
10: )
11: 
12: // ErrShortPacket means that the packet is too short for a valid encrypted packet.
13: var ErrShortPacket = errors.New("short packet")
14: 
15: var _zerononce [128]byte // read-only. 128 bytes is more than enough.
16: 
17: // Pack encrypts plaintext using Cipher with a randomly generated salt and
18: // returns a slice of dst containing the encrypted packet and any error occurred.
19: // Ensure len(dst) >= ciph.SaltSize() + len(plaintext) + aead.Overhead().
20: func Pack(dst, plaintext []byte, ciph Cipher) ([]byte, error) {
21: 	saltSize := ciph.SaltSize()
22: 	salt := dst[:saltSize]
23: 	if _, err := rand.Read(salt); err != nil {
24: 		return nil, err
25: 	}
26: 	aead, err := ciph.Encrypter(salt)
27: 	if err != nil {
28: 		return nil, err
29: 	}
30: 	if len(dst) < saltSize+len(plaintext)+aead.Overhead() {
31: 		return nil, io.ErrShortBuffer
32: 	}
33: 	b := aead.Seal(dst[saltSize:saltSize], _zerononce[:aead.NonceSize()], plaintext, nil)
34: 	return dst[:saltSize+len(b)], nil
35: }
36: 
37: // Unpack decrypts pkt using Cipher and returns a slice of dst containing the decrypted payload and any error occurred.
38: // Ensure len(dst) >= len(pkt) - aead.SaltSize() - aead.Overhead().
39: func Unpack(dst, pkt []byte, ciph Cipher) ([]byte, error) {
40: 	saltSize := ciph.SaltSize()
41: 	if len(pkt) < saltSize {
42: 		return nil, ErrShortPacket
43: 	}
44: 	salt := pkt[:saltSize]
45: 	aead, err := ciph.Decrypter(salt)
46: 	if err != nil {
47: 		return nil, err
48: 	}
49: 	if len(pkt) < saltSize+aead.Overhead() {
50: 		return nil, ErrShortPacket
51: 	}
52: 	if saltSize+len(dst)+aead.Overhead() < len(pkt) {
53: 		return nil, io.ErrShortBuffer
54: 	}
55: 	b, err := aead.Open(dst[:0], _zerononce[:aead.NonceSize()], pkt[saltSize:], nil)
56: 	return b, err
57: }
58: 
59: type PacketConn struct {
60: 	net.PacketConn
61: 	Cipher
62: }
63: 
64: const maxPacketSize = 64 * 1024
65: 
66: // NewPacketConn wraps a net.PacketConn with cipher
67: func NewPacketConn(c net.PacketConn, ciph Cipher) *PacketConn {
68: 	return &PacketConn{PacketConn: c, Cipher: ciph}
69: }
70: 
71: // WriteTo encrypts b and write to addr using the embedded PacketConn.
72: func (c *PacketConn) WriteTo(b []byte, addr net.Addr) (int, error) {
73: 	buf := pool.Get(maxPacketSize)
74: 	defer pool.Put(buf)
75: 	buf, err := Pack(buf, b, c)
76: 	if err != nil {
77: 		return 0, err
78: 	}
79: 	_, err = c.PacketConn.WriteTo(buf, addr)
80: 	return len(b), err
81: }
82: 
83: // ReadFrom reads from the embedded PacketConn and decrypts into b.
84: func (c *PacketConn) ReadFrom(b []byte) (int, net.Addr, error) {
85: 	n, addr, err := c.PacketConn.ReadFrom(b)
86: 	if err != nil {
87: 		return n, addr, err
88: 	}
89: 	bb, err := Unpack(b[c.Cipher.SaltSize():], b[:n], c)
90: 	if err != nil {
91: 		return n, addr, err
92: 	}
93: 	copy(b, bb)
94: 	return len(bb), addr, err
95: }


./transport\shadowsocks\shadowaead\stream.go
1: package shadowaead
2: 
3: import (
4: 	"crypto/cipher"
5: 	"crypto/rand"
6: 	"errors"
7: 	"io"
8: 	"net"
9: 
10: 	"github.com/Dreamacro/clash/common/pool"
11: )
12: 
13: const (
14: 	// payloadSizeMask is the maximum size of payload in bytes.
15: 	payloadSizeMask = 0x3FFF    // 16*1024 - 1
16: 	bufSize         = 17 * 1024 // >= 2+aead.Overhead()+payloadSizeMask+aead.Overhead()
17: )
18: 
19: var ErrZeroChunk = errors.New("zero chunk")
20: 
21: type Writer struct {
22: 	io.Writer
23: 	cipher.AEAD
24: 	nonce [32]byte // should be sufficient for most nonce sizes
25: }
26: 
27: // NewWriter wraps an io.Writer with authenticated encryption.
28: func NewWriter(w io.Writer, aead cipher.AEAD) *Writer { return &Writer{Writer: w, AEAD: aead} }
29: 
30: // Write encrypts p and writes to the embedded io.Writer.
31: func (w *Writer) Write(p []byte) (n int, err error) {
32: 	buf := pool.Get(bufSize)
33: 	defer pool.Put(buf)
34: 	nonce := w.nonce[:w.NonceSize()]
35: 	tag := w.Overhead()
36: 	off := 2 + tag
37: 
38: 	// compatible with snell
39: 	if len(p) == 0 {
40: 		buf = buf[:off]
41: 		buf[0], buf[1] = byte(0), byte(0)
42: 		w.Seal(buf[:0], nonce, buf[:2], nil)
43: 		increment(nonce)
44: 		_, err = w.Writer.Write(buf)
45: 		return
46: 	}
47: 
48: 	for nr := 0; n < len(p) && err == nil; n += nr {
49: 		nr = payloadSizeMask
50: 		if n+nr > len(p) {
51: 			nr = len(p) - n
52: 		}
53: 		buf = buf[:off+nr+tag]
54: 		buf[0], buf[1] = byte(nr>>8), byte(nr) // big-endian payload size
55: 		w.Seal(buf[:0], nonce, buf[:2], nil)
56: 		increment(nonce)
57: 		w.Seal(buf[:off], nonce, p[n:n+nr], nil)
58: 		increment(nonce)
59: 		_, err = w.Writer.Write(buf)
60: 	}
61: 	return
62: }
63: 
64: // ReadFrom reads from the given io.Reader until EOF or error, encrypts and
65: // writes to the embedded io.Writer. Returns number of bytes read from r and
66: // any error encountered.
67: func (w *Writer) ReadFrom(r io.Reader) (n int64, err error) {
68: 	buf := pool.Get(bufSize)
69: 	defer pool.Put(buf)
70: 	nonce := w.nonce[:w.NonceSize()]
71: 	tag := w.Overhead()
72: 	off := 2 + tag
73: 	for {
74: 		nr, er := r.Read(buf[off : off+payloadSizeMask])
75: 		n += int64(nr)
76: 		buf[0], buf[1] = byte(nr>>8), byte(nr)
77: 		w.Seal(buf[:0], nonce, buf[:2], nil)
78: 		increment(nonce)
79: 		w.Seal(buf[:off], nonce, buf[off:off+nr], nil)
80: 		increment(nonce)
81: 		if _, ew := w.Writer.Write(buf[:off+nr+tag]); ew != nil {
82: 			err = ew
83: 			return
84: 		}
85: 		if er != nil {
86: 			if er != io.EOF { // ignore EOF as per io.ReaderFrom contract
87: 				err = er
88: 			}
89: 			return
90: 		}
91: 	}
92: }
93: 
94: type Reader struct {
95: 	io.Reader
96: 	cipher.AEAD
97: 	nonce [32]byte // should be sufficient for most nonce sizes
98: 	buf   []byte   // to be put back into bufPool
99: 	off   int      // offset to unconsumed part of buf
100: }
101: 
102: // NewReader wraps an io.Reader with authenticated decryption.
103: func NewReader(r io.Reader, aead cipher.AEAD) *Reader { return &Reader{Reader: r, AEAD: aead} }
104: 
105: // Read and decrypt a record into p. len(p) >= max payload size + AEAD overhead.
106: func (r *Reader) read(p []byte) (int, error) {
107: 	nonce := r.nonce[:r.NonceSize()]
108: 	tag := r.Overhead()
109: 
110: 	// decrypt payload size
111: 	p = p[:2+tag]
112: 	if _, err := io.ReadFull(r.Reader, p); err != nil {
113: 		return 0, err
114: 	}
115: 	_, err := r.Open(p[:0], nonce, p, nil)
116: 	increment(nonce)
117: 	if err != nil {
118: 		return 0, err
119: 	}
120: 
121: 	// decrypt payload
122: 	size := (int(p[0])<<8 + int(p[1])) & payloadSizeMask
123: 	if size == 0 {
124: 		return 0, ErrZeroChunk
125: 	}
126: 
127: 	p = p[:size+tag]
128: 	if _, err := io.ReadFull(r.Reader, p); err != nil {
129: 		return 0, err
130: 	}
131: 	_, err = r.Open(p[:0], nonce, p, nil)
132: 	increment(nonce)
133: 	if err != nil {
134: 		return 0, err
135: 	}
136: 	return size, nil
137: }
138: 
139: // Read reads from the embedded io.Reader, decrypts and writes to p.
140: func (r *Reader) Read(p []byte) (int, error) {
141: 	if r.buf == nil {
142: 		if len(p) >= payloadSizeMask+r.Overhead() {
143: 			return r.read(p)
144: 		}
145: 		b := pool.Get(bufSize)
146: 		n, err := r.read(b)
147: 		if err != nil {
148: 			return 0, err
149: 		}
150: 		r.buf = b[:n]
151: 		r.off = 0
152: 	}
153: 
154: 	n := copy(p, r.buf[r.off:])
155: 	r.off += n
156: 	if r.off == len(r.buf) {
157: 		pool.Put(r.buf[:cap(r.buf)])
158: 		r.buf = nil
159: 	}
160: 	return n, nil
161: }
162: 
163: // WriteTo reads from the embedded io.Reader, decrypts and writes to w until
164: // there's no more data to write or when an error occurs. Return number of
165: // bytes written to w and any error encountered.
166: func (r *Reader) WriteTo(w io.Writer) (n int64, err error) {
167: 	if r.buf == nil {
168: 		r.buf = pool.Get(bufSize)
169: 		r.off = len(r.buf)
170: 	}
171: 
172: 	for {
173: 		for r.off < len(r.buf) {
174: 			nw, ew := w.Write(r.buf[r.off:])
175: 			r.off += nw
176: 			n += int64(nw)
177: 			if ew != nil {
178: 				if r.off == len(r.buf) {
179: 					pool.Put(r.buf[:cap(r.buf)])
180: 					r.buf = nil
181: 				}
182: 				err = ew
183: 				return
184: 			}
185: 		}
186: 
187: 		nr, er := r.read(r.buf)
188: 		if er != nil {
189: 			if er != io.EOF {
190: 				err = er
191: 			}
192: 			return
193: 		}
194: 		r.buf = r.buf[:nr]
195: 		r.off = 0
196: 	}
197: }
198: 
199: // increment little-endian encoded unsigned integer b. Wrap around on overflow.
200: func increment(b []byte) {
201: 	for i := range b {
202: 		b[i]++
203: 		if b[i] != 0 {
204: 			return
205: 		}
206: 	}
207: }
208: 
209: type Conn struct {
210: 	net.Conn
211: 	Cipher
212: 	r *Reader
213: 	w *Writer
214: }
215: 
216: // NewConn wraps a stream-oriented net.Conn with cipher.
217: func NewConn(c net.Conn, ciph Cipher) *Conn { return &Conn{Conn: c, Cipher: ciph} }
218: 
219: func (c *Conn) initReader() error {
220: 	salt := make([]byte, c.SaltSize())
221: 	if _, err := io.ReadFull(c.Conn, salt); err != nil {
222: 		return err
223: 	}
224: 
225: 	aead, err := c.Decrypter(salt)
226: 	if err != nil {
227: 		return err
228: 	}
229: 
230: 	c.r = NewReader(c.Conn, aead)
231: 	return nil
232: }
233: 
234: func (c *Conn) Read(b []byte) (int, error) {
235: 	if c.r == nil {
236: 		if err := c.initReader(); err != nil {
237: 			return 0, err
238: 		}
239: 	}
240: 	return c.r.Read(b)
241: }
242: 
243: func (c *Conn) WriteTo(w io.Writer) (int64, error) {
244: 	if c.r == nil {
245: 		if err := c.initReader(); err != nil {
246: 			return 0, err
247: 		}
248: 	}
249: 	return c.r.WriteTo(w)
250: }
251: 
252: func (c *Conn) initWriter() error {
253: 	salt := make([]byte, c.SaltSize())
254: 	if _, err := rand.Read(salt); err != nil {
255: 		return err
256: 	}
257: 	aead, err := c.Encrypter(salt)
258: 	if err != nil {
259: 		return err
260: 	}
261: 	_, err = c.Conn.Write(salt)
262: 	if err != nil {
263: 		return err
264: 	}
265: 	c.w = NewWriter(c.Conn, aead)
266: 	return nil
267: }
268: 
269: func (c *Conn) Write(b []byte) (int, error) {
270: 	if c.w == nil {
271: 		if err := c.initWriter(); err != nil {
272: 			return 0, err
273: 		}
274: 	}
275: 	return c.w.Write(b)
276: }
277: 
278: func (c *Conn) ReadFrom(r io.Reader) (int64, error) {
279: 	if c.w == nil {
280: 		if err := c.initWriter(); err != nil {
281: 			return 0, err
282: 		}
283: 	}
284: 	return c.w.ReadFrom(r)
285: }


./transport\shadowsocks\shadowstream\cipher.go
1: package shadowstream
2: 
3: import (
4: 	"crypto/aes"
5: 	"crypto/cipher"
6: 	"crypto/md5"
7: 	"crypto/rc4"
8: 	"strconv"
9: 
10: 	"golang.org/x/crypto/chacha20"
11: )
12: 
13: // Cipher generates a pair of stream ciphers for encryption and decryption.
14: type Cipher interface {
15: 	IVSize() int
16: 	Encrypter(iv []byte) cipher.Stream
17: 	Decrypter(iv []byte) cipher.Stream
18: }
19: 
20: type KeySizeError int
21: 
22: func (e KeySizeError) Error() string {
23: 	return "key size error: need " + strconv.Itoa(int(e)) + " bytes"
24: }
25: 
26: // CTR mode
27: type ctrStream struct{ cipher.Block }
28: 
29: func (b *ctrStream) IVSize() int                       { return b.BlockSize() }
30: func (b *ctrStream) Decrypter(iv []byte) cipher.Stream { return b.Encrypter(iv) }
31: func (b *ctrStream) Encrypter(iv []byte) cipher.Stream { return cipher.NewCTR(b, iv) }
32: 
33: func AESCTR(key []byte) (Cipher, error) {
34: 	blk, err := aes.NewCipher(key)
35: 	if err != nil {
36: 		return nil, err
37: 	}
38: 	return &ctrStream{blk}, nil
39: }
40: 
41: // CFB mode
42: type cfbStream struct{ cipher.Block }
43: 
44: func (b *cfbStream) IVSize() int                       { return b.BlockSize() }
45: func (b *cfbStream) Decrypter(iv []byte) cipher.Stream { return cipher.NewCFBDecrypter(b, iv) }
46: func (b *cfbStream) Encrypter(iv []byte) cipher.Stream { return cipher.NewCFBEncrypter(b, iv) }
47: 
48: func AESCFB(key []byte) (Cipher, error) {
49: 	blk, err := aes.NewCipher(key)
50: 	if err != nil {
51: 		return nil, err
52: 	}
53: 	return &cfbStream{blk}, nil
54: }
55: 
56: // IETF-variant of chacha20
57: type chacha20ietfkey []byte
58: 
59: func (k chacha20ietfkey) IVSize() int                       { return chacha20.NonceSize }
60: func (k chacha20ietfkey) Decrypter(iv []byte) cipher.Stream { return k.Encrypter(iv) }
61: func (k chacha20ietfkey) Encrypter(iv []byte) cipher.Stream {
62: 	ciph, err := chacha20.NewUnauthenticatedCipher(k, iv)
63: 	if err != nil {
64: 		panic(err) // should never happen
65: 	}
66: 	return ciph
67: }
68: 
69: func Chacha20IETF(key []byte) (Cipher, error) {
70: 	if len(key) != chacha20.KeySize {
71: 		return nil, KeySizeError(chacha20.KeySize)
72: 	}
73: 	return chacha20ietfkey(key), nil
74: }
75: 
76: type xchacha20key []byte
77: 
78: func (k xchacha20key) IVSize() int                       { return chacha20.NonceSizeX }
79: func (k xchacha20key) Decrypter(iv []byte) cipher.Stream { return k.Encrypter(iv) }
80: func (k xchacha20key) Encrypter(iv []byte) cipher.Stream {
81: 	ciph, err := chacha20.NewUnauthenticatedCipher(k, iv)
82: 	if err != nil {
83: 		panic(err) // should never happen
84: 	}
85: 	return ciph
86: }
87: 
88: func Xchacha20(key []byte) (Cipher, error) {
89: 	if len(key) != chacha20.KeySize {
90: 		return nil, KeySizeError(chacha20.KeySize)
91: 	}
92: 	return xchacha20key(key), nil
93: }
94: 
95: type rc4Md5Key []byte
96: 
97: func (k rc4Md5Key) IVSize() int {
98: 	return 16
99: }
100: 
101: func (k rc4Md5Key) Encrypter(iv []byte) cipher.Stream {
102: 	h := md5.New()
103: 	h.Write([]byte(k))
104: 	h.Write(iv)
105: 	rc4key := h.Sum(nil)
106: 	c, _ := rc4.NewCipher(rc4key)
107: 	return c
108: }
109: 
110: func (k rc4Md5Key) Decrypter(iv []byte) cipher.Stream {
111: 	return k.Encrypter(iv)
112: }
113: 
114: func RC4MD5(key []byte) (Cipher, error) {
115: 	return rc4Md5Key(key), nil
116: }


./transport\shadowsocks\shadowstream\packet.go
1: package shadowstream
2: 
3: import (
4: 	"crypto/rand"
5: 	"errors"
6: 	"io"
7: 	"net"
8: 
9: 	"github.com/Dreamacro/clash/common/pool"
10: )
11: 
12: // ErrShortPacket means the packet is too short to be a valid encrypted packet.
13: var ErrShortPacket = errors.New("short packet")
14: 
15: // Pack encrypts plaintext using stream cipher s and a random IV.
16: // Returns a slice of dst containing random IV and ciphertext.
17: // Ensure len(dst) >= s.IVSize() + len(plaintext).
18: func Pack(dst, plaintext []byte, s Cipher) ([]byte, error) {
19: 	if len(dst) < s.IVSize()+len(plaintext) {
20: 		return nil, io.ErrShortBuffer
21: 	}
22: 	iv := dst[:s.IVSize()]
23: 	_, err := rand.Read(iv)
24: 	if err != nil {
25: 		return nil, err
26: 	}
27: 	s.Encrypter(iv).XORKeyStream(dst[len(iv):], plaintext)
28: 	return dst[:len(iv)+len(plaintext)], nil
29: }
30: 
31: // Unpack decrypts pkt using stream cipher s.
32: // Returns a slice of dst containing decrypted plaintext.
33: func Unpack(dst, pkt []byte, s Cipher) ([]byte, error) {
34: 	if len(pkt) < s.IVSize() {
35: 		return nil, ErrShortPacket
36: 	}
37: 	if len(dst) < len(pkt)-s.IVSize() {
38: 		return nil, io.ErrShortBuffer
39: 	}
40: 	iv := pkt[:s.IVSize()]
41: 	s.Decrypter(iv).XORKeyStream(dst, pkt[len(iv):])
42: 	return dst[:len(pkt)-len(iv)], nil
43: }
44: 
45: type PacketConn struct {
46: 	net.PacketConn
47: 	Cipher
48: }
49: 
50: // NewPacketConn wraps a net.PacketConn with stream cipher encryption/decryption.
51: func NewPacketConn(c net.PacketConn, ciph Cipher) *PacketConn {
52: 	return &PacketConn{PacketConn: c, Cipher: ciph}
53: }
54: 
55: const maxPacketSize = 64 * 1024
56: 
57: func (c *PacketConn) WriteTo(b []byte, addr net.Addr) (int, error) {
58: 	buf := pool.Get(maxPacketSize)
59: 	defer pool.Put(buf)
60: 	buf, err := Pack(buf, b, c.Cipher)
61: 	if err != nil {
62: 		return 0, err
63: 	}
64: 	_, err = c.PacketConn.WriteTo(buf, addr)
65: 	return len(b), err
66: }
67: 
68: func (c *PacketConn) ReadFrom(b []byte) (int, net.Addr, error) {
69: 	n, addr, err := c.PacketConn.ReadFrom(b)
70: 	if err != nil {
71: 		return n, addr, err
72: 	}
73: 	bb, err := Unpack(b[c.IVSize():], b[:n], c.Cipher)
74: 	if err != nil {
75: 		return n, addr, err
76: 	}
77: 	copy(b, bb)
78: 	return len(bb), addr, err
79: }


./transport\shadowsocks\shadowstream\stream.go
1: package shadowstream
2: 
3: import (
4: 	"crypto/cipher"
5: 	"crypto/rand"
6: 	"io"
7: 	"net"
8: )
9: 
10: const bufSize = 2048
11: 
12: type Writer struct {
13: 	io.Writer
14: 	cipher.Stream
15: 	buf [bufSize]byte
16: }
17: 
18: // NewWriter wraps an io.Writer with stream cipher encryption.
19: func NewWriter(w io.Writer, s cipher.Stream) *Writer { return &Writer{Writer: w, Stream: s} }
20: 
21: func (w *Writer) Write(p []byte) (n int, err error) {
22: 	buf := w.buf[:]
23: 	for nw := 0; n < len(p) && err == nil; n += nw {
24: 		end := n + len(buf)
25: 		if end > len(p) {
26: 			end = len(p)
27: 		}
28: 		w.XORKeyStream(buf, p[n:end])
29: 		nw, err = w.Writer.Write(buf[:end-n])
30: 	}
31: 	return
32: }
33: 
34: func (w *Writer) ReadFrom(r io.Reader) (n int64, err error) {
35: 	buf := w.buf[:]
36: 	for {
37: 		nr, er := r.Read(buf)
38: 		n += int64(nr)
39: 		b := buf[:nr]
40: 		w.XORKeyStream(b, b)
41: 		if _, err = w.Writer.Write(b); err != nil {
42: 			return
43: 		}
44: 		if er != nil {
45: 			if er != io.EOF { // ignore EOF as per io.ReaderFrom contract
46: 				err = er
47: 			}
48: 			return
49: 		}
50: 	}
51: }
52: 
53: type Reader struct {
54: 	io.Reader
55: 	cipher.Stream
56: 	buf [bufSize]byte
57: }
58: 
59: // NewReader wraps an io.Reader with stream cipher decryption.
60: func NewReader(r io.Reader, s cipher.Stream) *Reader { return &Reader{Reader: r, Stream: s} }
61: 
62: func (r *Reader) Read(p []byte) (n int, err error) {
63: 	n, err = r.Reader.Read(p)
64: 	if err != nil {
65: 		return 0, err
66: 	}
67: 	r.XORKeyStream(p, p[:n])
68: 	return
69: }
70: 
71: func (r *Reader) WriteTo(w io.Writer) (n int64, err error) {
72: 	buf := r.buf[:]
73: 	for {
74: 		nr, er := r.Reader.Read(buf)
75: 		if nr > 0 {
76: 			r.XORKeyStream(buf, buf[:nr])
77: 			nw, ew := w.Write(buf[:nr])
78: 			n += int64(nw)
79: 			if ew != nil {
80: 				err = ew
81: 				return
82: 			}
83: 		}
84: 		if er != nil {
85: 			if er != io.EOF { // ignore EOF as per io.Copy contract (using src.WriteTo shortcut)
86: 				err = er
87: 			}
88: 			return
89: 		}
90: 	}
91: }
92: 
93: // A Conn represents a Shadowsocks connection. It implements the net.Conn interface.
94: type Conn struct {
95: 	net.Conn
96: 	Cipher
97: 	r       *Reader
98: 	w       *Writer
99: 	readIV  []byte
100: 	writeIV []byte
101: }
102: 
103: // NewConn wraps a stream-oriented net.Conn with stream cipher encryption/decryption.
104: func NewConn(c net.Conn, ciph Cipher) *Conn { return &Conn{Conn: c, Cipher: ciph} }
105: 
106: func (c *Conn) initReader() error {
107: 	if c.r == nil {
108: 		iv, err := c.ObtainReadIV()
109: 		if err != nil {
110: 			return err
111: 		}
112: 		c.r = NewReader(c.Conn, c.Decrypter(iv))
113: 	}
114: 	return nil
115: }
116: 
117: func (c *Conn) Read(b []byte) (int, error) {
118: 	if c.r == nil {
119: 		if err := c.initReader(); err != nil {
120: 			return 0, err
121: 		}
122: 	}
123: 	return c.r.Read(b)
124: }
125: 
126: func (c *Conn) WriteTo(w io.Writer) (int64, error) {
127: 	if c.r == nil {
128: 		if err := c.initReader(); err != nil {
129: 			return 0, err
130: 		}
131: 	}
132: 	return c.r.WriteTo(w)
133: }
134: 
135: func (c *Conn) initWriter() error {
136: 	if c.w == nil {
137: 		iv, err := c.ObtainWriteIV()
138: 		if err != nil {
139: 			return err
140: 		}
141: 		if _, err := c.Conn.Write(iv); err != nil {
142: 			return err
143: 		}
144: 		c.w = NewWriter(c.Conn, c.Encrypter(iv))
145: 	}
146: 	return nil
147: }
148: 
149: func (c *Conn) Write(b []byte) (int, error) {
150: 	if c.w == nil {
151: 		if err := c.initWriter(); err != nil {
152: 			return 0, err
153: 		}
154: 	}
155: 	return c.w.Write(b)
156: }
157: 
158: func (c *Conn) ReadFrom(r io.Reader) (int64, error) {
159: 	if c.w == nil {
160: 		if err := c.initWriter(); err != nil {
161: 			return 0, err
162: 		}
163: 	}
164: 	return c.w.ReadFrom(r)
165: }
166: 
167: func (c *Conn) ObtainWriteIV() ([]byte, error) {
168: 	if len(c.writeIV) == c.IVSize() {
169: 		return c.writeIV, nil
170: 	}
171: 
172: 	iv := make([]byte, c.IVSize())
173: 
174: 	if _, err := rand.Read(iv); err != nil {
175: 		return nil, err
176: 	}
177: 
178: 	c.writeIV = iv
179: 
180: 	return iv, nil
181: }
182: 
183: func (c *Conn) ObtainReadIV() ([]byte, error) {
184: 	if len(c.readIV) == c.IVSize() {
185: 		return c.readIV, nil
186: 	}
187: 
188: 	iv := make([]byte, c.IVSize())
189: 
190: 	if _, err := io.ReadFull(c.Conn, iv); err != nil {
191: 		return nil, err
192: 	}
193: 
194: 	c.readIV = iv
195: 
196: 	return iv, nil
197: }


./transport\simple-obfs\http.go
1: package obfs
2: 
3: import (
4: 	"bytes"
5: 	"crypto/rand"
6: 	"encoding/base64"
7: 	"fmt"
8: 	"io"
9: 	mathRand "math/rand"
10: 	"net"
11: 	"net/http"
12: 
13: 	"github.com/Dreamacro/clash/common/pool"
14: )
15: 
16: // HTTPObfs is shadowsocks http simple-obfs implementation
17: type HTTPObfs struct {
18: 	net.Conn
19: 	host          string
20: 	port          string
21: 	buf           []byte
22: 	offset        int
23: 	firstRequest  bool
24: 	firstResponse bool
25: }
26: 
27: func (ho *HTTPObfs) Read(b []byte) (int, error) {
28: 	if ho.buf != nil {
29: 		n := copy(b, ho.buf[ho.offset:])
30: 		ho.offset += n
31: 		if ho.offset == len(ho.buf) {
32: 			pool.Put(ho.buf)
33: 			ho.buf = nil
34: 		}
35: 		return n, nil
36: 	}
37: 
38: 	if ho.firstResponse {
39: 		buf := pool.Get(pool.RelayBufferSize)
40: 		n, err := ho.Conn.Read(buf)
41: 		if err != nil {
42: 			pool.Put(buf)
43: 			return 0, err
44: 		}
45: 		idx := bytes.Index(buf[:n], []byte("\r\n\r\n"))
46: 		if idx == -1 {
47: 			pool.Put(buf)
48: 			return 0, io.EOF
49: 		}
50: 		ho.firstResponse = false
51: 		length := n - (idx + 4)
52: 		n = copy(b, buf[idx+4:n])
53: 		if length > n {
54: 			ho.buf = buf[:idx+4+length]
55: 			ho.offset = idx + 4 + n
56: 		} else {
57: 			pool.Put(buf)
58: 		}
59: 		return n, nil
60: 	}
61: 	return ho.Conn.Read(b)
62: }
63: 
64: func (ho *HTTPObfs) Write(b []byte) (int, error) {
65: 	if ho.firstRequest {
66: 		randBytes := make([]byte, 16)
67: 		rand.Read(randBytes)
68: 		req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("http://%s/", ho.host), bytes.NewBuffer(b[:]))
69: 		req.Header.Set("User-Agent", fmt.Sprintf("curl/7.%d.%d", mathRand.Int()%54, mathRand.Int()%2))
70: 		req.Header.Set("Upgrade", "websocket")
71: 		req.Header.Set("Connection", "Upgrade")
72: 		req.Host = ho.host
73: 		if ho.port != "80" {
74: 			req.Host = fmt.Sprintf("%s:%s", ho.host, ho.port)
75: 		}
76: 		req.Header.Set("Sec-WebSocket-Key", base64.URLEncoding.EncodeToString(randBytes))
77: 		req.ContentLength = int64(len(b))
78: 		err := req.Write(ho.Conn)
79: 		ho.firstRequest = false
80: 		return len(b), err
81: 	}
82: 
83: 	return ho.Conn.Write(b)
84: }
85: 
86: // NewHTTPObfs return a HTTPObfs
87: func NewHTTPObfs(conn net.Conn, host string, port string) net.Conn {
88: 	return &HTTPObfs{
89: 		Conn:          conn,
90: 		firstRequest:  true,
91: 		firstResponse: true,
92: 		host:          host,
93: 		port:          port,
94: 	}
95: }


./transport\simple-obfs\tls.go
1: package obfs
2: 
3: import (
4: 	"crypto/rand"
5: 	"encoding/binary"
6: 	"io"
7: 	"net"
8: 	"time"
9: 
10: 	"github.com/Dreamacro/clash/common/pool"
11: 
12: 	"github.com/Dreamacro/protobytes"
13: )
14: 
15: const (
16: 	chunkSize = 1 << 14 // 2 ** 14 == 16 * 1024
17: )
18: 
19: // TLSObfs is shadowsocks tls simple-obfs implementation
20: type TLSObfs struct {
21: 	net.Conn
22: 	server        string
23: 	remain        int
24: 	firstRequest  bool
25: 	firstResponse bool
26: }
27: 
28: func (to *TLSObfs) read(b []byte, discardN int) (int, error) {
29: 	buf := pool.Get(discardN)
30: 	_, err := io.ReadFull(to.Conn, buf)
31: 	pool.Put(buf)
32: 	if err != nil {
33: 		return 0, err
34: 	}
35: 
36: 	sizeBuf := make([]byte, 2)
37: 	_, err = io.ReadFull(to.Conn, sizeBuf)
38: 	if err != nil {
39: 		return 0, nil
40: 	}
41: 
42: 	length := int(binary.BigEndian.Uint16(sizeBuf))
43: 	if length > len(b) {
44: 		n, err := to.Conn.Read(b)
45: 		if err != nil {
46: 			return n, err
47: 		}
48: 		to.remain = length - n
49: 		return n, nil
50: 	}
51: 
52: 	return io.ReadFull(to.Conn, b[:length])
53: }
54: 
55: func (to *TLSObfs) Read(b []byte) (int, error) {
56: 	if to.remain > 0 {
57: 		length := to.remain
58: 		if length > len(b) {
59: 			length = len(b)
60: 		}
61: 
62: 		n, err := io.ReadFull(to.Conn, b[:length])
63: 		to.remain -= n
64: 		return n, err
65: 	}
66: 
67: 	if to.firstResponse {
68: 		// type + ver + lensize + 91 = 96
69: 		// type + ver + lensize + 1 = 6
70: 		// type + ver = 3
71: 		to.firstResponse = false
72: 		return to.read(b, 105)
73: 	}
74: 
75: 	// type + ver = 3
76: 	return to.read(b, 3)
77: }
78: 
79: func (to *TLSObfs) Write(b []byte) (int, error) {
80: 	length := len(b)
81: 	for i := 0; i < length; i += chunkSize {
82: 		end := i + chunkSize
83: 		if end > length {
84: 			end = length
85: 		}
86: 
87: 		n, err := to.write(b[i:end])
88: 		if err != nil {
89: 			return n, err
90: 		}
91: 	}
92: 	return length, nil
93: }
94: 
95: func (to *TLSObfs) write(b []byte) (int, error) {
96: 	if to.firstRequest {
97: 		helloMsg := makeClientHelloMsg(b, to.server)
98: 		_, err := to.Conn.Write(helloMsg)
99: 		to.firstRequest = false
100: 		return len(b), err
101: 	}
102: 
103: 	buf := pool.GetBytesBuffer()
104: 	defer pool.PutBytesBuffer(buf)
105: 	buf.PutSlice([]byte{0x17, 0x03, 0x03})
106: 	buf.PutUint16be(uint16(len(b)))
107: 	buf.PutSlice(b)
108: 	_, err := to.Conn.Write(buf.Bytes())
109: 	return len(b), err
110: }
111: 
112: // NewTLSObfs return a SimpleObfs
113: func NewTLSObfs(conn net.Conn, server string) net.Conn {
114: 	return &TLSObfs{
115: 		Conn:          conn,
116: 		server:        server,
117: 		firstRequest:  true,
118: 		firstResponse: true,
119: 	}
120: }
121: 
122: func makeClientHelloMsg(data []byte, server string) []byte {
123: 	buf := protobytes.BytesWriter{}
124: 
125: 	// handshake, TLS 1.0 version, length
126: 	buf.PutUint8(22)
127: 	buf.PutSlice([]byte{0x03, 0x01})
128: 	length := uint16(212 + len(data) + len(server))
129: 	buf.PutUint16be(length)
130: 
131: 	// clientHello, length, TLS 1.2 version
132: 	buf.PutUint8(1)
133: 	buf.PutUint8(0)
134: 	buf.PutUint16be(uint16(208 + len(data) + len(server)))
135: 	buf.PutSlice([]byte{0x03, 0x03})
136: 
137: 	// random with timestamp, sid len, sid
138: 	buf.PutUint32be(uint32(time.Now().Unix()))
139: 	buf.ReadFull(rand.Reader, 28)
140: 	buf.PutUint8(32)
141: 	buf.ReadFull(rand.Reader, 32)
142: 
143: 	// cipher suites
144: 	buf.PutSlice([]byte{0x00, 0x38})
145: 	buf.PutSlice([]byte{
146: 		0xc0, 0x2c, 0xc0, 0x30, 0x00, 0x9f, 0xcc, 0xa9, 0xcc, 0xa8, 0xcc, 0xaa, 0xc0, 0x2b, 0xc0, 0x2f,
147: 		0x00, 0x9e, 0xc0, 0x24, 0xc0, 0x28, 0x00, 0x6b, 0xc0, 0x23, 0xc0, 0x27, 0x00, 0x67, 0xc0, 0x0a,
148: 		0xc0, 0x14, 0x00, 0x39, 0xc0, 0x09, 0xc0, 0x13, 0x00, 0x33, 0x00, 0x9d, 0x00, 0x9c, 0x00, 0x3d,
149: 		0x00, 0x3c, 0x00, 0x35, 0x00, 0x2f, 0x00, 0xff,
150: 	})
151: 
152: 	// compression
153: 	buf.PutSlice([]byte{0x01, 0x00})
154: 
155: 	// extension length
156: 	buf.PutUint16be(uint16(79 + len(data) + len(server)))
157: 
158: 	// session ticket
159: 	buf.PutSlice([]byte{0x00, 0x23})
160: 	buf.PutUint16be(uint16(len(data)))
161: 	buf.PutSlice(data)
162: 
163: 	// server name
164: 	buf.PutSlice([]byte{0x00, 0x00})
165: 	buf.PutUint16be(uint16(len(server) + 5))
166: 	buf.PutUint16be(uint16(len(server) + 3))
167: 	buf.PutUint8(0)
168: 	buf.PutUint16be(uint16(len(server)))
169: 	buf.PutSlice([]byte(server))
170: 
171: 	// ec_point
172: 	buf.PutSlice([]byte{0x00, 0x0b, 0x00, 0x04, 0x03, 0x01, 0x00, 0x02})
173: 
174: 	// groups
175: 	buf.PutSlice([]byte{0x00, 0x0a, 0x00, 0x0a, 0x00, 0x08, 0x00, 0x1d, 0x00, 0x17, 0x00, 0x19, 0x00, 0x18})
176: 
177: 	// signature
178: 	buf.PutSlice([]byte{
179: 		0x00, 0x0d, 0x00, 0x20, 0x00, 0x1e, 0x06, 0x01, 0x06, 0x02, 0x06, 0x03, 0x05,
180: 		0x01, 0x05, 0x02, 0x05, 0x03, 0x04, 0x01, 0x04, 0x02, 0x04, 0x03, 0x03, 0x01,
181: 		0x03, 0x02, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x03,
182: 	})
183: 
184: 	// encrypt then mac
185: 	buf.PutSlice([]byte{0x00, 0x16, 0x00, 0x00})
186: 
187: 	// extended master secret
188: 	buf.PutSlice([]byte{0x00, 0x17, 0x00, 0x00})
189: 
190: 	return buf.Bytes()
191: }


./transport\snell\cipher.go
1: package snell
2: 
3: import (
4: 	"crypto/aes"
5: 	"crypto/cipher"
6: 
7: 	"github.com/Dreamacro/clash/transport/shadowsocks/shadowaead"
8: 
9: 	"golang.org/x/crypto/argon2"
10: 	"golang.org/x/crypto/chacha20poly1305"
11: )
12: 
13: type snellCipher struct {
14: 	psk      []byte
15: 	keySize  int
16: 	makeAEAD func(key []byte) (cipher.AEAD, error)
17: }
18: 
19: func (sc *snellCipher) KeySize() int  { return sc.keySize }
20: func (sc *snellCipher) SaltSize() int { return 16 }
21: func (sc *snellCipher) Encrypter(salt []byte) (cipher.AEAD, error) {
22: 	return sc.makeAEAD(snellKDF(sc.psk, salt, sc.KeySize()))
23: }
24: 
25: func (sc *snellCipher) Decrypter(salt []byte) (cipher.AEAD, error) {
26: 	return sc.makeAEAD(snellKDF(sc.psk, salt, sc.KeySize()))
27: }
28: 
29: func snellKDF(psk, salt []byte, keySize int) []byte {
30: 	// snell use a special kdf function
31: 	return argon2.IDKey(psk, salt, 3, 8, 1, 32)[:keySize]
32: }
33: 
34: func aesGCM(key []byte) (cipher.AEAD, error) {
35: 	blk, err := aes.NewCipher(key)
36: 	if err != nil {
37: 		return nil, err
38: 	}
39: 	return cipher.NewGCM(blk)
40: }
41: 
42: func NewAES128GCM(psk []byte) shadowaead.Cipher {
43: 	return &snellCipher{
44: 		psk:      psk,
45: 		keySize:  16,
46: 		makeAEAD: aesGCM,
47: 	}
48: }
49: 
50: func NewChacha20Poly1305(psk []byte) shadowaead.Cipher {
51: 	return &snellCipher{
52: 		psk:      psk,
53: 		keySize:  32,
54: 		makeAEAD: chacha20poly1305.New,
55: 	}
56: }


./transport\snell\pool.go
1: package snell
2: 
3: import (
4: 	"context"
5: 	"net"
6: 	"time"
7: 
8: 	"github.com/Dreamacro/clash/component/pool"
9: 	"github.com/Dreamacro/clash/transport/shadowsocks/shadowaead"
10: )
11: 
12: type Pool struct {
13: 	pool *pool.Pool
14: }
15: 
16: func (p *Pool) Get() (net.Conn, error) {
17: 	return p.GetContext(context.Background())
18: }
19: 
20: func (p *Pool) GetContext(ctx context.Context) (net.Conn, error) {
21: 	elm, err := p.pool.GetContext(ctx)
22: 	if err != nil {
23: 		return nil, err
24: 	}
25: 
26: 	return &PoolConn{elm.(*Snell), p}, nil
27: }
28: 
29: func (p *Pool) Put(conn net.Conn) {
30: 	if err := HalfClose(conn); err != nil {
31: 		conn.Close()
32: 		return
33: 	}
34: 
35: 	p.pool.Put(conn)
36: }
37: 
38: type PoolConn struct {
39: 	*Snell
40: 	pool *Pool
41: }
42: 
43: func (pc *PoolConn) Read(b []byte) (int, error) {
44: 	// save old status of reply (it mutable by Read)
45: 	reply := pc.Snell.reply
46: 
47: 	n, err := pc.Snell.Read(b)
48: 	if err == shadowaead.ErrZeroChunk {
49: 		// if reply is false, it should be client halfclose.
50: 		// ignore error and read data again.
51: 		if !reply {
52: 			pc.Snell.reply = false
53: 			return pc.Snell.Read(b)
54: 		}
55: 	}
56: 	return n, err
57: }
58: 
59: func (pc *PoolConn) Write(b []byte) (int, error) {
60: 	return pc.Snell.Write(b)
61: }
62: 
63: func (pc *PoolConn) Close() error {
64: 	// clash use SetReadDeadline to break bidirectional copy between client and server.
65: 	// reset it before reuse connection to avoid io timeout error.
66: 	pc.Snell.Conn.SetReadDeadline(time.Time{})
67: 	pc.pool.Put(pc.Snell)
68: 	return nil
69: }
70: 
71: func NewPool(factory func(context.Context) (*Snell, error)) *Pool {
72: 	p := pool.New(
73: 		func(ctx context.Context) (any, error) {
74: 			return factory(ctx)
75: 		},
76: 		pool.WithAge(15000),
77: 		pool.WithSize(10),
78: 		pool.WithEvict(func(item any) {
79: 			item.(*Snell).Close()
80: 		}),
81: 	)
82: 
83: 	return &Pool{p}
84: }


./transport\snell\snell.go
1: package snell
2: 
3: import (
4: 	"errors"
5: 	"fmt"
6: 	"io"
7: 	"net"
8: 	"sync"
9: 
10: 	"github.com/Dreamacro/clash/common/pool"
11: 	"github.com/Dreamacro/clash/transport/shadowsocks/shadowaead"
12: 	"github.com/Dreamacro/clash/transport/socks5"
13: )
14: 
15: const (
16: 	Version1            = 1
17: 	Version2            = 2
18: 	Version3            = 3
19: 	DefaultSnellVersion = Version1
20: 
21: 	// max packet length
22: 	maxLength = 0x3FFF
23: )
24: 
25: const (
26: 	CommandPing       byte = 0
27: 	CommandConnect    byte = 1
28: 	CommandConnectV2  byte = 5
29: 	CommandUDP        byte = 6
30: 	CommondUDPForward byte = 1
31: 
32: 	CommandTunnel byte = 0
33: 	CommandPong   byte = 1
34: 	CommandError  byte = 2
35: 
36: 	Version byte = 1
37: )
38: 
39: var endSignal = []byte{}
40: 
41: type Snell struct {
42: 	net.Conn
43: 	buffer [1]byte
44: 	reply  bool
45: }
46: 
47: func (s *Snell) Read(b []byte) (int, error) {
48: 	if s.reply {
49: 		return s.Conn.Read(b)
50: 	}
51: 
52: 	s.reply = true
53: 	if _, err := io.ReadFull(s.Conn, s.buffer[:]); err != nil {
54: 		return 0, err
55: 	}
56: 
57: 	if s.buffer[0] == CommandTunnel {
58: 		return s.Conn.Read(b)
59: 	} else if s.buffer[0] != CommandError {
60: 		return 0, errors.New("command not support")
61: 	}
62: 
63: 	// CommandError
64: 	// 1 byte error code
65: 	if _, err := io.ReadFull(s.Conn, s.buffer[:]); err != nil {
66: 		return 0, err
67: 	}
68: 	errcode := int(s.buffer[0])
69: 
70: 	// 1 byte error message length
71: 	if _, err := io.ReadFull(s.Conn, s.buffer[:]); err != nil {
72: 		return 0, err
73: 	}
74: 	length := int(s.buffer[0])
75: 	msg := make([]byte, length)
76: 
77: 	if _, err := io.ReadFull(s.Conn, msg); err != nil {
78: 		return 0, err
79: 	}
80: 
81: 	return 0, fmt.Errorf("server reported code: %d, message: %s", errcode, string(msg))
82: }
83: 
84: func WriteHeader(conn net.Conn, host string, port uint, version int) error {
85: 	buf := pool.GetBytesBuffer()
86: 	defer pool.PutBytesBuffer(buf)
87: 	buf.PutUint8(Version)
88: 	if version == Version2 {
89: 		buf.PutUint8(CommandConnectV2)
90: 	} else {
91: 		buf.PutUint8(CommandConnect)
92: 	}
93: 
94: 	// clientID length & id
95: 	buf.PutUint8(0)
96: 
97: 	// host & port
98: 	buf.PutUint8(uint8(len(host)))
99: 	buf.PutString(host)
100: 	buf.PutUint16be(uint16(port))
101: 
102: 	if _, err := conn.Write(buf.Bytes()); err != nil {
103: 		return err
104: 	}
105: 
106: 	return nil
107: }
108: 
109: func WriteUDPHeader(conn net.Conn, version int) error {
110: 	if version < Version3 {
111: 		return errors.New("unsupport UDP version")
112: 	}
113: 
114: 	// version, command, clientID length
115: 	_, err := conn.Write([]byte{Version, CommandUDP, 0x00})
116: 	return err
117: }
118: 
119: // HalfClose works only on version2
120: func HalfClose(conn net.Conn) error {
121: 	if _, err := conn.Write(endSignal); err != nil {
122: 		return err
123: 	}
124: 
125: 	if s, ok := conn.(*Snell); ok {
126: 		s.reply = false
127: 	}
128: 	return nil
129: }
130: 
131: func StreamConn(conn net.Conn, psk []byte, version int) *Snell {
132: 	var cipher shadowaead.Cipher
133: 	if version != Version1 {
134: 		cipher = NewAES128GCM(psk)
135: 	} else {
136: 		cipher = NewChacha20Poly1305(psk)
137: 	}
138: 	return &Snell{Conn: shadowaead.NewConn(conn, cipher)}
139: }
140: 
141: func PacketConn(conn net.Conn) net.PacketConn {
142: 	return &packetConn{
143: 		Conn: conn,
144: 	}
145: }
146: 
147: func writePacket(w io.Writer, socks5Addr, payload []byte) (int, error) {
148: 	buf := pool.GetBytesBuffer()
149: 	defer pool.PutBytesBuffer(buf)
150: 
151: 	// compose snell UDP address format (refer: icpz/snell-server-reversed)
152: 	// a brand new wheel to replace socks5 address format, well done Yachen
153: 	buf.PutUint8(CommondUDPForward)
154: 	switch socks5Addr[0] {
155: 	case socks5.AtypDomainName:
156: 		hostLen := socks5Addr[1]
157: 		buf.PutSlice(socks5Addr[1 : 1+1+hostLen+2])
158: 	case socks5.AtypIPv4:
159: 		buf.PutSlice([]byte{0x00, 0x04})
160: 		buf.PutSlice(socks5Addr[1 : 1+net.IPv4len+2])
161: 	case socks5.AtypIPv6:
162: 		buf.PutSlice([]byte{0x00, 0x06})
163: 		buf.PutSlice(socks5Addr[1 : 1+net.IPv6len+2])
164: 	}
165: 
166: 	buf.PutSlice(payload)
167: 	_, err := w.Write(buf.Bytes())
168: 	if err != nil {
169: 		return 0, err
170: 	}
171: 	return len(payload), nil
172: }
173: 
174: func WritePacket(w io.Writer, socks5Addr, payload []byte) (int, error) {
175: 	if len(payload) <= maxLength {
176: 		return writePacket(w, socks5Addr, payload)
177: 	}
178: 
179: 	offset := 0
180: 	total := len(payload)
181: 	for {
182: 		cursor := offset + maxLength
183: 		if cursor > total {
184: 			cursor = total
185: 		}
186: 
187: 		n, err := writePacket(w, socks5Addr, payload[offset:cursor])
188: 		if err != nil {
189: 			return offset + n, err
190: 		}
191: 
192: 		offset = cursor
193: 		if offset == total {
194: 			break
195: 		}
196: 	}
197: 
198: 	return total, nil
199: }
200: 
201: func ReadPacket(r io.Reader, payload []byte) (net.Addr, int, error) {
202: 	buf := pool.Get(pool.UDPBufferSize)
203: 	defer pool.Put(buf)
204: 
205: 	n, err := r.Read(buf)
206: 	headLen := 1
207: 	if err != nil {
208: 		return nil, 0, err
209: 	}
210: 	if n < headLen {
211: 		return nil, 0, errors.New("insufficient UDP length")
212: 	}
213: 
214: 	// parse snell UDP response address format
215: 	switch buf[0] {
216: 	case 0x04:
217: 		headLen += net.IPv4len + 2
218: 		if n < headLen {
219: 			err = errors.New("insufficient UDP length")
220: 			break
221: 		}
222: 		buf[0] = socks5.AtypIPv4
223: 	case 0x06:
224: 		headLen += net.IPv6len + 2
225: 		if n < headLen {
226: 			err = errors.New("insufficient UDP length")
227: 			break
228: 		}
229: 		buf[0] = socks5.AtypIPv6
230: 	default:
231: 		err = errors.New("ip version invalid")
232: 	}
233: 
234: 	if err != nil {
235: 		return nil, 0, err
236: 	}
237: 
238: 	addr := socks5.SplitAddr(buf[0:])
239: 	if addr == nil {
240: 		return nil, 0, errors.New("remote address invalid")
241: 	}
242: 	uAddr := addr.UDPAddr()
243: 	if uAddr == nil {
244: 		return nil, 0, errors.New("parse addr error")
245: 	}
246: 
247: 	length := len(payload)
248: 	if n-headLen < length {
249: 		length = n - headLen
250: 	}
251: 	copy(payload[:], buf[headLen:headLen+length])
252: 
253: 	return uAddr, length, nil
254: }
255: 
256: type packetConn struct {
257: 	net.Conn
258: 	rMux sync.Mutex
259: 	wMux sync.Mutex
260: }
261: 
262: func (pc *packetConn) WriteTo(b []byte, addr net.Addr) (int, error) {
263: 	pc.wMux.Lock()
264: 	defer pc.wMux.Unlock()
265: 
266: 	return WritePacket(pc, socks5.ParseAddr(addr.String()), b)
267: }
268: 
269: func (pc *packetConn) ReadFrom(b []byte) (int, net.Addr, error) {
270: 	pc.rMux.Lock()
271: 	defer pc.rMux.Unlock()
272: 
273: 	addr, n, err := ReadPacket(pc.Conn, b)
274: 	if err != nil {
275: 		return 0, nil, err
276: 	}
277: 
278: 	return n, addr, nil
279: }


./transport\socks4\socks4.go
1: package socks4
2: 
3: import (
4: 	"errors"
5: 	"io"
6: 	"net"
7: 	"net/netip"
8: 	"strconv"
9: 
10: 	"github.com/Dreamacro/clash/component/auth"
11: 
12: 	"github.com/Dreamacro/protobytes"
13: )
14: 
15: const Version = 0x04
16: 
17: type Command = uint8
18: 
19: const (
20: 	CmdConnect Command = 0x01
21: 	CmdBind    Command = 0x02
22: )
23: 
24: type Code = uint8
25: 
26: const (
27: 	RequestGranted          Code = 90
28: 	RequestRejected         Code = 91
29: 	RequestIdentdFailed     Code = 92
30: 	RequestIdentdMismatched Code = 93
31: )
32: 
33: var (
34: 	errVersionMismatched   = errors.New("version code mismatched")
35: 	errCommandNotSupported = errors.New("command not supported")
36: 	errIPv6NotSupported    = errors.New("IPv6 not supported")
37: 
38: 	ErrRequestRejected         = errors.New("request rejected or failed")
39: 	ErrRequestIdentdFailed     = errors.New("request rejected because SOCKS server cannot connect to identd on the client")
40: 	ErrRequestIdentdMismatched = errors.New("request rejected because the client program and identd report different user-ids")
41: 	ErrRequestUnknownCode      = errors.New("request failed with unknown code")
42: )
43: 
44: func ServerHandshake(rw io.ReadWriter, authenticator auth.Authenticator) (addr string, command Command, err error) {
45: 	var req [8]byte
46: 	if _, err = io.ReadFull(rw, req[:]); err != nil {
47: 		return
48: 	}
49: 
50: 	r := protobytes.BytesReader(req[:])
51: 	if r.ReadUint8() != Version {
52: 		err = errVersionMismatched
53: 		return
54: 	}
55: 
56: 	if command = r.ReadUint8(); command != CmdConnect {
57: 		err = errCommandNotSupported
58: 		return
59: 	}
60: 
61: 	var (
62: 		host   string
63: 		port   string
64: 		code   uint8
65: 		userID []byte
66: 	)
67: 	if userID, err = readUntilNull(rw); err != nil {
68: 		return
69: 	}
70: 
71: 	dstPort := r.ReadUint16be()
72: 	dstAddr := r.ReadIPv4()
73: 	if isReservedIP(dstAddr) {
74: 		var target []byte
75: 		if target, err = readUntilNull(rw); err != nil {
76: 			return
77: 		}
78: 		host = string(target)
79: 	}
80: 
81: 	port = strconv.Itoa(int(dstPort))
82: 	if host != "" {
83: 		addr = net.JoinHostPort(host, port)
84: 	} else {
85: 		addr = net.JoinHostPort(dstAddr.String(), port)
86: 	}
87: 
88: 	// SOCKS4 only support USERID auth.
89: 	if authenticator == nil || authenticator.Verify(string(userID), "") {
90: 		code = RequestGranted
91: 	} else {
92: 		code = RequestIdentdMismatched
93: 		err = ErrRequestIdentdMismatched
94: 	}
95: 
96: 	reply := protobytes.BytesWriter(make([]byte, 0, 8))
97: 	reply.PutUint8(0)    // reply code
98: 	reply.PutUint8(code) // result code
99: 	reply.PutUint16be(dstPort)
100: 	reply.PutSlice(dstAddr.AsSlice())
101: 
102: 	_, wErr := rw.Write(reply.Bytes())
103: 	if err == nil {
104: 		err = wErr
105: 	}
106: 	return
107: }
108: 
109: func ClientHandshake(rw io.ReadWriter, addr string, command Command, userID string) (err error) {
110: 	host, portStr, err := net.SplitHostPort(addr)
111: 	if err != nil {
112: 		return err
113: 	}
114: 
115: 	port, err := strconv.ParseUint(portStr, 10, 16)
116: 	if err != nil {
117: 		return err
118: 	}
119: 
120: 	ip, err := netip.ParseAddr(host)
121: 	if err != nil { // Host
122: 		ip = netip.AddrFrom4([4]byte{0, 0, 0, 1})
123: 	} else if ip.Is6() { // IPv6
124: 		return errIPv6NotSupported
125: 	}
126: 
127: 	req := protobytes.BytesWriter{}
128: 	req.PutUint8(Version)
129: 	req.PutUint8(command)
130: 	req.PutUint16be(uint16(port))
131: 	req.PutSlice(ip.AsSlice())
132: 	req.PutString(userID)
133: 	req.PutUint8(0) /* NULL */
134: 
135: 	if isReservedIP(ip) /* SOCKS4A */ {
136: 		req.PutString(host)
137: 		req.PutUint8(0) /* NULL */
138: 	}
139: 
140: 	if _, err = rw.Write(req.Bytes()); err != nil {
141: 		return err
142: 	}
143: 
144: 	var resp [8]byte
145: 	if _, err = io.ReadFull(rw, resp[:]); err != nil {
146: 		return err
147: 	}
148: 
149: 	if resp[0] != 0x00 {
150: 		return errVersionMismatched
151: 	}
152: 
153: 	switch resp[1] {
154: 	case RequestGranted:
155: 		return nil
156: 	case RequestRejected:
157: 		return ErrRequestRejected
158: 	case RequestIdentdFailed:
159: 		return ErrRequestIdentdFailed
160: 	case RequestIdentdMismatched:
161: 		return ErrRequestIdentdMismatched
162: 	default:
163: 		return ErrRequestUnknownCode
164: 	}
165: }
166: 
167: // For version 4A, if the client cannot resolve the destination host's
168: // domain name to find its IP address, it should set the first three bytes
169: // of DSTIP to NULL and the last byte to a non-zero value. (This corresponds
170: // to IP address 0.0.0.x, with x nonzero. As decreed by IANA  -- The
171: // Internet Assigned Numbers Authority -- such an address is inadmissible
172: // as a destination IP address and thus should never occur if the client
173: // can resolve the domain name.)
174: func isReservedIP(ip netip.Addr) bool {
175: 	subnet := netip.PrefixFrom(
176: 		netip.AddrFrom4([4]byte{0, 0, 0, 0}),
177: 		24,
178: 	)
179: 
180: 	return !ip.IsUnspecified() && subnet.Contains(ip)
181: }
182: 
183: func readUntilNull(r io.Reader) ([]byte, error) {
184: 	buf := protobytes.BytesWriter{}
185: 	var data [1]byte
186: 
187: 	for {
188: 		if _, err := r.Read(data[:]); err != nil {
189: 			return nil, err
190: 		}
191: 		if data[0] == 0 {
192: 			return buf.Bytes(), nil
193: 		}
194: 		buf.PutUint8(data[0])
195: 	}
196: }


./transport\socks5\socks5.go
1: package socks5
2: 
3: import (
4: 	"bytes"
5: 	"encoding/binary"
6: 	"errors"
7: 	"io"
8: 	"net"
9: 	"net/netip"
10: 	"strconv"
11: 
12: 	"github.com/Dreamacro/clash/component/auth"
13: 
14: 	"github.com/Dreamacro/protobytes"
15: )
16: 
17: // Error represents a SOCKS error
18: type Error byte
19: 
20: func (err Error) Error() string {
21: 	return "SOCKS error: " + strconv.Itoa(int(err))
22: }
23: 
24: // Command is request commands as defined in RFC 1928 section 4.
25: type Command = uint8
26: 
27: const Version = 5
28: 
29: // SOCKS request commands as defined in RFC 1928 section 4.
30: const (
31: 	CmdConnect      Command = 1
32: 	CmdBind         Command = 2
33: 	CmdUDPAssociate Command = 3
34: )
35: 
36: // SOCKS address types as defined in RFC 1928 section 5.
37: const (
38: 	AtypIPv4       = 1
39: 	AtypDomainName = 3
40: 	AtypIPv6       = 4
41: )
42: 
43: // MaxAddrLen is the maximum size of SOCKS address in bytes.
44: const MaxAddrLen = 1 + 1 + 255 + 2
45: 
46: // MaxAuthLen is the maximum size of user/password field in SOCKS5 Auth
47: const MaxAuthLen = 255
48: 
49: // Addr represents a SOCKS address as defined in RFC 1928 section 5.
50: type Addr []byte
51: 
52: func (a Addr) String() string {
53: 	var host, port string
54: 
55: 	switch a[0] {
56: 	case AtypDomainName:
57: 		hostLen := uint16(a[1])
58: 		host = string(a[2 : 2+hostLen])
59: 		port = strconv.Itoa((int(a[2+hostLen]) << 8) | int(a[2+hostLen+1]))
60: 	case AtypIPv4:
61: 		host = net.IP(a[1 : 1+net.IPv4len]).String()
62: 		port = strconv.Itoa((int(a[1+net.IPv4len]) << 8) | int(a[1+net.IPv4len+1]))
63: 	case AtypIPv6:
64: 		host = net.IP(a[1 : 1+net.IPv6len]).String()
65: 		port = strconv.Itoa((int(a[1+net.IPv6len]) << 8) | int(a[1+net.IPv6len+1]))
66: 	}
67: 
68: 	return net.JoinHostPort(host, port)
69: }
70: 
71: // UDPAddr converts a socks5.Addr to *net.UDPAddr
72: func (a Addr) UDPAddr() *net.UDPAddr {
73: 	if len(a) == 0 {
74: 		return nil
75: 	}
76: 	switch a[0] {
77: 	case AtypIPv4:
78: 		var ip [net.IPv4len]byte
79: 		copy(ip[0:], a[1:1+net.IPv4len])
80: 		return &net.UDPAddr{IP: net.IP(ip[:]), Port: int(binary.BigEndian.Uint16(a[1+net.IPv4len : 1+net.IPv4len+2]))}
81: 	case AtypIPv6:
82: 		var ip [net.IPv6len]byte
83: 		copy(ip[0:], a[1:1+net.IPv6len])
84: 		return &net.UDPAddr{IP: net.IP(ip[:]), Port: int(binary.BigEndian.Uint16(a[1+net.IPv6len : 1+net.IPv6len+2]))}
85: 	}
86: 	// Other Atyp
87: 	return nil
88: }
89: 
90: // SOCKS errors as defined in RFC 1928 section 6.
91: const (
92: 	ErrGeneralFailure       = Error(1)
93: 	ErrConnectionNotAllowed = Error(2)
94: 	ErrNetworkUnreachable   = Error(3)
95: 	ErrHostUnreachable      = Error(4)
96: 	ErrConnectionRefused    = Error(5)
97: 	ErrTTLExpired           = Error(6)
98: 	ErrCommandNotSupported  = Error(7)
99: 	ErrAddressNotSupported  = Error(8)
100: )
101: 
102: // Auth errors used to return a specific "Auth failed" error
103: var ErrAuth = errors.New("auth failed")
104: 
105: type User struct {
106: 	Username string
107: 	Password string
108: }
109: 
110: // ServerHandshake fast-tracks SOCKS initialization to get target address to connect on server side.
111: func ServerHandshake(rw net.Conn, authenticator auth.Authenticator) (addr Addr, command Command, err error) {
112: 	// Read RFC 1928 for request and reply structure and sizes.
113: 	buf := make([]byte, MaxAddrLen)
114: 	// read VER, NMETHODS, METHODS
115: 	if _, err = io.ReadFull(rw, buf[:2]); err != nil {
116: 		return
117: 	}
118: 	nmethods := buf[1]
119: 	if _, err = io.ReadFull(rw, buf[:nmethods]); err != nil {
120: 		return
121: 	}
122: 
123: 	// write VER METHOD
124: 	if authenticator != nil {
125: 		if _, err = rw.Write([]byte{5, 2}); err != nil {
126: 			return
127: 		}
128: 
129: 		// Get header
130: 		header := make([]byte, 2)
131: 		if _, err = io.ReadFull(rw, header); err != nil {
132: 			return
133: 		}
134: 
135: 		authBuf := make([]byte, MaxAuthLen)
136: 		// Get username
137: 		userLen := int(header[1])
138: 		if userLen <= 0 {
139: 			rw.Write([]byte{1, 1})
140: 			err = ErrAuth
141: 			return
142: 		}
143: 		if _, err = io.ReadFull(rw, authBuf[:userLen]); err != nil {
144: 			return
145: 		}
146: 		user := string(authBuf[:userLen])
147: 
148: 		// Get password
149: 		if _, err = rw.Read(header[:1]); err != nil {
150: 			return
151: 		}
152: 		passLen := int(header[0])
153: 		if passLen <= 0 {
154: 			rw.Write([]byte{1, 1})
155: 			err = ErrAuth
156: 			return
157: 		}
158: 		if _, err = io.ReadFull(rw, authBuf[:passLen]); err != nil {
159: 			return
160: 		}
161: 		pass := string(authBuf[:passLen])
162: 
163: 		// Verify
164: 		if ok := authenticator.Verify(user, pass); !ok {
165: 			rw.Write([]byte{1, 1})
166: 			err = ErrAuth
167: 			return
168: 		}
169: 
170: 		// Response auth state
171: 		if _, err = rw.Write([]byte{1, 0}); err != nil {
172: 			return
173: 		}
174: 	} else {
175: 		if _, err = rw.Write([]byte{5, 0}); err != nil {
176: 			return
177: 		}
178: 	}
179: 
180: 	// read VER CMD RSV ATYP DST.ADDR DST.PORT
181: 	if _, err = io.ReadFull(rw, buf[:3]); err != nil {
182: 		return
183: 	}
184: 
185: 	command = buf[1]
186: 	addr, err = ReadAddr(rw, buf)
187: 	if err != nil {
188: 		return
189: 	}
190: 
191: 	switch command {
192: 	case CmdConnect, CmdUDPAssociate:
193: 		// Acquire server listened address info
194: 		localAddr := ParseAddr(rw.LocalAddr().String())
195: 		if localAddr == nil {
196: 			err = ErrAddressNotSupported
197: 		} else {
198: 			// write VER REP RSV ATYP BND.ADDR BND.PORT
199: 			_, err = rw.Write(bytes.Join([][]byte{{5, 0, 0}, localAddr}, []byte{}))
200: 		}
201: 	case CmdBind:
202: 		fallthrough
203: 	default:
204: 		err = ErrCommandNotSupported
205: 	}
206: 
207: 	return
208: }
209: 
210: // ClientHandshake fast-tracks SOCKS initialization to get target address to connect on client side.
211: func ClientHandshake(rw io.ReadWriter, addr Addr, command Command, user *User) (Addr, error) {
212: 	buf := make([]byte, MaxAddrLen)
213: 	var err error
214: 
215: 	// VER, NMETHODS, METHODS
216: 	if user != nil {
217: 		_, err = rw.Write([]byte{5, 1, 2})
218: 	} else {
219: 		_, err = rw.Write([]byte{5, 1, 0})
220: 	}
221: 	if err != nil {
222: 		return nil, err
223: 	}
224: 
225: 	// VER, METHOD
226: 	if _, err := io.ReadFull(rw, buf[:2]); err != nil {
227: 		return nil, err
228: 	}
229: 
230: 	if buf[0] != 5 {
231: 		return nil, errors.New("SOCKS version error")
232: 	}
233: 
234: 	if buf[1] == 2 {
235: 		if user == nil {
236: 			return nil, ErrAuth
237: 		}
238: 
239: 		// password protocol version
240: 		authMsg := protobytes.BytesWriter{}
241: 		authMsg.PutUint8(1)
242: 		authMsg.PutUint8(uint8(len(user.Username)))
243: 		authMsg.PutString(user.Username)
244: 		authMsg.PutUint8(uint8(len(user.Password)))
245: 		authMsg.PutString(user.Password)
246: 
247: 		if _, err := rw.Write(authMsg.Bytes()); err != nil {
248: 			return nil, err
249: 		}
250: 
251: 		if _, err := io.ReadFull(rw, buf[:2]); err != nil {
252: 			return nil, err
253: 		}
254: 
255: 		if buf[1] != 0 {
256: 			return nil, errors.New("rejected username/password")
257: 		}
258: 	} else if buf[1] != 0 {
259: 		return nil, errors.New("SOCKS need auth")
260: 	}
261: 
262: 	// VER, CMD, RSV, ADDR
263: 	if _, err := rw.Write(bytes.Join([][]byte{{5, command, 0}, addr}, []byte{})); err != nil {
264: 		return nil, err
265: 	}
266: 
267: 	// VER, REP, RSV
268: 	if _, err := io.ReadFull(rw, buf[:3]); err != nil {
269: 		return nil, err
270: 	}
271: 
272: 	return ReadAddr(rw, buf)
273: }
274: 
275: func ReadAddr(r io.Reader, b []byte) (Addr, error) {
276: 	if len(b) < MaxAddrLen {
277: 		return nil, io.ErrShortBuffer
278: 	}
279: 	_, err := io.ReadFull(r, b[:1]) // read 1st byte for address type
280: 	if err != nil {
281: 		return nil, err
282: 	}
283: 
284: 	switch b[0] {
285: 	case AtypDomainName:
286: 		_, err = io.ReadFull(r, b[1:2]) // read 2nd byte for domain length
287: 		if err != nil {
288: 			return nil, err
289: 		}
290: 		domainLength := uint16(b[1])
291: 		_, err = io.ReadFull(r, b[2:2+domainLength+2])
292: 		return b[:1+1+domainLength+2], err
293: 	case AtypIPv4:
294: 		_, err = io.ReadFull(r, b[1:1+net.IPv4len+2])
295: 		return b[:1+net.IPv4len+2], err
296: 	case AtypIPv6:
297: 		_, err = io.ReadFull(r, b[1:1+net.IPv6len+2])
298: 		return b[:1+net.IPv6len+2], err
299: 	}
300: 
301: 	return nil, ErrAddressNotSupported
302: }
303: 
304: // SplitAddr slices a SOCKS address from beginning of b. Returns nil if failed.
305: func SplitAddr(b []byte) Addr {
306: 	addrLen := 1
307: 	if len(b) < addrLen {
308: 		return nil
309: 	}
310: 
311: 	switch b[0] {
312: 	case AtypDomainName:
313: 		if len(b) < 2 {
314: 			return nil
315: 		}
316: 		addrLen = 1 + 1 + int(b[1]) + 2
317: 	case AtypIPv4:
318: 		addrLen = 1 + net.IPv4len + 2
319: 	case AtypIPv6:
320: 		addrLen = 1 + net.IPv6len + 2
321: 	default:
322: 		return nil
323: 
324: 	}
325: 
326: 	if len(b) < addrLen {
327: 		return nil
328: 	}
329: 
330: 	return b[:addrLen]
331: }
332: 
333: // ParseAddr parses the address in string s. Returns nil if failed.
334: func ParseAddr(s string) Addr {
335: 	buf := protobytes.BytesWriter{}
336: 	host, port, err := net.SplitHostPort(s)
337: 	if err != nil {
338: 		return nil
339: 	}
340: 	if ip := net.ParseIP(host); ip != nil {
341: 		if ip4 := ip.To4(); ip4 != nil {
342: 			buf.PutUint8(AtypIPv4)
343: 			buf.PutSlice(ip4)
344: 		} else {
345: 			buf.PutUint8(AtypIPv6)
346: 			buf.PutSlice(ip)
347: 		}
348: 	} else {
349: 		if len(host) > 255 {
350: 			return nil
351: 		}
352: 		buf.PutUint8(AtypDomainName)
353: 		buf.PutUint8(byte(len(host)))
354: 		buf.PutString(host)
355: 	}
356: 
357: 	portnum, err := strconv.ParseUint(port, 10, 16)
358: 	if err != nil {
359: 		return nil
360: 	}
361: 
362: 	buf.PutUint16be(uint16(portnum))
363: 	return Addr(buf.Bytes())
364: }
365: 
366: // ParseAddrToSocksAddr parse a socks addr from net.addr
367: // This is a fast path of ParseAddr(addr.String())
368: func ParseAddrToSocksAddr(addr net.Addr) Addr {
369: 	var hostip net.IP
370: 	var port int
371: 	if udpaddr, ok := addr.(*net.UDPAddr); ok {
372: 		hostip = udpaddr.IP
373: 		port = udpaddr.Port
374: 	} else if tcpaddr, ok := addr.(*net.TCPAddr); ok {
375: 		hostip = tcpaddr.IP
376: 		port = tcpaddr.Port
377: 	}
378: 
379: 	// fallback parse
380: 	if hostip == nil {
381: 		return ParseAddr(addr.String())
382: 	}
383: 
384: 	var parsed protobytes.BytesWriter
385: 	if ip4 := hostip.To4(); ip4.DefaultMask() != nil {
386: 		parsed = make([]byte, 0, 1+net.IPv4len+2)
387: 		parsed.PutUint8(AtypIPv4)
388: 		parsed.PutSlice(ip4)
389: 		parsed.PutUint16be(uint16(port))
390: 	} else {
391: 		parsed = make([]byte, 0, 1+net.IPv6len+2)
392: 		parsed.PutUint8(AtypIPv6)
393: 		parsed.PutSlice(hostip)
394: 		parsed.PutUint16be(uint16(port))
395: 	}
396: 	return Addr(parsed)
397: }
398: 
399: func AddrFromStdAddrPort(addrPort netip.AddrPort) Addr {
400: 	addr := addrPort.Addr()
401: 	if addr.Is4() {
402: 		ip4 := addr.As4()
403: 		return []byte{AtypIPv4, ip4[0], ip4[1], ip4[2], ip4[3], byte(addrPort.Port() >> 8), byte(addrPort.Port())}
404: 	}
405: 
406: 	buf := make([]byte, 1+net.IPv6len+2)
407: 	buf[0] = AtypIPv6
408: 	copy(buf[1:], addr.AsSlice())
409: 	buf[1+net.IPv6len] = byte(addrPort.Port() >> 8)
410: 	buf[1+net.IPv6len+1] = byte(addrPort.Port())
411: 	return buf
412: }
413: 
414: // DecodeUDPPacket split `packet` to addr payload, and this function is mutable with `packet`
415: func DecodeUDPPacket(packet []byte) (addr Addr, payload []byte, err error) {
416: 	r := protobytes.BytesReader(packet)
417: 
418: 	if r.Len() < 5 {
419: 		err = errors.New("insufficient length of packet")
420: 		return
421: 	}
422: 
423: 	// packet[0] and packet[1] are reserved
424: 	reserved, r := r.SplitAt(2)
425: 	if !bytes.Equal(reserved, []byte{0, 0}) {
426: 		err = errors.New("reserved fields should be zero")
427: 		return
428: 	}
429: 
430: 	if r.ReadUint8() != 0 /* fragments */ {
431: 		err = errors.New("discarding fragmented payload")
432: 		return
433: 	}
434: 
435: 	addr = SplitAddr(r)
436: 	if addr == nil {
437: 		err = errors.New("failed to read UDP header")
438: 	}
439: 
440: 	_, payload = r.SplitAt(len(addr))
441: 	return
442: }
443: 
444: func EncodeUDPPacket(addr Addr, payload []byte) (packet []byte, err error) {
445: 	if addr == nil {
446: 		err = errors.New("address is invalid")
447: 		return
448: 	}
449: 	w := protobytes.BytesWriter{}
450: 	w.PutSlice([]byte{0, 0, 0})
451: 	w.PutSlice(addr)
452: 	w.PutSlice(payload)
453: 	packet = w.Bytes()
454: 	return
455: }


./transport\ssr\obfs\base.go
1: package obfs
2: 
3: type Base struct {
4: 	Host   string
5: 	Port   int
6: 	Key    []byte
7: 	IVSize int
8: 	Param  string
9: }


./transport\ssr\obfs\http_post.go
1: package obfs
2: 
3: func init() {
4: 	register("http_post", newHTTPPost, 0)
5: }
6: 
7: func newHTTPPost(b *Base) Obfs {
8: 	return &httpObfs{Base: b, post: true}
9: }


./transport\ssr\obfs\http_simple.go
1: package obfs
2: 
3: import (
4: 	"bytes"
5: 	"encoding/hex"
6: 	"io"
7: 	"math/rand"
8: 	"net"
9: 	"strconv"
10: 	"strings"
11: 
12: 	"github.com/Dreamacro/clash/common/pool"
13: )
14: 
15: func init() {
16: 	register("http_simple", newHTTPSimple, 0)
17: }
18: 
19: type httpObfs struct {
20: 	*Base
21: 	post bool
22: }
23: 
24: func newHTTPSimple(b *Base) Obfs {
25: 	return &httpObfs{Base: b}
26: }
27: 
28: type httpConn struct {
29: 	net.Conn
30: 	*httpObfs
31: 	hasSentHeader bool
32: 	hasRecvHeader bool
33: 	buf           []byte
34: }
35: 
36: func (h *httpObfs) StreamConn(c net.Conn) net.Conn {
37: 	return &httpConn{Conn: c, httpObfs: h}
38: }
39: 
40: func (c *httpConn) Read(b []byte) (int, error) {
41: 	if c.buf != nil {
42: 		n := copy(b, c.buf)
43: 		if n == len(c.buf) {
44: 			c.buf = nil
45: 		} else {
46: 			c.buf = c.buf[n:]
47: 		}
48: 		return n, nil
49: 	}
50: 
51: 	if c.hasRecvHeader {
52: 		return c.Conn.Read(b)
53: 	}
54: 
55: 	buf := pool.Get(pool.RelayBufferSize)
56: 	defer pool.Put(buf)
57: 	n, err := c.Conn.Read(buf)
58: 	if err != nil {
59: 		return 0, err
60: 	}
61: 	pos := bytes.Index(buf[:n], []byte("\r\n\r\n"))
62: 	if pos == -1 {
63: 		return 0, io.EOF
64: 	}
65: 	c.hasRecvHeader = true
66: 	dataLength := n - pos - 4
67: 	n = copy(b, buf[4+pos:n])
68: 	if dataLength > n {
69: 		c.buf = append(c.buf, buf[4+pos+n:4+pos+dataLength]...)
70: 	}
71: 	return n, nil
72: }
73: 
74: func (c *httpConn) Write(b []byte) (int, error) {
75: 	if c.hasSentHeader {
76: 		return c.Conn.Write(b)
77: 	}
78: 	// 30: head length
79: 	headLength := c.IVSize + 30
80: 
81: 	bLength := len(b)
82: 	headDataLength := bLength
83: 	if bLength-headLength > 64 {
84: 		headDataLength = headLength + rand.Intn(65)
85: 	}
86: 	headData := b[:headDataLength]
87: 	b = b[headDataLength:]
88: 
89: 	var body string
90: 	host := c.Host
91: 	if len(c.Param) > 0 {
92: 		pos := strings.Index(c.Param, "#")
93: 		if pos != -1 {
94: 			body = strings.ReplaceAll(c.Param[pos+1:], "\n", "\r\n")
95: 			body = strings.ReplaceAll(body, "\\n", "\r\n")
96: 			host = c.Param[:pos]
97: 		} else {
98: 			host = c.Param
99: 		}
100: 	}
101: 	hosts := strings.Split(host, ",")
102: 	host = hosts[rand.Intn(len(hosts))]
103: 
104: 	buf := pool.GetBuffer()
105: 	defer pool.PutBuffer(buf)
106: 	if c.post {
107: 		buf.WriteString("POST /")
108: 	} else {
109: 		buf.WriteString("GET /")
110: 	}
111: 	packURLEncodedHeadData(buf, headData)
112: 	buf.WriteString(" HTTP/1.1\r\nHost: " + host)
113: 	if c.Port != 80 {
114: 		buf.WriteString(":" + strconv.Itoa(c.Port))
115: 	}
116: 	buf.WriteString("\r\n")
117: 	if len(body) > 0 {
118: 		buf.WriteString(body + "\r\n\r\n")
119: 	} else {
120: 		buf.WriteString("User-Agent: ")
121: 		buf.WriteString(userAgent[rand.Intn(len(userAgent))])
122: 		buf.WriteString("\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q=0.8\r\nAccept-Encoding: gzip, deflate\r\n")
123: 		if c.post {
124: 			packBoundary(buf)
125: 		}
126: 		buf.WriteString("DNT: 1\r\nConnection: keep-alive\r\n\r\n")
127: 	}
128: 	buf.Write(b)
129: 	_, err := c.Conn.Write(buf.Bytes())
130: 	if err != nil {
131: 		return 0, nil
132: 	}
133: 	c.hasSentHeader = true
134: 	return bLength, nil
135: }
136: 
137: func packURLEncodedHeadData(buf *bytes.Buffer, data []byte) {
138: 	dataLength := len(data)
139: 	for i := 0; i < dataLength; i++ {
140: 		buf.WriteRune('%')
141: 		buf.WriteString(hex.EncodeToString(data[i : i+1]))
142: 	}
143: }
144: 
145: func packBoundary(buf *bytes.Buffer) {
146: 	buf.WriteString("Content-Type: multipart/form-data; boundary=")
147: 	set := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
148: 	for i := 0; i < 32; i++ {
149: 		buf.WriteByte(set[rand.Intn(62)])
150: 	}
151: 	buf.WriteString("\r\n")
152: }
153: 
154: var userAgent = []string{
155: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36",
156: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36",
157: 	"Mozilla/5.0 (Linux; Android 7.0; Moto C Build/NRD90M.059) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
158: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
159: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
160: 	"Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/55.0.2883.91 Mobile Safari/537.36",
161: 	"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
162: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
163: 	"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
164: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36",
165: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
166: 	"Mozilla/5.0 (Linux; Android 5.1.1; SM-J120M Build/LMY47X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
167: 	"Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
168: 	"Mozilla/5.0 (Linux; Android 7.0; Moto G (5) Build/NPPS25.137-93-14) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
169: 	"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
170: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
171: 	"Mozilla/5.0 (Linux; Android 7.0; SM-G570M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
172: 	"Mozilla/5.0 (Windows NT 5.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
173: 	"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
174: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
175: 	"Mozilla/5.0 (Linux; Android 6.0; CAM-L03 Build/HUAWEICAM-L03) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
176: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36",
177: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
178: 	"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3",
179: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
180: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
181: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36",
182: 	"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7",
183: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
184: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36",
185: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36",
186: 	"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.63 Safari/534.3",
187: 	"Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
188: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36",
189: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
190: 	"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.237 Safari/534.10",
191: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
192: 	"Mozilla/5.0 (X11; U; Linux x86_64; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2",
193: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
194: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36",
195: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
196: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36",
197: 	"Mozilla/5.0 (X11; Datanyze; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
198: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
199: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36",
200: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36",
201: 	"Mozilla/5.0 (Linux; Android 5.1.1; SM-J111M Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
202: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
203: 	"Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
204: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
205: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36",
206: 	"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
207: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36",
208: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
209: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.107 Safari/537.36",
210: 	"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
211: 	"Mozilla/5.0 (Linux; Android 6.0.1; SM-J700M Build/MMB29K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
212: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.63 Safari/537.36",
213: 	"Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Slackware/Chrome/12.0.742.100 Safari/534.30",
214: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
215: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36",
216: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36",
217: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36",
218: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
219: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36",
220: 	"Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.100 Safari/534.30",
221: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
222: 	"Mozilla/5.0 (Linux; Android 8.0.0; WAS-LX3 Build/HUAWEIWAS-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
223: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
224: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
225: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36",
226: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36",
227: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36",
228: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
229: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36",
230: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.1805 Safari/537.36 MVisionPlayer/1.0.0.0",
231: 	"Mozilla/5.0 (Linux; Android 7.0; TRT-LX3 Build/HUAWEITRT-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
232: 	"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36",
233: 	"Mozilla/5.0 (Linux; Android 6.0; vivo 1610 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
234: 	"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
235: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
236: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36",
237: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
238: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36",
239: 	"Mozilla/5.0 (Linux; Android 4.4.2; de-de; SAMSUNG GT-I9195 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Version/1.5 Chrome/28.0.1500.94 Mobile Safari/537.36",
240: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
241: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36",
242: 	"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36",
243: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36",
244: 	"Mozilla/5.0 (Linux; Android 8.0.0; ANE-LX3 Build/HUAWEIANE-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
245: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
246: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
247: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36",
248: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36",
249: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
250: 	"Mozilla/5.0 (X11; U; Linux i586; en-US) AppleWebKit/533.2 (KHTML, like Gecko) Chrome/5.0.342.1 Safari/533.2",
251: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.65 Safari/537.36",
252: 	"Mozilla/5.0 (Linux; Android 7.0; SM-G610M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36",
253: 	"Mozilla/5.0 (Linux; Android 6.0.1; SM-J500M Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
254: 	"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7",
255: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.104 Safari/537.36",
256: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36",
257: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
258: 	"Mozilla/5.0 (Linux; Android 6.0; vivo 1606 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
259: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
260: 	"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36",
261: 	"Mozilla/5.0 (Linux; Android 7.0; SM-G610M Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
262: 	"Mozilla/5.0 (Linux; Android 7.1; vivo 1716 Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.98 Mobile Safari/537.36",
263: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
264: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
265: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36",
266: 	"Mozilla/5.0 (Linux; Android 7.0; SM-G570M Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
267: 	"Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
268: 	"Mozilla/5.0 (Linux; Android 6.0; MYA-L22 Build/HUAWEIMYA-L22) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
269: 	"Mozilla/5.0 (Linux; Android 5.1; A1601 Build/LMY47I) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.98 Mobile Safari/537.36",
270: 	"Mozilla/5.0 (Linux; Android 7.0; TRT-LX2 Build/HUAWEITRT-LX2; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/59.0.3071.125 Mobile Safari/537.36",
271: 	"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
272: 	"Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
273: 	"Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
274: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
275: 	"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17",
276: 	"Mozilla/5.0 (Linux; Android 6.0; CAM-L21 Build/HUAWEICAM-L21; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/62.0.3202.84 Mobile Safari/537.36",
277: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
278: 	"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.3 Safari/534.24",
279: 	"Mozilla/5.0 (Linux; Android 7.1.2; Redmi 4X Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
280: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
281: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
282: 	"Mozilla/5.0 (Linux; Android 4.4.2; SM-G7102 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
283: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36",
284: 	"Mozilla/5.0 (Linux; Android 5.1; HUAWEI CUN-L22 Build/HUAWEICUN-L22; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/62.0.3202.84 Mobile Safari/537.36",
285: 	"Mozilla/5.0 (Linux; Android 5.1.1; A37fw Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
286: 	"Mozilla/5.0 (Linux; Android 7.0; SM-J730GM Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
287: 	"Mozilla/5.0 (Linux; Android 7.0; SM-G610F Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
288: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
289: 	"Mozilla/5.0 (Linux; Android 7.1.2; Redmi Note 5A Build/N2G47H; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36",
290: 	"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
291: 	"Mozilla/5.0 (Linux; Android 7.0; Redmi Note 4 Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
292: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36",
293: 	"Mozilla/5.0 (Unknown; Linux) AppleWebKit/538.1 (KHTML, like Gecko) Chrome/v1.0.0 Safari/538.1",
294: 	"Mozilla/5.0 (Linux; Android 7.0; BLL-L22 Build/HUAWEIBLL-L22) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.91 Mobile Safari/537.36",
295: 	"Mozilla/5.0 (Linux; Android 7.0; SM-J710F Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
296: 	"Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.91 Mobile Safari/537.36",
297: 	"Mozilla/5.0 (Linux; Android 7.1.1; CPH1723 Build/N6F26Q) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.98 Mobile Safari/537.36",
298: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36",
299: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36",
300: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36",
301: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36",
302: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36",
303: 	"Mozilla/5.0 (Linux; Android 8.0.0; FIG-LX3 Build/HUAWEIFIG-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
304: 	"Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.17 (KHTML, like Gecko) Chrome/10.0.649.0 Safari/534.17",
305: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
306: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.63 Safari/537.36",
307: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36",
308: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
309: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",
310: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
311: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
312: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
313: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
314: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36",
315: 	"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
316: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
317: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
318: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.65 Safari/537.36",
319: 	"Mozilla/5.0 (Linux; Android 7.1; Mi A1 Build/N2G47H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.83 Mobile Safari/537.36",
320: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
321: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
322: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
323: 	"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4",
324: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36",
325: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
326: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36 MVisionPlayer/1.0.0.0",
327: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36",
328: 	"Mozilla/5.0 (Linux; Android 5.1; A37f Build/LMY47V) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.93 Mobile Safari/537.36",
329: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
330: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36",
331: 	"Mozilla/5.0 (Windows NT 6.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
332: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
333: 	"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
334: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
335: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36",
336: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
337: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36",
338: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
339: 	"Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
340: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
341: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
342: 	"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
343: 	"Mozilla/5.0 (Linux; Android 6.0.1; CPH1607 Build/MMB29M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/63.0.3239.111 Mobile Safari/537.36",
344: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36",
345: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36",
346: 	"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
347: 	"Mozilla/5.0 (Linux; Android 6.0.1; vivo 1603 Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.83 Mobile Safari/537.36",
348: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36",
349: 	"Mozilla/5.0 (Linux; Android 6.0.1; SM-G532M Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36",
350: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36",
351: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36",
352: 	"Mozilla/5.0 (Linux; Android 6.0.1; Redmi 4A Build/MMB29M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.116 Mobile Safari/537.36",
353: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36",
354: 	"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
355: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
356: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
357: 	"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36",
358: 	"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36",
359: 	"Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
360: 	"Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
361: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
362: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36",
363: 	"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.90 Safari/537.36",
364: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36",
365: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
366: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36",
367: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
368: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
369: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
370: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36",
371: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36",
372: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
373: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31",
374: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36",
375: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
376: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
377: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36",
378: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36",
379: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
380: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
381: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36",
382: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
383: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36",
384: 	"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36",
385: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
386: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36",
387: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
388: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36",
389: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36",
390: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36",
391: 	"Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36",
392: 	"Mozilla/5.0 (Linux; Android 6.0.1; SM-G532G Build/MMB29T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.83 Mobile Safari/537.36",
393: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36",
394: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36",
395: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36",
396: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36",
397: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
398: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.131 Safari/537.36",
399: 	"Mozilla/5.0 (Linux; Android 6.0; vivo 1713 Build/MRA58K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.124 Mobile Safari/537.36",
400: 	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36",
401: 	"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36",
402: 	"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36",
403: 	"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36",
404: 	"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36",
405: }


./transport\ssr\obfs\obfs.go
1: package obfs
2: 
3: import (
4: 	"errors"
5: 	"fmt"
6: 	"net"
7: )
8: 
9: var (
10: 	errTLS12TicketAuthIncorrectMagicNumber = errors.New("tls1.2_ticket_auth incorrect magic number")
11: 	errTLS12TicketAuthTooShortData         = errors.New("tls1.2_ticket_auth too short data")
12: 	errTLS12TicketAuthHMACError            = errors.New("tls1.2_ticket_auth hmac verifying failed")
13: )
14: 
15: type authData struct {
16: 	clientID [32]byte
17: }
18: 
19: type Obfs interface {
20: 	StreamConn(net.Conn) net.Conn
21: }
22: 
23: type obfsCreator func(b *Base) Obfs
24: 
25: var obfsList = make(map[string]struct {
26: 	overhead int
27: 	new      obfsCreator
28: })
29: 
30: func register(name string, c obfsCreator, o int) {
31: 	obfsList[name] = struct {
32: 		overhead int
33: 		new      obfsCreator
34: 	}{overhead: o, new: c}
35: }
36: 
37: func PickObfs(name string, b *Base) (Obfs, int, error) {
38: 	if choice, ok := obfsList[name]; ok {
39: 		return choice.new(b), choice.overhead, nil
40: 	}
41: 	return nil, 0, fmt.Errorf("Obfs %s not supported", name)
42: }


./transport\ssr\obfs\plain.go
1: package obfs
2: 
3: import "net"
4: 
5: type plain struct{}
6: 
7: func init() {
8: 	register("plain", newPlain, 0)
9: }
10: 
11: func newPlain(b *Base) Obfs {
12: 	return &plain{}
13: }
14: 
15: func (p *plain) StreamConn(c net.Conn) net.Conn { return c }


./transport\ssr\obfs\random_head.go
1: package obfs
2: 
3: import (
4: 	"crypto/rand"
5: 	"encoding/binary"
6: 	"hash/crc32"
7: 	mathRand "math/rand"
8: 	"net"
9: 
10: 	"github.com/Dreamacro/clash/common/pool"
11: )
12: 
13: func init() {
14: 	register("random_head", newRandomHead, 0)
15: }
16: 
17: type randomHead struct {
18: 	*Base
19: }
20: 
21: func newRandomHead(b *Base) Obfs {
22: 	return &randomHead{Base: b}
23: }
24: 
25: type randomHeadConn struct {
26: 	net.Conn
27: 	*randomHead
28: 	hasSentHeader bool
29: 	rawTransSent  bool
30: 	rawTransRecv  bool
31: 	buf           []byte
32: }
33: 
34: func (r *randomHead) StreamConn(c net.Conn) net.Conn {
35: 	return &randomHeadConn{Conn: c, randomHead: r}
36: }
37: 
38: func (c *randomHeadConn) Read(b []byte) (int, error) {
39: 	if c.rawTransRecv {
40: 		return c.Conn.Read(b)
41: 	}
42: 	buf := pool.Get(pool.RelayBufferSize)
43: 	defer pool.Put(buf)
44: 	c.Conn.Read(buf)
45: 	c.rawTransRecv = true
46: 	c.Write(nil)
47: 	return 0, nil
48: }
49: 
50: func (c *randomHeadConn) Write(b []byte) (int, error) {
51: 	if c.rawTransSent {
52: 		return c.Conn.Write(b)
53: 	}
54: 	c.buf = append(c.buf, b...)
55: 	if !c.hasSentHeader {
56: 		c.hasSentHeader = true
57: 		dataLength := mathRand.Intn(96) + 4
58: 		buf := pool.Get(dataLength + 4)
59: 		defer pool.Put(buf)
60: 		rand.Read(buf[:dataLength])
61: 		binary.LittleEndian.PutUint32(buf[dataLength:], 0xffffffff-crc32.ChecksumIEEE(buf[:dataLength]))
62: 		_, err := c.Conn.Write(buf)
63: 		return len(b), err
64: 	}
65: 	if c.rawTransRecv {
66: 		_, err := c.Conn.Write(c.buf)
67: 		c.buf = nil
68: 		c.rawTransSent = true
69: 		return len(b), err
70: 	}
71: 	return len(b), nil
72: }


./transport\ssr\obfs\tls1.2_ticket_auth.go
1: package obfs
2: 
3: import (
4: 	"bytes"
5: 	"crypto/hmac"
6: 	"crypto/rand"
7: 	"encoding/binary"
8: 	mathRand "math/rand"
9: 	"net"
10: 	"strings"
11: 	"time"
12: 
13: 	"github.com/Dreamacro/clash/common/pool"
14: 	"github.com/Dreamacro/clash/transport/ssr/tools"
15: )
16: 
17: func init() {
18: 	register("tls1.2_ticket_auth", newTLS12Ticket, 5)
19: 	register("tls1.2_ticket_fastauth", newTLS12Ticket, 5)
20: }
21: 
22: type tls12Ticket struct {
23: 	*Base
24: 	*authData
25: }
26: 
27: func newTLS12Ticket(b *Base) Obfs {
28: 	r := &tls12Ticket{Base: b, authData: &authData{}}
29: 	rand.Read(r.clientID[:])
30: 	return r
31: }
32: 
33: type tls12TicketConn struct {
34: 	net.Conn
35: 	*tls12Ticket
36: 	handshakeStatus int
37: 	decoded         bytes.Buffer
38: 	underDecoded    bytes.Buffer
39: 	sendBuf         bytes.Buffer
40: }
41: 
42: func (t *tls12Ticket) StreamConn(c net.Conn) net.Conn {
43: 	return &tls12TicketConn{Conn: c, tls12Ticket: t}
44: }
45: 
46: func (c *tls12TicketConn) Read(b []byte) (int, error) {
47: 	if c.decoded.Len() > 0 {
48: 		return c.decoded.Read(b)
49: 	}
50: 
51: 	buf := pool.Get(pool.RelayBufferSize)
52: 	defer pool.Put(buf)
53: 	n, err := c.Conn.Read(buf)
54: 	if err != nil {
55: 		return 0, err
56: 	}
57: 
58: 	if c.handshakeStatus == 8 {
59: 		c.underDecoded.Write(buf[:n])
60: 		for c.underDecoded.Len() > 5 {
61: 			if !bytes.Equal(c.underDecoded.Bytes()[:3], []byte{0x17, 3, 3}) {
62: 				c.underDecoded.Reset()
63: 				return 0, errTLS12TicketAuthIncorrectMagicNumber
64: 			}
65: 			size := int(binary.BigEndian.Uint16(c.underDecoded.Bytes()[3:5]))
66: 			if c.underDecoded.Len() < 5+size {
67: 				break
68: 			}
69: 			c.underDecoded.Next(5)
70: 			c.decoded.Write(c.underDecoded.Next(size))
71: 		}
72: 		n, _ = c.decoded.Read(b)
73: 		return n, nil
74: 	}
75: 
76: 	if n < 11+32+1+32 {
77: 		return 0, errTLS12TicketAuthTooShortData
78: 	}
79: 
80: 	if !hmac.Equal(buf[33:43], c.hmacSHA1(buf[11:33])[:10]) || !hmac.Equal(buf[n-10:n], c.hmacSHA1(buf[:n-10])[:10]) {
81: 		return 0, errTLS12TicketAuthHMACError
82: 	}
83: 
84: 	c.Write(nil)
85: 	return 0, nil
86: }
87: 
88: func (c *tls12TicketConn) Write(b []byte) (int, error) {
89: 	length := len(b)
90: 	if c.handshakeStatus == 8 {
91: 		buf := pool.GetBuffer()
92: 		defer pool.PutBuffer(buf)
93: 		for len(b) > 2048 {
94: 			size := mathRand.Intn(4096) + 100
95: 			if len(b) < size {
96: 				size = len(b)
97: 			}
98: 			packData(buf, b[:size])
99: 			b = b[size:]
100: 		}
101: 		if len(b) > 0 {
102: 			packData(buf, b)
103: 		}
104: 		_, err := c.Conn.Write(buf.Bytes())
105: 		if err != nil {
106: 			return 0, err
107: 		}
108: 		return length, nil
109: 	}
110: 
111: 	if len(b) > 0 {
112: 		packData(&c.sendBuf, b)
113: 	}
114: 
115: 	if c.handshakeStatus == 0 {
116: 		c.handshakeStatus = 1
117: 
118: 		data := pool.GetBuffer()
119: 		defer pool.PutBuffer(data)
120: 
121: 		data.Write([]byte{3, 3})
122: 		c.packAuthData(data)
123: 		data.WriteByte(0x20)
124: 		data.Write(c.clientID[:])
125: 		data.Write([]byte{0x00, 0x1c, 0xc0, 0x2b, 0xc0, 0x2f, 0xcc, 0xa9, 0xcc, 0xa8, 0xcc, 0x14, 0xcc, 0x13, 0xc0, 0x0a, 0xc0, 0x14, 0xc0, 0x09, 0xc0, 0x13, 0x00, 0x9c, 0x00, 0x35, 0x00, 0x2f, 0x00, 0x0a})
126: 		data.Write([]byte{0x1, 0x0})
127: 
128: 		ext := pool.GetBuffer()
129: 		defer pool.PutBuffer(ext)
130: 
131: 		host := c.getHost()
132: 		ext.Write([]byte{0xff, 0x01, 0x00, 0x01, 0x00})
133: 		packSNIData(ext, host)
134: 		ext.Write([]byte{0, 0x17, 0, 0})
135: 		c.packTicketBuf(ext, host)
136: 		ext.Write([]byte{0x00, 0x0d, 0x00, 0x16, 0x00, 0x14, 0x06, 0x01, 0x06, 0x03, 0x05, 0x01, 0x05, 0x03, 0x04, 0x01, 0x04, 0x03, 0x03, 0x01, 0x03, 0x03, 0x02, 0x01, 0x02, 0x03})
137: 		ext.Write([]byte{0x00, 0x05, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00})
138: 		ext.Write([]byte{0x00, 0x12, 0x00, 0x00})
139: 		ext.Write([]byte{0x75, 0x50, 0x00, 0x00})
140: 		ext.Write([]byte{0x00, 0x0b, 0x00, 0x02, 0x01, 0x00})
141: 		ext.Write([]byte{0x00, 0x0a, 0x00, 0x06, 0x00, 0x04, 0x00, 0x17, 0x00, 0x18})
142: 
143: 		binary.Write(data, binary.BigEndian, uint16(ext.Len()))
144: 		data.ReadFrom(ext)
145: 
146: 		ret := pool.GetBuffer()
147: 		defer pool.PutBuffer(ret)
148: 
149: 		ret.Write([]byte{0x16, 3, 1})
150: 		binary.Write(ret, binary.BigEndian, uint16(data.Len()+4))
151: 		ret.Write([]byte{1, 0})
152: 		binary.Write(ret, binary.BigEndian, uint16(data.Len()))
153: 		ret.ReadFrom(data)
154: 
155: 		_, err := c.Conn.Write(ret.Bytes())
156: 		if err != nil {
157: 			return 0, err
158: 		}
159: 		return length, nil
160: 	} else if c.handshakeStatus == 1 && len(b) == 0 {
161: 		buf := pool.GetBuffer()
162: 		defer pool.PutBuffer(buf)
163: 
164: 		buf.Write([]byte{0x14, 3, 3, 0, 1, 1, 0x16, 3, 3, 0, 0x20})
165: 		tools.AppendRandBytes(buf, 22)
166: 		buf.Write(c.hmacSHA1(buf.Bytes())[:10])
167: 		buf.ReadFrom(&c.sendBuf)
168: 
169: 		c.handshakeStatus = 8
170: 
171: 		_, err := c.Conn.Write(buf.Bytes())
172: 		return 0, err
173: 	}
174: 	return length, nil
175: }
176: 
177: func packData(buf *bytes.Buffer, data []byte) {
178: 	buf.Write([]byte{0x17, 3, 3})
179: 	binary.Write(buf, binary.BigEndian, uint16(len(data)))
180: 	buf.Write(data)
181: }
182: 
183: func (t *tls12Ticket) packAuthData(buf *bytes.Buffer) {
184: 	binary.Write(buf, binary.BigEndian, uint32(time.Now().Unix()))
185: 	tools.AppendRandBytes(buf, 18)
186: 	buf.Write(t.hmacSHA1(buf.Bytes()[buf.Len()-22:])[:10])
187: }
188: 
189: func packSNIData(buf *bytes.Buffer, u string) {
190: 	len := uint16(len(u))
191: 	buf.Write([]byte{0, 0})
192: 	binary.Write(buf, binary.BigEndian, len+5)
193: 	binary.Write(buf, binary.BigEndian, len+3)
194: 	buf.WriteByte(0)
195: 	binary.Write(buf, binary.BigEndian, len)
196: 	buf.WriteString(u)
197: }
198: 
199: func (c *tls12TicketConn) packTicketBuf(buf *bytes.Buffer, u string) {
200: 	length := 16 * (mathRand.Intn(17) + 8)
201: 	buf.Write([]byte{0, 0x23})
202: 	binary.Write(buf, binary.BigEndian, uint16(length))
203: 	tools.AppendRandBytes(buf, length)
204: }
205: 
206: func (t *tls12Ticket) hmacSHA1(data []byte) []byte {
207: 	key := pool.Get(len(t.Key) + 32)
208: 	defer pool.Put(key)
209: 	copy(key, t.Key)
210: 	copy(key[len(t.Key):], t.clientID[:])
211: 
212: 	sha1Data := tools.HmacSHA1(key, data)
213: 	return sha1Data[:10]
214: }
215: 
216: func (t *tls12Ticket) getHost() string {
217: 	host := t.Param
218: 	if len(host) == 0 {
219: 		host = t.Host
220: 	}
221: 	if len(host) > 0 && host[len(host)-1] >= '0' && host[len(host)-1] <= '9' {
222: 		host = ""
223: 	}
224: 	hosts := strings.Split(host, ",")
225: 	host = hosts[mathRand.Intn(len(hosts))]
226: 	return host
227: }


./transport\ssr\protocol\auth_aes128_md5.go
1: package protocol
2: 
3: import "github.com/Dreamacro/clash/transport/ssr/tools"
4: 
5: func init() {
6: 	register("auth_aes128_md5", newAuthAES128MD5, 9)
7: }
8: 
9: func newAuthAES128MD5(b *Base) Protocol {
10: 	a := &authAES128{
11: 		Base:               b,
12: 		authData:           &authData{},
13: 		authAES128Function: &authAES128Function{salt: "auth_aes128_md5", hmac: tools.HmacMD5, hashDigest: tools.MD5Sum},
14: 		userData:           &userData{},
15: 	}
16: 	a.initUserData()
17: 	return a
18: }


./transport\ssr\protocol\auth_aes128_sha1.go
1: package protocol
2: 
3: import (
4: 	"bytes"
5: 	"crypto/rand"
6: 	"encoding/binary"
7: 	"math"
8: 	mathRand "math/rand"
9: 	"net"
10: 	"strconv"
11: 	"strings"
12: 
13: 	"github.com/Dreamacro/clash/common/pool"
14: 	"github.com/Dreamacro/clash/log"
15: 	"github.com/Dreamacro/clash/transport/ssr/tools"
16: )
17: 
18: type (
19: 	hmacMethod       func(key, data []byte) []byte
20: 	hashDigestMethod func([]byte) []byte
21: )
22: 
23: func init() {
24: 	register("auth_aes128_sha1", newAuthAES128SHA1, 9)
25: }
26: 
27: type authAES128Function struct {
28: 	salt       string
29: 	hmac       hmacMethod
30: 	hashDigest hashDigestMethod
31: }
32: 
33: type authAES128 struct {
34: 	*Base
35: 	*authData
36: 	*authAES128Function
37: 	*userData
38: 	iv            []byte
39: 	hasSentHeader bool
40: 	rawTrans      bool
41: 	packID        uint32
42: 	recvID        uint32
43: }
44: 
45: func newAuthAES128SHA1(b *Base) Protocol {
46: 	a := &authAES128{
47: 		Base:               b,
48: 		authData:           &authData{},
49: 		authAES128Function: &authAES128Function{salt: "auth_aes128_sha1", hmac: tools.HmacSHA1, hashDigest: tools.SHA1Sum},
50: 		userData:           &userData{},
51: 	}
52: 	a.initUserData()
53: 	return a
54: }
55: 
56: func (a *authAES128) initUserData() {
57: 	params := strings.Split(a.Param, ":")
58: 	if len(params) > 1 {
59: 		if userID, err := strconv.ParseUint(params[0], 10, 32); err == nil {
60: 			binary.LittleEndian.PutUint32(a.userID[:], uint32(userID))
61: 			a.userKey = a.hashDigest([]byte(params[1]))
62: 		} else {
63: 			log.Warnln("Wrong protocol-param for %s, only digits are expected before ':'", a.salt)
64: 		}
65: 	}
66: 	if len(a.userKey) == 0 {
67: 		a.userKey = a.Key
68: 		rand.Read(a.userID[:])
69: 	}
70: }
71: 
72: func (a *authAES128) StreamConn(c net.Conn, iv []byte) net.Conn {
73: 	p := &authAES128{
74: 		Base:               a.Base,
75: 		authData:           a.next(),
76: 		authAES128Function: a.authAES128Function,
77: 		userData:           a.userData,
78: 		packID:             1,
79: 		recvID:             1,
80: 	}
81: 	p.iv = iv
82: 	return &Conn{Conn: c, Protocol: p}
83: }
84: 
85: func (a *authAES128) PacketConn(c net.PacketConn) net.PacketConn {
86: 	p := &authAES128{
87: 		Base:               a.Base,
88: 		authAES128Function: a.authAES128Function,
89: 		userData:           a.userData,
90: 	}
91: 	return &PacketConn{PacketConn: c, Protocol: p}
92: }
93: 
94: func (a *authAES128) Decode(dst, src *bytes.Buffer) error {
95: 	if a.rawTrans {
96: 		dst.ReadFrom(src)
97: 		return nil
98: 	}
99: 	for src.Len() > 4 {
100: 		macKey := pool.Get(len(a.userKey) + 4)
101: 		defer pool.Put(macKey)
102: 		copy(macKey, a.userKey)
103: 		binary.LittleEndian.PutUint32(macKey[len(a.userKey):], a.recvID)
104: 		if !bytes.Equal(a.hmac(macKey, src.Bytes()[:2])[:2], src.Bytes()[2:4]) {
105: 			src.Reset()
106: 			return errAuthAES128MACError
107: 		}
108: 
109: 		length := int(binary.LittleEndian.Uint16(src.Bytes()[:2]))
110: 		if length >= 8192 || length < 7 {
111: 			a.rawTrans = true
112: 			src.Reset()
113: 			return errAuthAES128LengthError
114: 		}
115: 		if length > src.Len() {
116: 			break
117: 		}
118: 
119: 		if !bytes.Equal(a.hmac(macKey, src.Bytes()[:length-4])[:4], src.Bytes()[length-4:length]) {
120: 			a.rawTrans = true
121: 			src.Reset()
122: 			return errAuthAES128ChksumError
123: 		}
124: 
125: 		a.recvID++
126: 
127: 		pos := int(src.Bytes()[4])
128: 		if pos < 255 {
129: 			pos += 4
130: 		} else {
131: 			pos = int(binary.LittleEndian.Uint16(src.Bytes()[5:7])) + 4
132: 		}
133: 		dst.Write(src.Bytes()[pos : length-4])
134: 		src.Next(length)
135: 	}
136: 	return nil
137: }
138: 
139: func (a *authAES128) Encode(buf *bytes.Buffer, b []byte) error {
140: 	fullDataLength := len(b)
141: 	if !a.hasSentHeader {
142: 		dataLength := getDataLength(b)
143: 		a.packAuthData(buf, b[:dataLength])
144: 		b = b[dataLength:]
145: 		a.hasSentHeader = true
146: 	}
147: 	for len(b) > 8100 {
148: 		a.packData(buf, b[:8100], fullDataLength)
149: 		b = b[8100:]
150: 	}
151: 	if len(b) > 0 {
152: 		a.packData(buf, b, fullDataLength)
153: 	}
154: 	return nil
155: }
156: 
157: func (a *authAES128) DecodePacket(b []byte) ([]byte, error) {
158: 	if len(b) < 4 {
159: 		return nil, errAuthAES128LengthError
160: 	}
161: 	if !bytes.Equal(a.hmac(a.Key, b[:len(b)-4])[:4], b[len(b)-4:]) {
162: 		return nil, errAuthAES128ChksumError
163: 	}
164: 	return b[:len(b)-4], nil
165: }
166: 
167: func (a *authAES128) EncodePacket(buf *bytes.Buffer, b []byte) error {
168: 	buf.Write(b)
169: 	buf.Write(a.userID[:])
170: 	buf.Write(a.hmac(a.userKey, buf.Bytes())[:4])
171: 	return nil
172: }
173: 
174: func (a *authAES128) packData(poolBuf *bytes.Buffer, data []byte, fullDataLength int) {
175: 	dataLength := len(data)
176: 	randDataLength := a.getRandDataLengthForPackData(dataLength, fullDataLength)
177: 	/*
178: 		2:	uint16 LittleEndian packedDataLength
179: 		2:	hmac of packedDataLength
180: 		3:	maxRandDataLengthPrefix (min:1)
181: 		4:	hmac of packedData except the last 4 bytes
182: 	*/
183: 	packedDataLength := 2 + 2 + 3 + randDataLength + dataLength + 4
184: 	if randDataLength < 128 {
185: 		packedDataLength -= 2
186: 	}
187: 
188: 	macKey := pool.Get(len(a.userKey) + 4)
189: 	defer pool.Put(macKey)
190: 	copy(macKey, a.userKey)
191: 	binary.LittleEndian.PutUint32(macKey[len(a.userKey):], a.packID)
192: 	a.packID++
193: 
194: 	binary.Write(poolBuf, binary.LittleEndian, uint16(packedDataLength))
195: 	poolBuf.Write(a.hmac(macKey, poolBuf.Bytes()[poolBuf.Len()-2:])[:2])
196: 	a.packRandData(poolBuf, randDataLength)
197: 	poolBuf.Write(data)
198: 	poolBuf.Write(a.hmac(macKey, poolBuf.Bytes()[poolBuf.Len()-packedDataLength+4:])[:4])
199: }
200: 
201: func trapezoidRandom(max int, d float64) int {
202: 	base := mathRand.Float64()
203: 	if d-0 > 1e-6 {
204: 		a := 1 - d
205: 		base = (math.Sqrt(a*a+4*d*base) - a) / (2 * d)
206: 	}
207: 	return int(base * float64(max))
208: }
209: 
210: func (a *authAES128) getRandDataLengthForPackData(dataLength, fullDataLength int) int {
211: 	if fullDataLength >= 32*1024-a.Overhead {
212: 		return 0
213: 	}
214: 	// 1460: tcp_mss
215: 	revLength := 1460 - dataLength - 9
216: 	if revLength == 0 {
217: 		return 0
218: 	}
219: 	if revLength < 0 {
220: 		if revLength > -1460 {
221: 			return trapezoidRandom(revLength+1460, -0.3)
222: 		}
223: 		return mathRand.Intn(32)
224: 	}
225: 	if dataLength > 900 {
226: 		return mathRand.Intn(revLength)
227: 	}
228: 	return trapezoidRandom(revLength, -0.3)
229: }
230: 
231: func (a *authAES128) packAuthData(poolBuf *bytes.Buffer, data []byte) {
232: 	if len(data) == 0 {
233: 		return
234: 	}
235: 	dataLength := len(data)
236: 	randDataLength := a.getRandDataLengthForPackAuthData(dataLength)
237: 	/*
238: 		7:	checkHead(1) and hmac of checkHead(6)
239: 		4:	userID
240: 		16:	encrypted data of authdata(12), uint16 BigEndian packedDataLength(2) and uint16 BigEndian randDataLength(2)
241: 		4:	hmac of userID and encrypted data
242: 		4:	hmac of packedAuthData except the last 4 bytes
243: 	*/
244: 	packedAuthDataLength := 7 + 4 + 16 + 4 + randDataLength + dataLength + 4
245: 
246: 	macKey := pool.Get(len(a.iv) + len(a.Key))
247: 	defer pool.Put(macKey)
248: 	copy(macKey, a.iv)
249: 	copy(macKey[len(a.iv):], a.Key)
250: 
251: 	poolBuf.WriteByte(byte(mathRand.Intn(256)))
252: 	poolBuf.Write(a.hmac(macKey, poolBuf.Bytes())[:6])
253: 	poolBuf.Write(a.userID[:])
254: 	err := a.authData.putEncryptedData(poolBuf, a.userKey, [2]int{packedAuthDataLength, randDataLength}, a.salt)
255: 	if err != nil {
256: 		poolBuf.Reset()
257: 		return
258: 	}
259: 	poolBuf.Write(a.hmac(macKey, poolBuf.Bytes()[7:])[:4])
260: 	tools.AppendRandBytes(poolBuf, randDataLength)
261: 	poolBuf.Write(data)
262: 	poolBuf.Write(a.hmac(a.userKey, poolBuf.Bytes())[:4])
263: }
264: 
265: func (a *authAES128) getRandDataLengthForPackAuthData(size int) int {
266: 	if size > 400 {
267: 		return mathRand.Intn(512)
268: 	}
269: 	return mathRand.Intn(1024)
270: }
271: 
272: func (a *authAES128) packRandData(poolBuf *bytes.Buffer, size int) {
273: 	if size < 128 {
274: 		poolBuf.WriteByte(byte(size + 1))
275: 		tools.AppendRandBytes(poolBuf, size)
276: 		return
277: 	}
278: 	poolBuf.WriteByte(255)
279: 	binary.Write(poolBuf, binary.LittleEndian, uint16(size+3))
280: 	tools.AppendRandBytes(poolBuf, size)
281: }


./transport\ssr\protocol\auth_chain_a.go
1: package protocol
2: 
3: import (
4: 	"bytes"
5: 	"crypto/cipher"
6: 	"crypto/rand"
7: 	"crypto/rc4"
8: 	"encoding/base64"
9: 	"encoding/binary"
10: 	"net"
11: 	"strconv"
12: 	"strings"
13: 
14: 	"github.com/Dreamacro/clash/common/pool"
15: 	"github.com/Dreamacro/clash/log"
16: 	"github.com/Dreamacro/clash/transport/shadowsocks/core"
17: 	"github.com/Dreamacro/clash/transport/ssr/tools"
18: )
19: 
20: func init() {
21: 	register("auth_chain_a", newAuthChainA, 4)
22: }
23: 
24: type randDataLengthMethod func(int, []byte, *tools.XorShift128Plus) int
25: 
26: type authChainA struct {
27: 	*Base
28: 	*authData
29: 	*userData
30: 	iv             []byte
31: 	salt           string
32: 	hasSentHeader  bool
33: 	rawTrans       bool
34: 	lastClientHash []byte
35: 	lastServerHash []byte
36: 	encrypter      cipher.Stream
37: 	decrypter      cipher.Stream
38: 	randomClient   tools.XorShift128Plus
39: 	randomServer   tools.XorShift128Plus
40: 	randDataLength randDataLengthMethod
41: 	packID         uint32
42: 	recvID         uint32
43: }
44: 
45: func newAuthChainA(b *Base) Protocol {
46: 	a := &authChainA{
47: 		Base:     b,
48: 		authData: &authData{},
49: 		userData: &userData{},
50: 		salt:     "auth_chain_a",
51: 	}
52: 	a.initUserData()
53: 	return a
54: }
55: 
56: func (a *authChainA) initUserData() {
57: 	params := strings.Split(a.Param, ":")
58: 	if len(params) > 1 {
59: 		if userID, err := strconv.ParseUint(params[0], 10, 32); err == nil {
60: 			binary.LittleEndian.PutUint32(a.userID[:], uint32(userID))
61: 			a.userKey = []byte(params[1])
62: 		} else {
63: 			log.Warnln("Wrong protocol-param for %s, only digits are expected before ':'", a.salt)
64: 		}
65: 	}
66: 	if len(a.userKey) == 0 {
67: 		a.userKey = a.Key
68: 		rand.Read(a.userID[:])
69: 	}
70: }
71: 
72: func (a *authChainA) StreamConn(c net.Conn, iv []byte) net.Conn {
73: 	p := &authChainA{
74: 		Base:     a.Base,
75: 		authData: a.next(),
76: 		userData: a.userData,
77: 		salt:     a.salt,
78: 		packID:   1,
79: 		recvID:   1,
80: 	}
81: 	p.iv = iv
82: 	p.randDataLength = p.getRandLength
83: 	return &Conn{Conn: c, Protocol: p}
84: }
85: 
86: func (a *authChainA) PacketConn(c net.PacketConn) net.PacketConn {
87: 	p := &authChainA{
88: 		Base:     a.Base,
89: 		salt:     a.salt,
90: 		userData: a.userData,
91: 	}
92: 	return &PacketConn{PacketConn: c, Protocol: p}
93: }
94: 
95: func (a *authChainA) Decode(dst, src *bytes.Buffer) error {
96: 	if a.rawTrans {
97: 		dst.ReadFrom(src)
98: 		return nil
99: 	}
100: 	for src.Len() > 4 {
101: 		macKey := pool.Get(len(a.userKey) + 4)
102: 		defer pool.Put(macKey)
103: 		copy(macKey, a.userKey)
104: 		binary.LittleEndian.PutUint32(macKey[len(a.userKey):], a.recvID)
105: 
106: 		dataLength := int(binary.LittleEndian.Uint16(src.Bytes()[:2]) ^ binary.LittleEndian.Uint16(a.lastServerHash[14:16]))
107: 		randDataLength := a.randDataLength(dataLength, a.lastServerHash, &a.randomServer)
108: 		length := dataLength + randDataLength
109: 
110: 		if length >= 4096 {
111: 			a.rawTrans = true
112: 			src.Reset()
113: 			return errAuthChainLengthError
114: 		}
115: 
116: 		if 4+length > src.Len() {
117: 			break
118: 		}
119: 
120: 		serverHash := tools.HmacMD5(macKey, src.Bytes()[:length+2])
121: 		if !bytes.Equal(serverHash[:2], src.Bytes()[length+2:length+4]) {
122: 			a.rawTrans = true
123: 			src.Reset()
124: 			return errAuthChainChksumError
125: 		}
126: 		a.lastServerHash = serverHash
127: 
128: 		pos := 2
129: 		if dataLength > 0 && randDataLength > 0 {
130: 			pos += getRandStartPos(randDataLength, &a.randomServer)
131: 		}
132: 		wantedData := src.Bytes()[pos : pos+dataLength]
133: 		a.decrypter.XORKeyStream(wantedData, wantedData)
134: 		if a.recvID == 1 {
135: 			dst.Write(wantedData[2:])
136: 		} else {
137: 			dst.Write(wantedData)
138: 		}
139: 		a.recvID++
140: 		src.Next(length + 4)
141: 	}
142: 	return nil
143: }
144: 
145: func (a *authChainA) Encode(buf *bytes.Buffer, b []byte) error {
146: 	if !a.hasSentHeader {
147: 		dataLength := getDataLength(b)
148: 		a.packAuthData(buf, b[:dataLength])
149: 		b = b[dataLength:]
150: 		a.hasSentHeader = true
151: 	}
152: 	for len(b) > 2800 {
153: 		a.packData(buf, b[:2800])
154: 		b = b[2800:]
155: 	}
156: 	if len(b) > 0 {
157: 		a.packData(buf, b)
158: 	}
159: 	return nil
160: }
161: 
162: func (a *authChainA) DecodePacket(b []byte) ([]byte, error) {
163: 	if len(b) < 9 {
164: 		return nil, errAuthChainLengthError
165: 	}
166: 	if !bytes.Equal(tools.HmacMD5(a.userKey, b[:len(b)-1])[:1], b[len(b)-1:]) {
167: 		return nil, errAuthChainChksumError
168: 	}
169: 	md5Data := tools.HmacMD5(a.Key, b[len(b)-8:len(b)-1])
170: 
171: 	randDataLength := udpGetRandLength(md5Data, &a.randomServer)
172: 
173: 	key := core.Kdf(base64.StdEncoding.EncodeToString(a.userKey)+base64.StdEncoding.EncodeToString(md5Data), 16)
174: 	rc4Cipher, err := rc4.NewCipher(key)
175: 	if err != nil {
176: 		return nil, err
177: 	}
178: 	wantedData := b[:len(b)-8-randDataLength]
179: 	rc4Cipher.XORKeyStream(wantedData, wantedData)
180: 	return wantedData, nil
181: }
182: 
183: func (a *authChainA) EncodePacket(buf *bytes.Buffer, b []byte) error {
184: 	authData := pool.Get(3)
185: 	defer pool.Put(authData)
186: 	rand.Read(authData)
187: 
188: 	md5Data := tools.HmacMD5(a.Key, authData)
189: 
190: 	randDataLength := udpGetRandLength(md5Data, &a.randomClient)
191: 
192: 	key := core.Kdf(base64.StdEncoding.EncodeToString(a.userKey)+base64.StdEncoding.EncodeToString(md5Data), 16)
193: 	rc4Cipher, err := rc4.NewCipher(key)
194: 	if err != nil {
195: 		return err
196: 	}
197: 	rc4Cipher.XORKeyStream(b, b)
198: 
199: 	buf.Write(b)
200: 	tools.AppendRandBytes(buf, randDataLength)
201: 	buf.Write(authData)
202: 	binary.Write(buf, binary.LittleEndian, binary.LittleEndian.Uint32(a.userID[:])^binary.LittleEndian.Uint32(md5Data[:4]))
203: 	buf.Write(tools.HmacMD5(a.userKey, buf.Bytes())[:1])
204: 	return nil
205: }
206: 
207: func (a *authChainA) packAuthData(poolBuf *bytes.Buffer, data []byte) {
208: 	/*
209: 		dataLength := len(data)
210: 		12:	checkHead(4) and hmac of checkHead(8)
211: 		4:	uint32 LittleEndian uid (uid = userID ^ last client hash)
212: 		16:	encrypted data of authdata(12), uint16 LittleEndian overhead(2) and uint16 LittleEndian number zero(2)
213: 		4:	last server hash(4)
214: 		packedAuthDataLength := 12 + 4 + 16 + 4 + dataLength
215: 	*/
216: 
217: 	macKey := pool.Get(len(a.iv) + len(a.Key))
218: 	defer pool.Put(macKey)
219: 	copy(macKey, a.iv)
220: 	copy(macKey[len(a.iv):], a.Key)
221: 
222: 	// check head
223: 	tools.AppendRandBytes(poolBuf, 4)
224: 	a.lastClientHash = tools.HmacMD5(macKey, poolBuf.Bytes())
225: 	a.initRC4Cipher()
226: 	poolBuf.Write(a.lastClientHash[:8])
227: 	// uid
228: 	binary.Write(poolBuf, binary.LittleEndian, binary.LittleEndian.Uint32(a.userID[:])^binary.LittleEndian.Uint32(a.lastClientHash[8:12]))
229: 	// encrypted data
230: 	err := a.putEncryptedData(poolBuf, a.userKey, [2]int{a.Overhead, 0}, a.salt)
231: 	if err != nil {
232: 		poolBuf.Reset()
233: 		return
234: 	}
235: 	// last server hash
236: 	a.lastServerHash = tools.HmacMD5(a.userKey, poolBuf.Bytes()[12:])
237: 	poolBuf.Write(a.lastServerHash[:4])
238: 	// packed data
239: 	a.packData(poolBuf, data)
240: }
241: 
242: func (a *authChainA) packData(poolBuf *bytes.Buffer, data []byte) {
243: 	a.encrypter.XORKeyStream(data, data)
244: 
245: 	macKey := pool.Get(len(a.userKey) + 4)
246: 	defer pool.Put(macKey)
247: 	copy(macKey, a.userKey)
248: 	binary.LittleEndian.PutUint32(macKey[len(a.userKey):], a.packID)
249: 	a.packID++
250: 
251: 	length := uint16(len(data)) ^ binary.LittleEndian.Uint16(a.lastClientHash[14:16])
252: 
253: 	originalLength := poolBuf.Len()
254: 	binary.Write(poolBuf, binary.LittleEndian, length)
255: 	a.putMixedRandDataAndData(poolBuf, data)
256: 	a.lastClientHash = tools.HmacMD5(macKey, poolBuf.Bytes()[originalLength:])
257: 	poolBuf.Write(a.lastClientHash[:2])
258: }
259: 
260: func (a *authChainA) putMixedRandDataAndData(poolBuf *bytes.Buffer, data []byte) {
261: 	randDataLength := a.randDataLength(len(data), a.lastClientHash, &a.randomClient)
262: 	if len(data) == 0 {
263: 		tools.AppendRandBytes(poolBuf, randDataLength)
264: 		return
265: 	}
266: 	if randDataLength > 0 {
267: 		startPos := getRandStartPos(randDataLength, &a.randomClient)
268: 		tools.AppendRandBytes(poolBuf, startPos)
269: 		poolBuf.Write(data)
270: 		tools.AppendRandBytes(poolBuf, randDataLength-startPos)
271: 		return
272: 	}
273: 	poolBuf.Write(data)
274: }
275: 
276: func getRandStartPos(length int, random *tools.XorShift128Plus) int {
277: 	if length == 0 {
278: 		return 0
279: 	}
280: 	return int(int64(random.Next()%8589934609) % int64(length))
281: }
282: 
283: func (a *authChainA) getRandLength(length int, lastHash []byte, random *tools.XorShift128Plus) int {
284: 	if length > 1440 {
285: 		return 0
286: 	}
287: 	random.InitFromBinAndLength(lastHash, length)
288: 	if length > 1300 {
289: 		return int(random.Next() % 31)
290: 	}
291: 	if length > 900 {
292: 		return int(random.Next() % 127)
293: 	}
294: 	if length > 400 {
295: 		return int(random.Next() % 521)
296: 	}
297: 	return int(random.Next() % 1021)
298: }
299: 
300: func (a *authChainA) initRC4Cipher() {
301: 	key := core.Kdf(base64.StdEncoding.EncodeToString(a.userKey)+base64.StdEncoding.EncodeToString(a.lastClientHash), 16)
302: 	a.encrypter, _ = rc4.NewCipher(key)
303: 	a.decrypter, _ = rc4.NewCipher(key)
304: }
305: 
306: func udpGetRandLength(lastHash []byte, random *tools.XorShift128Plus) int {
307: 	random.InitFromBin(lastHash)
308: 	return int(random.Next() % 127)
309: }


./transport\ssr\protocol\auth_chain_b.go
1: package protocol
2: 
3: import (
4: 	"net"
5: 	"sort"
6: 
7: 	"github.com/Dreamacro/clash/transport/ssr/tools"
8: )
9: 
10: func init() {
11: 	register("auth_chain_b", newAuthChainB, 4)
12: }
13: 
14: type authChainB struct {
15: 	*authChainA
16: 	dataSizeList  []int
17: 	dataSizeList2 []int
18: }
19: 
20: func newAuthChainB(b *Base) Protocol {
21: 	a := &authChainB{
22: 		authChainA: &authChainA{
23: 			Base:     b,
24: 			authData: &authData{},
25: 			userData: &userData{},
26: 			salt:     "auth_chain_b",
27: 		},
28: 	}
29: 	a.initUserData()
30: 	return a
31: }
32: 
33: func (a *authChainB) StreamConn(c net.Conn, iv []byte) net.Conn {
34: 	p := &authChainB{
35: 		authChainA: &authChainA{
36: 			Base:     a.Base,
37: 			authData: a.next(),
38: 			userData: a.userData,
39: 			salt:     a.salt,
40: 			packID:   1,
41: 			recvID:   1,
42: 		},
43: 	}
44: 	p.iv = iv
45: 	p.randDataLength = p.getRandLength
46: 	p.initDataSize()
47: 	return &Conn{Conn: c, Protocol: p}
48: }
49: 
50: func (a *authChainB) initDataSize() {
51: 	a.dataSizeList = a.dataSizeList[:0]
52: 	a.dataSizeList2 = a.dataSizeList2[:0]
53: 
54: 	a.randomServer.InitFromBin(a.Key)
55: 	length := a.randomServer.Next()%8 + 4
56: 	for ; length > 0; length-- {
57: 		a.dataSizeList = append(a.dataSizeList, int(a.randomServer.Next()%2340%2040%1440))
58: 	}
59: 	sort.Ints(a.dataSizeList)
60: 
61: 	length = a.randomServer.Next()%16 + 8
62: 	for ; length > 0; length-- {
63: 		a.dataSizeList2 = append(a.dataSizeList2, int(a.randomServer.Next()%2340%2040%1440))
64: 	}
65: 	sort.Ints(a.dataSizeList2)
66: }
67: 
68: func (a *authChainB) getRandLength(length int, lashHash []byte, random *tools.XorShift128Plus) int {
69: 	if length >= 1440 {
70: 		return 0
71: 	}
72: 	random.InitFromBinAndLength(lashHash, length)
73: 	pos := sort.Search(len(a.dataSizeList), func(i int) bool { return a.dataSizeList[i] >= length+a.Overhead })
74: 	finalPos := pos + int(random.Next()%uint64(len(a.dataSizeList)))
75: 	if finalPos < len(a.dataSizeList) {
76: 		return a.dataSizeList[finalPos] - length - a.Overhead
77: 	}
78: 
79: 	pos = sort.Search(len(a.dataSizeList2), func(i int) bool { return a.dataSizeList2[i] >= length+a.Overhead })
80: 	finalPos = pos + int(random.Next()%uint64(len(a.dataSizeList2)))
81: 	if finalPos < len(a.dataSizeList2) {
82: 		return a.dataSizeList2[finalPos] - length - a.Overhead
83: 	}
84: 	if finalPos < pos+len(a.dataSizeList2)-1 {
85: 		return 0
86: 	}
87: 	if length > 1300 {
88: 		return int(random.Next() % 31)
89: 	}
90: 	if length > 900 {
91: 		return int(random.Next() % 127)
92: 	}
93: 	if length > 400 {
94: 		return int(random.Next() % 521)
95: 	}
96: 	return int(random.Next() % 1021)
97: }


./transport\ssr\protocol\auth_sha1_v4.go
1: package protocol
2: 
3: import (
4: 	"bytes"
5: 	"encoding/binary"
6: 	"hash/adler32"
7: 	"hash/crc32"
8: 	"math/rand"
9: 	"net"
10: 
11: 	"github.com/Dreamacro/clash/common/pool"
12: 	"github.com/Dreamacro/clash/transport/ssr/tools"
13: )
14: 
15: func init() {
16: 	register("auth_sha1_v4", newAuthSHA1V4, 7)
17: }
18: 
19: type authSHA1V4 struct {
20: 	*Base
21: 	*authData
22: 	iv            []byte
23: 	hasSentHeader bool
24: 	rawTrans      bool
25: }
26: 
27: func newAuthSHA1V4(b *Base) Protocol {
28: 	return &authSHA1V4{Base: b, authData: &authData{}}
29: }
30: 
31: func (a *authSHA1V4) StreamConn(c net.Conn, iv []byte) net.Conn {
32: 	p := &authSHA1V4{Base: a.Base, authData: a.next()}
33: 	p.iv = iv
34: 	return &Conn{Conn: c, Protocol: p}
35: }
36: 
37: func (a *authSHA1V4) PacketConn(c net.PacketConn) net.PacketConn {
38: 	return c
39: }
40: 
41: func (a *authSHA1V4) Decode(dst, src *bytes.Buffer) error {
42: 	if a.rawTrans {
43: 		dst.ReadFrom(src)
44: 		return nil
45: 	}
46: 	for src.Len() > 4 {
47: 		if uint16(crc32.ChecksumIEEE(src.Bytes()[:2])&0xffff) != binary.LittleEndian.Uint16(src.Bytes()[2:4]) {
48: 			src.Reset()
49: 			return errAuthSHA1V4CRC32Error
50: 		}
51: 
52: 		length := int(binary.BigEndian.Uint16(src.Bytes()[:2]))
53: 		if length >= 8192 || length < 7 {
54: 			a.rawTrans = true
55: 			src.Reset()
56: 			return errAuthSHA1V4LengthError
57: 		}
58: 		if length > src.Len() {
59: 			break
60: 		}
61: 
62: 		if adler32.Checksum(src.Bytes()[:length-4]) != binary.LittleEndian.Uint32(src.Bytes()[length-4:length]) {
63: 			a.rawTrans = true
64: 			src.Reset()
65: 			return errAuthSHA1V4Adler32Error
66: 		}
67: 
68: 		pos := int(src.Bytes()[4])
69: 		if pos < 255 {
70: 			pos += 4
71: 		} else {
72: 			pos = int(binary.BigEndian.Uint16(src.Bytes()[5:7])) + 4
73: 		}
74: 		dst.Write(src.Bytes()[pos : length-4])
75: 		src.Next(length)
76: 	}
77: 	return nil
78: }
79: 
80: func (a *authSHA1V4) Encode(buf *bytes.Buffer, b []byte) error {
81: 	if !a.hasSentHeader {
82: 		dataLength := getDataLength(b)
83: 
84: 		a.packAuthData(buf, b[:dataLength])
85: 		b = b[dataLength:]
86: 
87: 		a.hasSentHeader = true
88: 	}
89: 	for len(b) > 8100 {
90: 		a.packData(buf, b[:8100])
91: 		b = b[8100:]
92: 	}
93: 	if len(b) > 0 {
94: 		a.packData(buf, b)
95: 	}
96: 
97: 	return nil
98: }
99: 
100: func (a *authSHA1V4) DecodePacket(b []byte) ([]byte, error) { return b, nil }
101: 
102: func (a *authSHA1V4) EncodePacket(buf *bytes.Buffer, b []byte) error {
103: 	buf.Write(b)
104: 	return nil
105: }
106: 
107: func (a *authSHA1V4) packData(poolBuf *bytes.Buffer, data []byte) {
108: 	dataLength := len(data)
109: 	randDataLength := a.getRandDataLength(dataLength)
110: 	/*
111: 		2:	uint16 BigEndian packedDataLength
112: 		2:	uint16 LittleEndian crc32Data & 0xffff
113: 		3:	maxRandDataLengthPrefix (min:1)
114: 		4:	adler32Data
115: 	*/
116: 	packedDataLength := 2 + 2 + 3 + randDataLength + dataLength + 4
117: 	if randDataLength < 128 {
118: 		packedDataLength -= 2
119: 	}
120: 
121: 	binary.Write(poolBuf, binary.BigEndian, uint16(packedDataLength))
122: 	binary.Write(poolBuf, binary.LittleEndian, uint16(crc32.ChecksumIEEE(poolBuf.Bytes()[poolBuf.Len()-2:])&0xffff))
123: 	a.packRandData(poolBuf, randDataLength)
124: 	poolBuf.Write(data)
125: 	binary.Write(poolBuf, binary.LittleEndian, adler32.Checksum(poolBuf.Bytes()[poolBuf.Len()-packedDataLength+4:]))
126: }
127: 
128: func (a *authSHA1V4) packAuthData(poolBuf *bytes.Buffer, data []byte) {
129: 	dataLength := len(data)
130: 	randDataLength := a.getRandDataLength(12 + dataLength)
131: 	/*
132: 		2:	uint16 BigEndian packedAuthDataLength
133: 		4:	uint32 LittleEndian crc32Data
134: 		3:	maxRandDataLengthPrefix (min: 1)
135: 		12:	authDataLength
136: 		10:	hmacSHA1DataLength
137: 	*/
138: 	packedAuthDataLength := 2 + 4 + 3 + randDataLength + 12 + dataLength + 10
139: 	if randDataLength < 128 {
140: 		packedAuthDataLength -= 2
141: 	}
142: 
143: 	salt := []byte("auth_sha1_v4")
144: 	crcData := pool.Get(len(salt) + len(a.Key) + 2)
145: 	defer pool.Put(crcData)
146: 	binary.BigEndian.PutUint16(crcData, uint16(packedAuthDataLength))
147: 	copy(crcData[2:], salt)
148: 	copy(crcData[2+len(salt):], a.Key)
149: 
150: 	key := pool.Get(len(a.iv) + len(a.Key))
151: 	defer pool.Put(key)
152: 	copy(key, a.iv)
153: 	copy(key[len(a.iv):], a.Key)
154: 
155: 	poolBuf.Write(crcData[:2])
156: 	binary.Write(poolBuf, binary.LittleEndian, crc32.ChecksumIEEE(crcData))
157: 	a.packRandData(poolBuf, randDataLength)
158: 	a.putAuthData(poolBuf)
159: 	poolBuf.Write(data)
160: 	poolBuf.Write(tools.HmacSHA1(key, poolBuf.Bytes()[poolBuf.Len()-packedAuthDataLength+10:])[:10])
161: }
162: 
163: func (a *authSHA1V4) packRandData(poolBuf *bytes.Buffer, size int) {
164: 	if size < 128 {
165: 		poolBuf.WriteByte(byte(size + 1))
166: 		tools.AppendRandBytes(poolBuf, size)
167: 		return
168: 	}
169: 	poolBuf.WriteByte(255)
170: 	binary.Write(poolBuf, binary.BigEndian, uint16(size+3))
171: 	tools.AppendRandBytes(poolBuf, size)
172: }
173: 
174: func (a *authSHA1V4) getRandDataLength(size int) int {
175: 	if size > 1200 {
176: 		return 0
177: 	}
178: 	if size > 400 {
179: 		return rand.Intn(256)
180: 	}
181: 	return rand.Intn(512)
182: }


./transport\ssr\protocol\base.go
1: package protocol
2: 
3: import (
4: 	"bytes"
5: 	"crypto/aes"
6: 	"crypto/cipher"
7: 	"crypto/rand"
8: 	"encoding/base64"
9: 	"encoding/binary"
10: 	mathRand "math/rand"
11: 	"sync"
12: 	"time"
13: 
14: 	"github.com/Dreamacro/clash/common/pool"
15: 	"github.com/Dreamacro/clash/log"
16: 	"github.com/Dreamacro/clash/transport/shadowsocks/core"
17: )
18: 
19: type Base struct {
20: 	Key      []byte
21: 	Overhead int
22: 	Param    string
23: }
24: 
25: type userData struct {
26: 	userKey []byte
27: 	userID  [4]byte
28: }
29: 
30: type authData struct {
31: 	clientID     [4]byte
32: 	connectionID uint32
33: 	mutex        sync.Mutex
34: }
35: 
36: func (a *authData) next() *authData {
37: 	r := &authData{}
38: 	a.mutex.Lock()
39: 	defer a.mutex.Unlock()
40: 	if a.connectionID > 0xff000000 || a.connectionID == 0 {
41: 		rand.Read(a.clientID[:])
42: 		a.connectionID = mathRand.Uint32() & 0xffffff
43: 	}
44: 	a.connectionID++
45: 	copy(r.clientID[:], a.clientID[:])
46: 	r.connectionID = a.connectionID
47: 	return r
48: }
49: 
50: func (a *authData) putAuthData(buf *bytes.Buffer) {
51: 	binary.Write(buf, binary.LittleEndian, uint32(time.Now().Unix()))
52: 	buf.Write(a.clientID[:])
53: 	binary.Write(buf, binary.LittleEndian, a.connectionID)
54: }
55: 
56: func (a *authData) putEncryptedData(b *bytes.Buffer, userKey []byte, paddings [2]int, salt string) error {
57: 	encrypt := pool.Get(16)
58: 	defer pool.Put(encrypt)
59: 	binary.LittleEndian.PutUint32(encrypt, uint32(time.Now().Unix()))
60: 	copy(encrypt[4:], a.clientID[:])
61: 	binary.LittleEndian.PutUint32(encrypt[8:], a.connectionID)
62: 	binary.LittleEndian.PutUint16(encrypt[12:], uint16(paddings[0]))
63: 	binary.LittleEndian.PutUint16(encrypt[14:], uint16(paddings[1]))
64: 
65: 	cipherKey := core.Kdf(base64.StdEncoding.EncodeToString(userKey)+salt, 16)
66: 	block, err := aes.NewCipher(cipherKey)
67: 	if err != nil {
68: 		log.Warnln("New cipher error: %s", err.Error())
69: 		return err
70: 	}
71: 	iv := bytes.Repeat([]byte{0}, 16)
72: 	cbcCipher := cipher.NewCBCEncrypter(block, iv)
73: 
74: 	cbcCipher.CryptBlocks(encrypt, encrypt)
75: 
76: 	b.Write(encrypt)
77: 	return nil
78: }


./transport\ssr\protocol\origin.go
1: package protocol
2: 
3: import (
4: 	"bytes"
5: 	"net"
6: )
7: 
8: type origin struct{}
9: 
10: func init() { register("origin", newOrigin, 0) }
11: 
12: func newOrigin(b *Base) Protocol { return &origin{} }
13: 
14: func (o *origin) StreamConn(c net.Conn, iv []byte) net.Conn { return c }
15: 
16: func (o *origin) PacketConn(c net.PacketConn) net.PacketConn { return c }
17: 
18: func (o *origin) Decode(dst, src *bytes.Buffer) error {
19: 	dst.ReadFrom(src)
20: 	return nil
21: }
22: 
23: func (o *origin) Encode(buf *bytes.Buffer, b []byte) error {
24: 	buf.Write(b)
25: 	return nil
26: }
27: 
28: func (o *origin) DecodePacket(b []byte) ([]byte, error) { return b, nil }
29: 
30: func (o *origin) EncodePacket(buf *bytes.Buffer, b []byte) error {
31: 	buf.Write(b)
32: 	return nil
33: }


./transport\ssr\protocol\packet.go
1: package protocol
2: 
3: import (
4: 	"net"
5: 
6: 	"github.com/Dreamacro/clash/common/pool"
7: )
8: 
9: type PacketConn struct {
10: 	net.PacketConn
11: 	Protocol
12: }
13: 
14: func (c *PacketConn) WriteTo(b []byte, addr net.Addr) (int, error) {
15: 	buf := pool.GetBuffer()
16: 	defer pool.PutBuffer(buf)
17: 	err := c.EncodePacket(buf, b)
18: 	if err != nil {
19: 		return 0, err
20: 	}
21: 	_, err = c.PacketConn.WriteTo(buf.Bytes(), addr)
22: 	return len(b), err
23: }
24: 
25: func (c *PacketConn) ReadFrom(b []byte) (int, net.Addr, error) {
26: 	n, addr, err := c.PacketConn.ReadFrom(b)
27: 	if err != nil {
28: 		return n, addr, err
29: 	}
30: 	decoded, err := c.DecodePacket(b[:n])
31: 	if err != nil {
32: 		return n, addr, err
33: 	}
34: 	copy(b, decoded)
35: 	return len(decoded), addr, nil
36: }


./transport\ssr\protocol\protocol.go
1: package protocol
2: 
3: import (
4: 	"bytes"
5: 	"errors"
6: 	"fmt"
7: 	"math/rand"
8: 	"net"
9: )
10: 
11: var (
12: 	errAuthSHA1V4CRC32Error   = errors.New("auth_sha1_v4 decode data wrong crc32")
13: 	errAuthSHA1V4LengthError  = errors.New("auth_sha1_v4 decode data wrong length")
14: 	errAuthSHA1V4Adler32Error = errors.New("auth_sha1_v4 decode data wrong adler32")
15: 	errAuthAES128MACError     = errors.New("auth_aes128 decode data wrong mac")
16: 	errAuthAES128LengthError  = errors.New("auth_aes128 decode data wrong length")
17: 	errAuthAES128ChksumError  = errors.New("auth_aes128 decode data wrong checksum")
18: 	errAuthChainLengthError   = errors.New("auth_chain decode data wrong length")
19: 	errAuthChainChksumError   = errors.New("auth_chain decode data wrong checksum")
20: )
21: 
22: type Protocol interface {
23: 	StreamConn(net.Conn, []byte) net.Conn
24: 	PacketConn(net.PacketConn) net.PacketConn
25: 	Decode(dst, src *bytes.Buffer) error
26: 	Encode(buf *bytes.Buffer, b []byte) error
27: 	DecodePacket([]byte) ([]byte, error)
28: 	EncodePacket(buf *bytes.Buffer, b []byte) error
29: }
30: 
31: type protocolCreator func(b *Base) Protocol
32: 
33: var protocolList = make(map[string]struct {
34: 	overhead int
35: 	new      protocolCreator
36: })
37: 
38: func register(name string, c protocolCreator, o int) {
39: 	protocolList[name] = struct {
40: 		overhead int
41: 		new      protocolCreator
42: 	}{overhead: o, new: c}
43: }
44: 
45: func PickProtocol(name string, b *Base) (Protocol, error) {
46: 	if choice, ok := protocolList[name]; ok {
47: 		b.Overhead += choice.overhead
48: 		return choice.new(b), nil
49: 	}
50: 	return nil, fmt.Errorf("protocol %s not supported", name)
51: }
52: 
53: func getHeadSize(b []byte, defaultValue int) int {
54: 	if len(b) < 2 {
55: 		return defaultValue
56: 	}
57: 	headType := b[0] & 7
58: 	switch headType {
59: 	case 1:
60: 		return 7
61: 	case 4:
62: 		return 19
63: 	case 3:
64: 		return 4 + int(b[1])
65: 	}
66: 	return defaultValue
67: }
68: 
69: func getDataLength(b []byte) int {
70: 	bLength := len(b)
71: 	dataLength := getHeadSize(b, 30) + rand.Intn(32)
72: 	if bLength < dataLength {
73: 		return bLength
74: 	}
75: 	return dataLength
76: }


./transport\ssr\protocol\stream.go
1: package protocol
2: 
3: import (
4: 	"bytes"
5: 	"net"
6: 
7: 	"github.com/Dreamacro/clash/common/pool"
8: )
9: 
10: type Conn struct {
11: 	net.Conn
12: 	Protocol
13: 	decoded      bytes.Buffer
14: 	underDecoded bytes.Buffer
15: }
16: 
17: func (c *Conn) Read(b []byte) (int, error) {
18: 	if c.decoded.Len() > 0 {
19: 		return c.decoded.Read(b)
20: 	}
21: 
22: 	buf := pool.Get(pool.RelayBufferSize)
23: 	defer pool.Put(buf)
24: 	n, err := c.Conn.Read(buf)
25: 	if err != nil {
26: 		return 0, err
27: 	}
28: 	c.underDecoded.Write(buf[:n])
29: 	err = c.Decode(&c.decoded, &c.underDecoded)
30: 	if err != nil {
31: 		return 0, err
32: 	}
33: 	n, _ = c.decoded.Read(b)
34: 	return n, nil
35: }
36: 
37: func (c *Conn) Write(b []byte) (int, error) {
38: 	bLength := len(b)
39: 	buf := pool.GetBuffer()
40: 	defer pool.PutBuffer(buf)
41: 	err := c.Encode(buf, b)
42: 	if err != nil {
43: 		return 0, err
44: 	}
45: 	_, err = c.Conn.Write(buf.Bytes())
46: 	if err != nil {
47: 		return 0, err
48: 	}
49: 	return bLength, nil
50: }


./transport\ssr\tools\bufPool.go
1: package tools
2: 
3: import (
4: 	"bytes"
5: 	"crypto/rand"
6: 	"io"
7: )
8: 
9: func AppendRandBytes(b *bytes.Buffer, length int) {
10: 	b.ReadFrom(io.LimitReader(rand.Reader, int64(length)))
11: }


./transport\ssr\tools\crypto.go
1: package tools
2: 
3: import (
4: 	"crypto/hmac"
5: 	"crypto/md5"
6: 	"crypto/sha1"
7: )
8: 
9: const HmacSHA1Len = 10
10: 
11: func HmacMD5(key, data []byte) []byte {
12: 	hmacMD5 := hmac.New(md5.New, key)
13: 	hmacMD5.Write(data)
14: 	return hmacMD5.Sum(nil)
15: }
16: 
17: func HmacSHA1(key, data []byte) []byte {
18: 	hmacSHA1 := hmac.New(sha1.New, key)
19: 	hmacSHA1.Write(data)
20: 	return hmacSHA1.Sum(nil)
21: }
22: 
23: func MD5Sum(b []byte) []byte {
24: 	h := md5.New()
25: 	h.Write(b)
26: 	return h.Sum(nil)
27: }
28: 
29: func SHA1Sum(b []byte) []byte {
30: 	h := sha1.New()
31: 	h.Write(b)
32: 	return h.Sum(nil)
33: }


./transport\ssr\tools\random.go
1: package tools
2: 
3: import (
4: 	"encoding/binary"
5: 
6: 	"github.com/Dreamacro/clash/common/pool"
7: )
8: 
9: // XorShift128Plus - a pseudorandom number generator
10: type XorShift128Plus struct {
11: 	s [2]uint64
12: }
13: 
14: func (r *XorShift128Plus) Next() uint64 {
15: 	x := r.s[0]
16: 	y := r.s[1]
17: 	r.s[0] = y
18: 	x ^= x << 23
19: 	x ^= y ^ (x >> 17) ^ (y >> 26)
20: 	r.s[1] = x
21: 	return x + y
22: }
23: 
24: func (r *XorShift128Plus) InitFromBin(bin []byte) {
25: 	var full []byte
26: 	if len(bin) < 16 {
27: 		full := pool.Get(16)[:0]
28: 		defer pool.Put(full)
29: 		full = append(full, bin...)
30: 		for len(full) < 16 {
31: 			full = append(full, 0)
32: 		}
33: 	} else {
34: 		full = bin
35: 	}
36: 	r.s[0] = binary.LittleEndian.Uint64(full[:8])
37: 	r.s[1] = binary.LittleEndian.Uint64(full[8:16])
38: }
39: 
40: func (r *XorShift128Plus) InitFromBinAndLength(bin []byte, length int) {
41: 	var full []byte
42: 	if len(bin) < 16 {
43: 		full := pool.Get(16)[:0]
44: 		defer pool.Put(full)
45: 		full = append(full, bin...)
46: 		for len(full) < 16 {
47: 			full = append(full, 0)
48: 		}
49: 	}
50: 	full = bin
51: 	binary.LittleEndian.PutUint16(full, uint16(length))
52: 	r.s[0] = binary.LittleEndian.Uint64(full[:8])
53: 	r.s[1] = binary.LittleEndian.Uint64(full[8:16])
54: 	for i := 0; i < 4; i++ {
55: 		r.Next()
56: 	}
57: }


./transport\trojan\trojan.go
1: package trojan
2: 
3: import (
4: 	"context"
5: 	"crypto/sha256"
6: 	"crypto/tls"
7: 	"encoding/binary"
8: 	"encoding/hex"
9: 	"errors"
10: 	"io"
11: 	"net"
12: 	"net/http"
13: 	"sync"
14: 
15: 	C "github.com/Dreamacro/clash/constant"
16: 	"github.com/Dreamacro/clash/transport/socks5"
17: 	"github.com/Dreamacro/clash/transport/vmess"
18: 
19: 	"github.com/Dreamacro/protobytes"
20: )
21: 
22: const (
23: 	// max packet length
24: 	maxLength = 8192
25: )
26: 
27: var (
28: 	defaultALPN          = []string{"h2", "http/1.1"}
29: 	defaultWebsocketALPN = []string{"http/1.1"}
30: 
31: 	crlf = []byte{'\r', '\n'}
32: )
33: 
34: type Command = byte
35: 
36: var (
37: 	CommandTCP byte = 1
38: 	CommandUDP byte = 3
39: )
40: 
41: type Option struct {
42: 	Password       string
43: 	ALPN           []string
44: 	ServerName     string
45: 	SkipCertVerify bool
46: }
47: 
48: type WebsocketOption struct {
49: 	Host    string
50: 	Port    string
51: 	Path    string
52: 	Headers http.Header
53: }
54: 
55: type Trojan struct {
56: 	option      *Option
57: 	hexPassword []byte
58: }
59: 
60: func (t *Trojan) StreamConn(conn net.Conn) (net.Conn, error) {
61: 	alpn := defaultALPN
62: 	if len(t.option.ALPN) != 0 {
63: 		alpn = t.option.ALPN
64: 	}
65: 
66: 	tlsConfig := &tls.Config{
67: 		NextProtos:         alpn,
68: 		MinVersion:         tls.VersionTLS12,
69: 		InsecureSkipVerify: t.option.SkipCertVerify,
70: 		ServerName:         t.option.ServerName,
71: 	}
72: 
73: 	tlsConn := tls.Client(conn, tlsConfig)
74: 
75: 	// fix tls handshake not timeout
76: 	ctx, cancel := context.WithTimeout(context.Background(), C.DefaultTLSTimeout)
77: 	defer cancel()
78: 	if err := tlsConn.HandshakeContext(ctx); err != nil {
79: 		return nil, err
80: 	}
81: 
82: 	return tlsConn, nil
83: }
84: 
85: func (t *Trojan) StreamWebsocketConn(conn net.Conn, wsOptions *WebsocketOption) (net.Conn, error) {
86: 	alpn := defaultWebsocketALPN
87: 	if len(t.option.ALPN) != 0 {
88: 		alpn = t.option.ALPN
89: 	}
90: 
91: 	tlsConfig := &tls.Config{
92: 		NextProtos:         alpn,
93: 		MinVersion:         tls.VersionTLS12,
94: 		InsecureSkipVerify: t.option.SkipCertVerify,
95: 		ServerName:         t.option.ServerName,
96: 	}
97: 
98: 	return vmess.StreamWebsocketConn(conn, &vmess.WebsocketConfig{
99: 		Host:      wsOptions.Host,
100: 		Port:      wsOptions.Port,
101: 		Path:      wsOptions.Path,
102: 		Headers:   wsOptions.Headers,
103: 		TLS:       true,
104: 		TLSConfig: tlsConfig,
105: 	})
106: }
107: 
108: func (t *Trojan) WriteHeader(w io.Writer, command Command, socks5Addr []byte) error {
109: 	buf := protobytes.BytesWriter{}
110: 	buf.PutSlice(t.hexPassword)
111: 	buf.PutSlice(crlf)
112: 
113: 	buf.PutUint8(command)
114: 	buf.PutSlice(socks5Addr)
115: 	buf.PutSlice(crlf)
116: 
117: 	_, err := w.Write(buf.Bytes())
118: 	return err
119: }
120: 
121: func (t *Trojan) PacketConn(conn net.Conn) net.PacketConn {
122: 	return &PacketConn{
123: 		Conn: conn,
124: 	}
125: }
126: 
127: func writePacket(w io.Writer, socks5Addr, payload []byte) (int, error) {
128: 	buf := protobytes.BytesWriter{}
129: 	buf.PutSlice(socks5Addr)
130: 	buf.PutUint16be(uint16(len(payload)))
131: 	buf.PutSlice(crlf)
132: 	buf.PutSlice(payload)
133: 	return w.Write(buf.Bytes())
134: }
135: 
136: func WritePacket(w io.Writer, socks5Addr, payload []byte) (int, error) {
137: 	if len(payload) <= maxLength {
138: 		return writePacket(w, socks5Addr, payload)
139: 	}
140: 
141: 	offset := 0
142: 	total := len(payload)
143: 	for {
144: 		cursor := offset + maxLength
145: 		if cursor > total {
146: 			cursor = total
147: 		}
148: 
149: 		n, err := writePacket(w, socks5Addr, payload[offset:cursor])
150: 		if err != nil {
151: 			return offset + n, err
152: 		}
153: 
154: 		offset = cursor
155: 		if offset == total {
156: 			break
157: 		}
158: 	}
159: 
160: 	return total, nil
161: }
162: 
163: func ReadPacket(r io.Reader, payload []byte) (net.Addr, int, int, error) {
164: 	addr, err := socks5.ReadAddr(r, payload)
165: 	if err != nil {
166: 		return nil, 0, 0, errors.New("read addr error")
167: 	}
168: 	uAddr := addr.UDPAddr()
169: 	if uAddr == nil {
170: 		return nil, 0, 0, errors.New("parse addr error")
171: 	}
172: 
173: 	if _, err = io.ReadFull(r, payload[:2]); err != nil {
174: 		return nil, 0, 0, errors.New("read length error")
175: 	}
176: 
177: 	total := int(binary.BigEndian.Uint16(payload[:2]))
178: 	if total > maxLength {
179: 		return nil, 0, 0, errors.New("packet invalid")
180: 	}
181: 
182: 	// read crlf
183: 	if _, err = io.ReadFull(r, payload[:2]); err != nil {
184: 		return nil, 0, 0, errors.New("read crlf error")
185: 	}
186: 
187: 	length := len(payload)
188: 	if total < length {
189: 		length = total
190: 	}
191: 
192: 	if _, err = io.ReadFull(r, payload[:length]); err != nil {
193: 		return nil, 0, 0, errors.New("read packet error")
194: 	}
195: 
196: 	return uAddr, length, total - length, nil
197: }
198: 
199: func New(option *Option) *Trojan {
200: 	return &Trojan{option, hexSha224([]byte(option.Password))}
201: }
202: 
203: type PacketConn struct {
204: 	net.Conn
205: 	remain int
206: 	rAddr  net.Addr
207: 	mux    sync.Mutex
208: }
209: 
210: func (pc *PacketConn) WriteTo(b []byte, addr net.Addr) (int, error) {
211: 	return WritePacket(pc, socks5.ParseAddr(addr.String()), b)
212: }
213: 
214: func (pc *PacketConn) ReadFrom(b []byte) (int, net.Addr, error) {
215: 	pc.mux.Lock()
216: 	defer pc.mux.Unlock()
217: 	if pc.remain != 0 {
218: 		length := len(b)
219: 		if pc.remain < length {
220: 			length = pc.remain
221: 		}
222: 
223: 		n, err := pc.Conn.Read(b[:length])
224: 		if err != nil {
225: 			return 0, nil, err
226: 		}
227: 
228: 		pc.remain -= n
229: 		addr := pc.rAddr
230: 		if pc.remain == 0 {
231: 			pc.rAddr = nil
232: 		}
233: 
234: 		return n, addr, nil
235: 	}
236: 
237: 	addr, n, remain, err := ReadPacket(pc.Conn, b)
238: 	if err != nil {
239: 		return 0, nil, err
240: 	}
241: 
242: 	if remain != 0 {
243: 		pc.remain = remain
244: 		pc.rAddr = addr
245: 	}
246: 
247: 	return n, addr, nil
248: }
249: 
250: func hexSha224(data []byte) []byte {
251: 	buf := make([]byte, 56)
252: 	hash := sha256.New224()
253: 	hash.Write(data)
254: 	hex.Encode(buf, hash.Sum(nil))
255: 	return buf
256: }


./transport\v2ray-plugin\mux.go
1: package obfs
2: 
3: import (
4: 	"encoding/binary"
5: 	"errors"
6: 	"io"
7: 	"net"
8: 	"net/netip"
9: 
10: 	"github.com/Dreamacro/protobytes"
11: )
12: 
13: type SessionStatus = byte
14: 
15: const (
16: 	SessionStatusNew       SessionStatus = 0x01
17: 	SessionStatusKeep      SessionStatus = 0x02
18: 	SessionStatusEnd       SessionStatus = 0x03
19: 	SessionStatusKeepAlive SessionStatus = 0x04
20: )
21: 
22: const (
23: 	OptionNone  = byte(0x00)
24: 	OptionData  = byte(0x01)
25: 	OptionError = byte(0x02)
26: )
27: 
28: type MuxOption struct {
29: 	ID   [2]byte
30: 	Port uint16
31: 	Host string
32: 	Type string
33: }
34: 
35: // Mux is an mux-compatible client for v2ray-plugin, not a complete implementation
36: type Mux struct {
37: 	net.Conn
38: 	buf    protobytes.BytesWriter
39: 	id     [2]byte
40: 	length [2]byte
41: 	status [2]byte
42: 	otb    []byte
43: 	remain int
44: }
45: 
46: func (m *Mux) Read(b []byte) (int, error) {
47: 	if m.remain != 0 {
48: 		length := m.remain
49: 		if len(b) < m.remain {
50: 			length = len(b)
51: 		}
52: 
53: 		n, err := m.Conn.Read(b[:length])
54: 		if err != nil {
55: 			return 0, err
56: 		}
57: 		m.remain -= n
58: 		return n, nil
59: 	}
60: 
61: 	for {
62: 		_, err := io.ReadFull(m.Conn, m.length[:])
63: 		if err != nil {
64: 			return 0, err
65: 		}
66: 		length := binary.BigEndian.Uint16(m.length[:])
67: 		if length > 512 {
68: 			return 0, errors.New("invalid metalen")
69: 		}
70: 
71: 		_, err = io.ReadFull(m.Conn, m.id[:])
72: 		if err != nil {
73: 			return 0, err
74: 		}
75: 
76: 		_, err = m.Conn.Read(m.status[:])
77: 		if err != nil {
78: 			return 0, err
79: 		}
80: 
81: 		opcode := m.status[0]
82: 		if opcode == SessionStatusKeepAlive {
83: 			continue
84: 		}
85: 
86: 		opts := m.status[1]
87: 
88: 		if opts != OptionData {
89: 			continue
90: 		}
91: 
92: 		_, err = io.ReadFull(m.Conn, m.length[:])
93: 		if err != nil {
94: 			return 0, err
95: 		}
96: 		dataLen := int(binary.BigEndian.Uint16(m.length[:]))
97: 		m.remain = dataLen
98: 		if dataLen > len(b) {
99: 			dataLen = len(b)
100: 		}
101: 
102: 		n, err := m.Conn.Read(b[:dataLen])
103: 		m.remain -= n
104: 		return n, err
105: 	}
106: }
107: 
108: func (m *Mux) Write(b []byte) (int, error) {
109: 	if m.otb != nil {
110: 		// create a sub connection
111: 		if _, err := m.Conn.Write(m.otb); err != nil {
112: 			return 0, err
113: 		}
114: 		m.otb = nil
115: 	}
116: 	m.buf.Reset()
117: 	m.buf.PutUint16be(4)
118: 	m.buf.PutSlice(m.id[:])
119: 	m.buf.PutUint8(SessionStatusKeep)
120: 	m.buf.PutUint8(OptionData)
121: 	m.buf.PutUint16be(uint16(len(b)))
122: 	m.buf.Write(b)
123: 
124: 	return m.Conn.Write(m.buf.Bytes())
125: }
126: 
127: func (m *Mux) Close() error {
128: 	_, err := m.Conn.Write([]byte{0x0, 0x4, m.id[0], m.id[1], SessionStatusEnd, OptionNone})
129: 	if err != nil {
130: 		return err
131: 	}
132: 	return m.Conn.Close()
133: }
134: 
135: func NewMux(conn net.Conn, option MuxOption) *Mux {
136: 	buf := protobytes.BytesWriter{}
137: 
138: 	// fill empty length
139: 	buf.PutSlice([]byte{0x0, 0x0})
140: 	buf.PutSlice(option.ID[:])
141: 	buf.PutUint8(SessionStatusNew)
142: 	buf.PutUint8(OptionNone)
143: 
144: 	// tcp
145: 	netType := byte(0x1)
146: 	if option.Type == "udp" {
147: 		netType = byte(0x2)
148: 	}
149: 	buf.PutUint8(netType)
150: 
151: 	// port
152: 	buf.PutUint16be(option.Port)
153: 
154: 	// address
155: 	ip, err := netip.ParseAddr(option.Host)
156: 	if err != nil {
157: 		buf.PutUint8(0x2)
158: 		buf.PutString(option.Host)
159: 	} else if ip.Is4() {
160: 		buf.PutUint8(0x1)
161: 		buf.PutSlice(ip.AsSlice())
162: 	} else {
163: 		buf.PutUint8(0x3)
164: 		buf.PutSlice(ip.AsSlice())
165: 	}
166: 
167: 	metadata := buf.Bytes()
168: 	binary.BigEndian.PutUint16(metadata[:2], uint16(len(metadata)-2))
169: 
170: 	return &Mux{
171: 		Conn: conn,
172: 		id:   option.ID,
173: 		otb:  metadata,
174: 	}
175: }


./transport\v2ray-plugin\websocket.go
1: package obfs
2: 
3: import (
4: 	"crypto/tls"
5: 	"net"
6: 	"net/http"
7: 
8: 	"github.com/Dreamacro/clash/transport/vmess"
9: )
10: 
11: // Option is options of websocket obfs
12: type Option struct {
13: 	Host           string
14: 	Port           string
15: 	Path           string
16: 	Headers        map[string]string
17: 	TLS            bool
18: 	SkipCertVerify bool
19: 	Mux            bool
20: }
21: 
22: // NewV2rayObfs return a HTTPObfs
23: func NewV2rayObfs(conn net.Conn, option *Option) (net.Conn, error) {
24: 	header := http.Header{}
25: 	for k, v := range option.Headers {
26: 		header.Add(k, v)
27: 	}
28: 
29: 	config := &vmess.WebsocketConfig{
30: 		Host:    option.Host,
31: 		Port:    option.Port,
32: 		Path:    option.Path,
33: 		Headers: header,
34: 	}
35: 
36: 	if option.TLS {
37: 		config.TLS = true
38: 		config.TLSConfig = &tls.Config{
39: 			ServerName:         option.Host,
40: 			InsecureSkipVerify: option.SkipCertVerify,
41: 			NextProtos:         []string{"http/1.1"},
42: 		}
43: 		if host := config.Headers.Get("Host"); host != "" {
44: 			config.TLSConfig.ServerName = host
45: 		}
46: 	}
47: 
48: 	var err error
49: 	conn, err = vmess.StreamWebsocketConn(conn, config)
50: 	if err != nil {
51: 		return nil, err
52: 	}
53: 
54: 	if option.Mux {
55: 		conn = NewMux(conn, MuxOption{
56: 			ID:   [2]byte{0, 0},
57: 			Host: "127.0.0.1",
58: 			Port: 0,
59: 		})
60: 	}
61: 	return conn, nil
62: }


./transport\vmess\aead.go
1: package vmess
2: 
3: import (
4: 	"crypto/cipher"
5: 	"encoding/binary"
6: 	"errors"
7: 	"io"
8: 	"sync"
9: 
10: 	"github.com/Dreamacro/clash/common/pool"
11: )
12: 
13: type aeadWriter struct {
14: 	io.Writer
15: 	cipher.AEAD
16: 	nonce [32]byte
17: 	count uint16
18: 	iv    []byte
19: 
20: 	writeLock sync.Mutex
21: }
22: 
23: func newAEADWriter(w io.Writer, aead cipher.AEAD, iv []byte) *aeadWriter {
24: 	return &aeadWriter{Writer: w, AEAD: aead, iv: iv}
25: }
26: 
27: func (w *aeadWriter) Write(b []byte) (n int, err error) {
28: 	w.writeLock.Lock()
29: 	buf := pool.Get(pool.RelayBufferSize)
30: 	defer func() {
31: 		w.writeLock.Unlock()
32: 		pool.Put(buf)
33: 	}()
34: 	length := len(b)
35: 	for {
36: 		if length == 0 {
37: 			break
38: 		}
39: 		readLen := chunkSize - w.Overhead()
40: 		if length < readLen {
41: 			readLen = length
42: 		}
43: 		payloadBuf := buf[lenSize : lenSize+chunkSize-w.Overhead()]
44: 		copy(payloadBuf, b[n:n+readLen])
45: 
46: 		binary.BigEndian.PutUint16(buf[:lenSize], uint16(readLen+w.Overhead()))
47: 		binary.BigEndian.PutUint16(w.nonce[:2], w.count)
48: 		copy(w.nonce[2:], w.iv[2:12])
49: 
50: 		w.Seal(payloadBuf[:0], w.nonce[:w.NonceSize()], payloadBuf[:readLen], nil)
51: 		w.count++
52: 
53: 		_, err = w.Writer.Write(buf[:lenSize+readLen+w.Overhead()])
54: 		if err != nil {
55: 			break
56: 		}
57: 		n += readLen
58: 		length -= readLen
59: 	}
60: 	return
61: }
62: 
63: type aeadReader struct {
64: 	io.Reader
65: 	cipher.AEAD
66: 	nonce   [32]byte
67: 	buf     []byte
68: 	offset  int
69: 	iv      []byte
70: 	sizeBuf []byte
71: 	count   uint16
72: }
73: 
74: func newAEADReader(r io.Reader, aead cipher.AEAD, iv []byte) *aeadReader {
75: 	return &aeadReader{Reader: r, AEAD: aead, iv: iv, sizeBuf: make([]byte, lenSize)}
76: }
77: 
78: func (r *aeadReader) Read(b []byte) (int, error) {
79: 	if r.buf != nil {
80: 		n := copy(b, r.buf[r.offset:])
81: 		r.offset += n
82: 		if r.offset == len(r.buf) {
83: 			pool.Put(r.buf)
84: 			r.buf = nil
85: 		}
86: 		return n, nil
87: 	}
88: 
89: 	_, err := io.ReadFull(r.Reader, r.sizeBuf)
90: 	if err != nil {
91: 		return 0, err
92: 	}
93: 
94: 	size := int(binary.BigEndian.Uint16(r.sizeBuf))
95: 	if size > maxSize {
96: 		return 0, errors.New("buffer is larger than standard")
97: 	}
98: 
99: 	buf := pool.Get(size)
100: 	_, err = io.ReadFull(r.Reader, buf[:size])
101: 	if err != nil {
102: 		pool.Put(buf)
103: 		return 0, err
104: 	}
105: 
106: 	binary.BigEndian.PutUint16(r.nonce[:2], r.count)
107: 	copy(r.nonce[2:], r.iv[2:12])
108: 
109: 	_, err = r.Open(buf[:0], r.nonce[:r.NonceSize()], buf[:size], nil)
110: 	r.count++
111: 	if err != nil {
112: 		return 0, err
113: 	}
114: 	realLen := size - r.Overhead()
115: 	n := copy(b, buf[:realLen])
116: 	if len(b) >= realLen {
117: 		pool.Put(buf)
118: 		return n, nil
119: 	}
120: 
121: 	r.offset = n
122: 	r.buf = buf[:realLen]
123: 	return n, nil
124: }


./transport\vmess\chunk.go
1: package vmess
2: 
3: import (
4: 	"encoding/binary"
5: 	"errors"
6: 	"io"
7: 
8: 	"github.com/Dreamacro/clash/common/pool"
9: )
10: 
11: const (
12: 	lenSize   = 2
13: 	chunkSize = 1 << 14   // 2 ** 14 == 16 * 1024
14: 	maxSize   = 17 * 1024 // 2 + chunkSize + aead.Overhead()
15: )
16: 
17: type chunkReader struct {
18: 	io.Reader
19: 	buf     []byte
20: 	sizeBuf []byte
21: 	offset  int
22: }
23: 
24: func newChunkReader(reader io.Reader) *chunkReader {
25: 	return &chunkReader{Reader: reader, sizeBuf: make([]byte, lenSize)}
26: }
27: 
28: func newChunkWriter(writer io.WriteCloser) *chunkWriter {
29: 	return &chunkWriter{Writer: writer}
30: }
31: 
32: func (cr *chunkReader) Read(b []byte) (int, error) {
33: 	if cr.buf != nil {
34: 		n := copy(b, cr.buf[cr.offset:])
35: 		cr.offset += n
36: 		if cr.offset == len(cr.buf) {
37: 			pool.Put(cr.buf)
38: 			cr.buf = nil
39: 		}
40: 		return n, nil
41: 	}
42: 
43: 	_, err := io.ReadFull(cr.Reader, cr.sizeBuf)
44: 	if err != nil {
45: 		return 0, err
46: 	}
47: 
48: 	size := int(binary.BigEndian.Uint16(cr.sizeBuf))
49: 	if size > maxSize {
50: 		return 0, errors.New("buffer is larger than standard")
51: 	}
52: 
53: 	if len(b) >= size {
54: 		_, err := io.ReadFull(cr.Reader, b[:size])
55: 		if err != nil {
56: 			return 0, err
57: 		}
58: 
59: 		return size, nil
60: 	}
61: 
62: 	buf := pool.Get(size)
63: 	_, err = io.ReadFull(cr.Reader, buf)
64: 	if err != nil {
65: 		pool.Put(buf)
66: 		return 0, err
67: 	}
68: 	n := copy(b, buf)
69: 	cr.offset = n
70: 	cr.buf = buf
71: 	return n, nil
72: }
73: 
74: type chunkWriter struct {
75: 	io.Writer
76: }
77: 
78: func (cw *chunkWriter) Write(b []byte) (n int, err error) {
79: 	buf := pool.Get(pool.RelayBufferSize)
80: 	defer pool.Put(buf)
81: 	length := len(b)
82: 	for {
83: 		if length == 0 {
84: 			break
85: 		}
86: 		readLen := chunkSize
87: 		if length < chunkSize {
88: 			readLen = length
89: 		}
90: 		payloadBuf := buf[lenSize : lenSize+chunkSize]
91: 		copy(payloadBuf, b[n:n+readLen])
92: 
93: 		binary.BigEndian.PutUint16(buf[:lenSize], uint16(readLen))
94: 		_, err = cw.Writer.Write(buf[:lenSize+readLen])
95: 		if err != nil {
96: 			break
97: 		}
98: 		n += readLen
99: 		length -= readLen
100: 	}
101: 	return
102: }


./transport\vmess\conn.go
1: package vmess
2: 
3: import (
4: 	"crypto/aes"
5: 	"crypto/cipher"
6: 	"crypto/hmac"
7: 	"crypto/md5"
8: 	"crypto/rand"
9: 	"crypto/sha256"
10: 	"encoding/binary"
11: 	"errors"
12: 	"hash/fnv"
13: 	"io"
14: 	mathRand "math/rand"
15: 	"net"
16: 	"time"
17: 
18: 	"github.com/Dreamacro/protobytes"
19: 	"golang.org/x/crypto/chacha20poly1305"
20: )
21: 
22: // Conn wrapper a net.Conn with vmess protocol
23: type Conn struct {
24: 	net.Conn
25: 	reader      io.Reader
26: 	writer      io.Writer
27: 	dst         *DstAddr
28: 	id          *ID
29: 	reqBodyIV   []byte
30: 	reqBodyKey  []byte
31: 	respBodyIV  []byte
32: 	respBodyKey []byte
33: 	respV       byte
34: 	security    byte
35: 	option      byte
36: 	isAead      bool
37: 	isVless     bool
38: 
39: 	received bool
40: }
41: 
42: func (vc *Conn) Write(b []byte) (int, error) {
43: 	return vc.writer.Write(b)
44: }
45: 
46: func (vc *Conn) Read(b []byte) (int, error) {
47: 	if vc.received {
48: 		return vc.reader.Read(b)
49: 	}
50: 
51: 	if err := vc.recvResponse(); err != nil {
52: 		return 0, err
53: 	}
54: 	vc.received = true
55: 	return vc.reader.Read(b)
56: }
57: 
58: func (vc *Conn) sendRequest() error {
59: 	if vc.isVless {
60: 		buf := protobytes.BytesWriter{}
61: 		buf.PutUint8(0)                  // Protocol Version
62: 		buf.PutSlice(vc.id.UUID.Bytes()) // UUID
63: 		buf.PutUint8(0)                  // Addons Length
64: 		// buf.PutString("")             // Addons Data
65: 
66: 		// Command
67: 		if vc.dst.UDP {
68: 			buf.PutUint8(CommandUDP)
69: 		} else {
70: 			buf.PutUint8(CommandTCP)
71: 		}
72: 
73: 		// Port AddrType Addr
74: 		buf.PutUint16be(uint16(vc.dst.Port))
75: 		buf.PutUint8(vc.dst.AddrType)
76: 		buf.PutSlice(vc.dst.Addr)
77: 
78: 		_, err := vc.Conn.Write(buf.Bytes())
79: 		return err
80: 	}
81: 
82: 	timestamp := time.Now()
83: 
84: 	mbuf := protobytes.BytesWriter{}
85: 
86: 	if !vc.isAead {
87: 		h := hmac.New(md5.New, vc.id.UUID.Bytes())
88: 		binary.Write(h, binary.BigEndian, uint64(timestamp.Unix()))
89: 		mbuf.PutSlice(h.Sum(nil))
90: 	}
91: 
92: 	buf := protobytes.BytesWriter{}
93: 
94: 	// Ver IV Key V Opt
95: 	buf.PutUint8(Version)
96: 	buf.PutSlice(vc.reqBodyIV[:])
97: 	buf.PutSlice(vc.reqBodyKey[:])
98: 	buf.PutUint8(vc.respV)
99: 	buf.PutUint8(vc.option)
100: 
101: 	p := mathRand.Intn(16)
102: 	// P Sec Reserve Cmd
103: 	buf.PutUint8(byte(p<<4) | vc.security)
104: 	buf.PutUint8(0)
105: 	if vc.dst.UDP {
106: 		buf.PutUint8(CommandUDP)
107: 	} else {
108: 		buf.PutUint8(CommandTCP)
109: 	}
110: 
111: 	// Port AddrType Addr
112: 	buf.PutUint16be(uint16(vc.dst.Port))
113: 	buf.PutUint8(vc.dst.AddrType)
114: 	buf.PutSlice(vc.dst.Addr)
115: 
116: 	// padding
117: 	if p > 0 {
118: 		buf.ReadFull(rand.Reader, p)
119: 	}
120: 
121: 	fnv1a := fnv.New32a()
122: 	fnv1a.Write(buf.Bytes())
123: 	buf.PutSlice(fnv1a.Sum(nil))
124: 
125: 	if !vc.isAead {
126: 		block, err := aes.NewCipher(vc.id.CmdKey)
127: 		if err != nil {
128: 			return err
129: 		}
130: 
131: 		stream := cipher.NewCFBEncrypter(block, hashTimestamp(timestamp))
132: 		stream.XORKeyStream(buf.Bytes(), buf.Bytes())
133: 		mbuf.PutSlice(buf.Bytes())
134: 		_, err = vc.Conn.Write(mbuf.Bytes())
135: 		return err
136: 	}
137: 
138: 	var fixedLengthCmdKey [16]byte
139: 	copy(fixedLengthCmdKey[:], vc.id.CmdKey)
140: 	vmessout := sealVMessAEADHeader(fixedLengthCmdKey, buf.Bytes(), timestamp)
141: 	_, err := vc.Conn.Write(vmessout)
142: 	return err
143: }
144: 
145: func (vc *Conn) recvResponse() error {
146: 	if vc.isVless {
147: 		var buffer [2]byte
148: 		if _, err := io.ReadFull(vc.Conn, buffer[:]); err != nil {
149: 			return err
150: 		}
151: 
152: 		if buffer[0] != 0 {
153: 			return errors.New("unexpected response version")
154: 		}
155: 
156: 		length := int64(buffer[1])
157: 		if length != 0 { // addon data length > 0
158: 			io.CopyN(io.Discard, vc.Conn, length) // just discard
159: 		}
160: 
161: 		return nil
162: 	}
163: 
164: 	var buf []byte
165: 	if !vc.isAead {
166: 		block, err := aes.NewCipher(vc.respBodyKey[:])
167: 		if err != nil {
168: 			return err
169: 		}
170: 
171: 		stream := cipher.NewCFBDecrypter(block, vc.respBodyIV[:])
172: 		buf = make([]byte, 4)
173: 		_, err = io.ReadFull(vc.Conn, buf)
174: 		if err != nil {
175: 			return err
176: 		}
177: 		stream.XORKeyStream(buf, buf)
178: 	} else {
179: 		aeadResponseHeaderLengthEncryptionKey := kdf(vc.respBodyKey[:], kdfSaltConstAEADRespHeaderLenKey)[:16]
180: 		aeadResponseHeaderLengthEncryptionIV := kdf(vc.respBodyIV[:], kdfSaltConstAEADRespHeaderLenIV)[:12]
181: 
182: 		aeadResponseHeaderLengthEncryptionKeyAESBlock, _ := aes.NewCipher(aeadResponseHeaderLengthEncryptionKey)
183: 		aeadResponseHeaderLengthEncryptionAEAD, _ := cipher.NewGCM(aeadResponseHeaderLengthEncryptionKeyAESBlock)
184: 
185: 		aeadEncryptedResponseHeaderLength := make([]byte, 18)
186: 		if _, err := io.ReadFull(vc.Conn, aeadEncryptedResponseHeaderLength); err != nil {
187: 			return err
188: 		}
189: 
190: 		decryptedResponseHeaderLengthBinaryBuffer, err := aeadResponseHeaderLengthEncryptionAEAD.Open(nil, aeadResponseHeaderLengthEncryptionIV, aeadEncryptedResponseHeaderLength[:], nil)
191: 		if err != nil {
192: 			return err
193: 		}
194: 
195: 		decryptedResponseHeaderLength := binary.BigEndian.Uint16(decryptedResponseHeaderLengthBinaryBuffer)
196: 		aeadResponseHeaderPayloadEncryptionKey := kdf(vc.respBodyKey[:], kdfSaltConstAEADRespHeaderPayloadKey)[:16]
197: 		aeadResponseHeaderPayloadEncryptionIV := kdf(vc.respBodyIV[:], kdfSaltConstAEADRespHeaderPayloadIV)[:12]
198: 		aeadResponseHeaderPayloadEncryptionKeyAESBlock, _ := aes.NewCipher(aeadResponseHeaderPayloadEncryptionKey)
199: 		aeadResponseHeaderPayloadEncryptionAEAD, _ := cipher.NewGCM(aeadResponseHeaderPayloadEncryptionKeyAESBlock)
200: 
201: 		encryptedResponseHeaderBuffer := make([]byte, decryptedResponseHeaderLength+16)
202: 		if _, err := io.ReadFull(vc.Conn, encryptedResponseHeaderBuffer); err != nil {
203: 			return err
204: 		}
205: 
206: 		buf, err = aeadResponseHeaderPayloadEncryptionAEAD.Open(nil, aeadResponseHeaderPayloadEncryptionIV, encryptedResponseHeaderBuffer, nil)
207: 		if err != nil {
208: 			return err
209: 		}
210: 
211: 		if len(buf) < 4 {
212: 			return errors.New("unexpected buffer length")
213: 		}
214: 	}
215: 
216: 	if buf[0] != vc.respV {
217: 		return errors.New("unexpected response header")
218: 	}
219: 
220: 	if buf[2] != 0 {
221: 		return errors.New("dynamic port is not supported now")
222: 	}
223: 
224: 	return nil
225: }
226: 
227: func hashTimestamp(t time.Time) []byte {
228: 	md5hash := md5.New()
229: 	ts := make([]byte, 8)
230: 	binary.BigEndian.PutUint64(ts, uint64(t.Unix()))
231: 	md5hash.Write(ts)
232: 	md5hash.Write(ts)
233: 	md5hash.Write(ts)
234: 	md5hash.Write(ts)
235: 	return md5hash.Sum(nil)
236: }
237: 
238: // newConn return a Conn instance
239: func newConn(conn net.Conn, id *ID, dst *DstAddr, security Security, isAead bool, isVless bool) (*Conn, error) {
240: 	var (
241: 		reqBodyKey  []byte
242: 		reqBodyIV   []byte
243: 		respBodyKey []byte
244: 		respBodyIV  []byte
245: 		respV       byte
246: 		option      byte
247: 	)
248: 
249: 	if !isVless {
250: 		randBytes := make([]byte, 33)
251: 		rand.Read(randBytes)
252: 		reqBodyIV = make([]byte, 16)
253: 		reqBodyKey = make([]byte, 16)
254: 		copy(reqBodyIV[:], randBytes[:16])
255: 		copy(reqBodyKey[:], randBytes[16:32])
256: 		respV = randBytes[32]
257: 		option = OptionChunkStream
258: 
259: 		if isAead {
260: 			bodyKey := sha256.Sum256(reqBodyKey)
261: 			bodyIV := sha256.Sum256(reqBodyIV)
262: 			respBodyKey = bodyKey[:16]
263: 			respBodyIV = bodyIV[:16]
264: 		} else {
265: 			bodyKey := md5.Sum(reqBodyKey)
266: 			bodyIV := md5.Sum(reqBodyIV)
267: 			respBodyKey = bodyKey[:]
268: 			respBodyIV = bodyIV[:]
269: 		}
270: 	}
271: 
272: 	var writer io.Writer
273: 	var reader io.Reader
274: 	switch security {
275: 	case SecurityZero:
276: 		security = SecurityNone
277: 		if !dst.UDP {
278: 			reader = conn
279: 			writer = conn
280: 			option = 0
281: 		} else {
282: 			reader = newChunkReader(conn)
283: 			writer = newChunkWriter(conn)
284: 		}
285: 	case SecurityNone:
286: 		reader = newChunkReader(conn)
287: 		writer = newChunkWriter(conn)
288: 	case SecurityAES128GCM:
289: 		block, _ := aes.NewCipher(reqBodyKey[:])
290: 		aead, _ := cipher.NewGCM(block)
291: 		writer = newAEADWriter(conn, aead, reqBodyIV[:])
292: 
293: 		block, _ = aes.NewCipher(respBodyKey[:])
294: 		aead, _ = cipher.NewGCM(block)
295: 		reader = newAEADReader(conn, aead, respBodyIV[:])
296: 	case SecurityCHACHA20POLY1305:
297: 		key := make([]byte, 32)
298: 		t := md5.Sum(reqBodyKey[:])
299: 		copy(key, t[:])
300: 		t = md5.Sum(key[:16])
301: 		copy(key[16:], t[:])
302: 		aead, _ := chacha20poly1305.New(key)
303: 		writer = newAEADWriter(conn, aead, reqBodyIV[:])
304: 
305: 		t = md5.Sum(respBodyKey[:])
306: 		copy(key, t[:])
307: 		t = md5.Sum(key[:16])
308: 		copy(key[16:], t[:])
309: 		aead, _ = chacha20poly1305.New(key)
310: 		reader = newAEADReader(conn, aead, respBodyIV[:])
311: 	}
312: 
313: 	c := &Conn{
314: 		Conn:        conn,
315: 		id:          id,
316: 		dst:         dst,
317: 		reqBodyIV:   reqBodyIV,
318: 		reqBodyKey:  reqBodyKey,
319: 		respV:       respV,
320: 		respBodyIV:  respBodyIV[:],
321: 		respBodyKey: respBodyKey[:],
322: 		reader:      reader,
323: 		writer:      writer,
324: 		security:    security,
325: 		option:      option,
326: 		isAead:      isAead,
327: 		isVless:     isVless,
328: 	}
329: 	if err := c.sendRequest(); err != nil {
330: 		return nil, err
331: 	}
332: 	return c, nil
333: }


./transport\vmess\h2.go
1: package vmess
2: 
3: import (
4: 	"io"
5: 	"math/rand"
6: 	"net"
7: 	"net/http"
8: 	"net/url"
9: 
10: 	"golang.org/x/net/http2"
11: )
12: 
13: type h2Conn struct {
14: 	net.Conn
15: 	*http2.ClientConn
16: 	pwriter *io.PipeWriter
17: 	res     *http.Response
18: 	cfg     *H2Config
19: }
20: 
21: type H2Config struct {
22: 	Hosts []string
23: 	Path  string
24: }
25: 
26: func (hc *h2Conn) establishConn() error {
27: 	preader, pwriter := io.Pipe()
28: 
29: 	host := hc.cfg.Hosts[rand.Intn(len(hc.cfg.Hosts))]
30: 	path := hc.cfg.Path
31: 	// TODO: connect use VMess Host instead of H2 Host
32: 	req := http.Request{
33: 		Method: http.MethodPut,
34: 		Host:   host,
35: 		URL: &url.URL{
36: 			Scheme: "https",
37: 			Host:   host,
38: 			Path:   path,
39: 		},
40: 		Proto:      "HTTP/2",
41: 		ProtoMajor: 2,
42: 		ProtoMinor: 0,
43: 		Body:       preader,
44: 		Header: map[string][]string{
45: 			"Accept-Encoding": {"identity"},
46: 		},
47: 	}
48: 
49: 	// it will be close at :  `func (hc *h2Conn) Close() error`
50: 	res, err := hc.ClientConn.RoundTrip(&req)
51: 	if err != nil {
52: 		return err
53: 	}
54: 
55: 	hc.pwriter = pwriter
56: 	hc.res = res
57: 
58: 	return nil
59: }
60: 
61: // Read implements net.Conn.Read()
62: func (hc *h2Conn) Read(b []byte) (int, error) {
63: 	if hc.res != nil && !hc.res.Close {
64: 		n, err := hc.res.Body.Read(b)
65: 		return n, err
66: 	}
67: 
68: 	if err := hc.establishConn(); err != nil {
69: 		return 0, err
70: 	}
71: 	return hc.res.Body.Read(b)
72: }
73: 
74: // Write implements io.Writer.
75: func (hc *h2Conn) Write(b []byte) (int, error) {
76: 	if hc.pwriter != nil {
77: 		return hc.pwriter.Write(b)
78: 	}
79: 
80: 	if err := hc.establishConn(); err != nil {
81: 		return 0, err
82: 	}
83: 	return hc.pwriter.Write(b)
84: }
85: 
86: func (hc *h2Conn) Close() error {
87: 	if err := hc.pwriter.Close(); err != nil {
88: 		return err
89: 	}
90: 	if err := hc.ClientConn.Shutdown(hc.res.Request.Context()); err != nil {
91: 		return err
92: 	}
93: 	return hc.Conn.Close()
94: }
95: 
96: func StreamH2Conn(conn net.Conn, cfg *H2Config) (net.Conn, error) {
97: 	transport := &http2.Transport{}
98: 
99: 	cconn, err := transport.NewClientConn(conn)
100: 	if err != nil {
101: 		return nil, err
102: 	}
103: 
104: 	return &h2Conn{
105: 		Conn:       conn,
106: 		ClientConn: cconn,
107: 		cfg:        cfg,
108: 	}, nil
109: }


./transport\vmess\header.go
1: package vmess
2: 
3: import (
4: 	"crypto/aes"
5: 	"crypto/cipher"
6: 	"crypto/hmac"
7: 	"crypto/rand"
8: 	"crypto/sha256"
9: 	"encoding/binary"
10: 	"hash"
11: 	"hash/crc32"
12: 	"time"
13: 
14: 	"github.com/Dreamacro/protobytes"
15: )
16: 
17: const (
18: 	kdfSaltConstAuthIDEncryptionKey             = "AES Auth ID Encryption"
19: 	kdfSaltConstAEADRespHeaderLenKey            = "AEAD Resp Header Len Key"
20: 	kdfSaltConstAEADRespHeaderLenIV             = "AEAD Resp Header Len IV"
21: 	kdfSaltConstAEADRespHeaderPayloadKey        = "AEAD Resp Header Key"
22: 	kdfSaltConstAEADRespHeaderPayloadIV         = "AEAD Resp Header IV"
23: 	kdfSaltConstVMessAEADKDF                    = "VMess AEAD KDF"
24: 	kdfSaltConstVMessHeaderPayloadAEADKey       = "VMess Header AEAD Key"
25: 	kdfSaltConstVMessHeaderPayloadAEADIV        = "VMess Header AEAD Nonce"
26: 	kdfSaltConstVMessHeaderPayloadLengthAEADKey = "VMess Header AEAD Key_Length"
27: 	kdfSaltConstVMessHeaderPayloadLengthAEADIV  = "VMess Header AEAD Nonce_Length"
28: )
29: 
30: func kdf(key []byte, path ...string) []byte {
31: 	hmacCreator := &hMacCreator{value: []byte(kdfSaltConstVMessAEADKDF)}
32: 	for _, v := range path {
33: 		hmacCreator = &hMacCreator{value: []byte(v), parent: hmacCreator}
34: 	}
35: 	hmacf := hmacCreator.Create()
36: 	hmacf.Write(key)
37: 	return hmacf.Sum(nil)
38: }
39: 
40: type hMacCreator struct {
41: 	parent *hMacCreator
42: 	value  []byte
43: }
44: 
45: func (h *hMacCreator) Create() hash.Hash {
46: 	if h.parent == nil {
47: 		return hmac.New(sha256.New, h.value)
48: 	}
49: 	return hmac.New(h.parent.Create, h.value)
50: }
51: 
52: func createAuthID(cmdKey []byte, time int64) [16]byte {
53: 	buf := protobytes.BytesWriter{}
54: 	buf.PutUint64be(uint64(time))
55: 	buf.ReadFull(rand.Reader, 4)
56: 	zero := crc32.ChecksumIEEE(buf.Bytes())
57: 	buf.PutUint32be(zero)
58: 
59: 	aesBlock, _ := aes.NewCipher(kdf(cmdKey[:], kdfSaltConstAuthIDEncryptionKey)[:16])
60: 	var result [16]byte
61: 	aesBlock.Encrypt(result[:], buf.Bytes())
62: 	return result
63: }
64: 
65: func sealVMessAEADHeader(key [16]byte, data []byte, t time.Time) []byte {
66: 	generatedAuthID := createAuthID(key[:], t.Unix())
67: 	connectionNonce := make([]byte, 8)
68: 	rand.Read(connectionNonce)
69: 
70: 	aeadPayloadLengthSerializedByte := make([]byte, 2)
71: 	binary.BigEndian.PutUint16(aeadPayloadLengthSerializedByte, uint16(len(data)))
72: 
73: 	var payloadHeaderLengthAEADEncrypted []byte
74: 
75: 	{
76: 		payloadHeaderLengthAEADKey := kdf(key[:], kdfSaltConstVMessHeaderPayloadLengthAEADKey, string(generatedAuthID[:]), string(connectionNonce))[:16]
77: 		payloadHeaderLengthAEADNonce := kdf(key[:], kdfSaltConstVMessHeaderPayloadLengthAEADIV, string(generatedAuthID[:]), string(connectionNonce))[:12]
78: 		payloadHeaderLengthAEADAESBlock, _ := aes.NewCipher(payloadHeaderLengthAEADKey)
79: 		payloadHeaderAEAD, _ := cipher.NewGCM(payloadHeaderLengthAEADAESBlock)
80: 		payloadHeaderLengthAEADEncrypted = payloadHeaderAEAD.Seal(nil, payloadHeaderLengthAEADNonce, aeadPayloadLengthSerializedByte, generatedAuthID[:])
81: 	}
82: 
83: 	var payloadHeaderAEADEncrypted []byte
84: 
85: 	{
86: 		payloadHeaderAEADKey := kdf(key[:], kdfSaltConstVMessHeaderPayloadAEADKey, string(generatedAuthID[:]), string(connectionNonce))[:16]
87: 		payloadHeaderAEADNonce := kdf(key[:], kdfSaltConstVMessHeaderPayloadAEADIV, string(generatedAuthID[:]), string(connectionNonce))[:12]
88: 		payloadHeaderAEADAESBlock, _ := aes.NewCipher(payloadHeaderAEADKey)
89: 		payloadHeaderAEAD, _ := cipher.NewGCM(payloadHeaderAEADAESBlock)
90: 		payloadHeaderAEADEncrypted = payloadHeaderAEAD.Seal(nil, payloadHeaderAEADNonce, data, generatedAuthID[:])
91: 	}
92: 
93: 	outputBuffer := protobytes.BytesWriter{}
94: 
95: 	outputBuffer.PutSlice(generatedAuthID[:])
96: 	outputBuffer.PutSlice(payloadHeaderLengthAEADEncrypted)
97: 	outputBuffer.PutSlice(connectionNonce)
98: 	outputBuffer.PutSlice(payloadHeaderAEADEncrypted)
99: 
100: 	return outputBuffer.Bytes()
101: }


./transport\vmess\http.go
1: package vmess
2: 
3: import (
4: 	"bufio"
5: 	"bytes"
6: 	"fmt"
7: 	"math/rand"
8: 	"net"
9: 	"net/http"
10: 	"net/textproto"
11: 
12: 	"github.com/Dreamacro/clash/common/util"
13: )
14: 
15: type httpConn struct {
16: 	net.Conn
17: 	cfg        *HTTPConfig
18: 	reader     *bufio.Reader
19: 	whandshake bool
20: }
21: 
22: type HTTPConfig struct {
23: 	Method  string
24: 	Host    string
25: 	Path    []string
26: 	Headers map[string][]string
27: }
28: 
29: // Read implements net.Conn.Read()
30: func (hc *httpConn) Read(b []byte) (int, error) {
31: 	if hc.reader != nil {
32: 		n, err := hc.reader.Read(b)
33: 		return n, err
34: 	}
35: 
36: 	reader := textproto.NewConn(hc.Conn)
37: 	// First line: GET /index.html HTTP/1.0
38: 	if _, err := reader.ReadLine(); err != nil {
39: 		return 0, err
40: 	}
41: 
42: 	if _, err := reader.ReadMIMEHeader(); err != nil {
43: 		return 0, err
44: 	}
45: 
46: 	hc.reader = reader.R
47: 	return reader.R.Read(b)
48: }
49: 
50: // Write implements io.Writer.
51: func (hc *httpConn) Write(b []byte) (int, error) {
52: 	if hc.whandshake {
53: 		return hc.Conn.Write(b)
54: 	}
55: 
56: 	path := hc.cfg.Path[rand.Intn(len(hc.cfg.Path))]
57: 	host := hc.cfg.Host
58: 	if header := hc.cfg.Headers["Host"]; len(header) != 0 {
59: 		host = header[rand.Intn(len(header))]
60: 	}
61: 
62: 	u := fmt.Sprintf("http://%s%s", host, path)
63: 	req, _ := http.NewRequest(util.EmptyOr(hc.cfg.Method, http.MethodGet), u, bytes.NewBuffer(b))
64: 	for key, list := range hc.cfg.Headers {
65: 		req.Header.Set(key, list[rand.Intn(len(list))])
66: 	}
67: 	req.ContentLength = int64(len(b))
68: 	if err := req.Write(hc.Conn); err != nil {
69: 		return 0, err
70: 	}
71: 	hc.whandshake = true
72: 	return len(b), nil
73: }
74: 
75: func (hc *httpConn) Close() error {
76: 	return hc.Conn.Close()
77: }
78: 
79: func StreamHTTPConn(conn net.Conn, cfg *HTTPConfig) net.Conn {
80: 	return &httpConn{
81: 		Conn: conn,
82: 		cfg:  cfg,
83: 	}
84: }


./transport\vmess\tls.go
1: package vmess
2: 
3: import (
4: 	"context"
5: 	"crypto/tls"
6: 	"net"
7: 
8: 	C "github.com/Dreamacro/clash/constant"
9: )
10: 
11: type TLSConfig struct {
12: 	Host           string
13: 	SkipCertVerify bool
14: 	NextProtos     []string
15: }
16: 
17: func StreamTLSConn(conn net.Conn, cfg *TLSConfig) (net.Conn, error) {
18: 	tlsConfig := &tls.Config{
19: 		ServerName:         cfg.Host,
20: 		InsecureSkipVerify: cfg.SkipCertVerify,
21: 		NextProtos:         cfg.NextProtos,
22: 	}
23: 
24: 	tlsConn := tls.Client(conn, tlsConfig)
25: 
26: 	// fix tls handshake not timeout
27: 	ctx, cancel := context.WithTimeout(context.Background(), C.DefaultTLSTimeout)
28: 	defer cancel()
29: 	err := tlsConn.HandshakeContext(ctx)
30: 	return tlsConn, err
31: }


./transport\vmess\user.go
1: package vmess
2: 
3: import (
4: 	"bytes"
5: 	"crypto/md5"
6: 
7: 	"github.com/gofrs/uuid/v5"
8: )
9: 
10: // ID cmdKey length
11: const (
12: 	IDBytesLen = 16
13: )
14: 
15: // The ID of en entity, in the form of a UUID.
16: type ID struct {
17: 	UUID   *uuid.UUID
18: 	CmdKey []byte
19: }
20: 
21: // newID returns an ID with given UUID.
22: func newID(uuid *uuid.UUID) *ID {
23: 	id := &ID{UUID: uuid, CmdKey: make([]byte, IDBytesLen)}
24: 	md5hash := md5.New()
25: 	md5hash.Write(uuid.Bytes())
26: 	md5hash.Write([]byte("c48619fe-8f02-49e0-b9e9-edf763e17e21"))
27: 	md5hash.Sum(id.CmdKey[:0])
28: 	return id
29: }
30: 
31: func nextID(u *uuid.UUID) *uuid.UUID {
32: 	md5hash := md5.New()
33: 	md5hash.Write(u.Bytes())
34: 	md5hash.Write([]byte("16167dc8-16b6-4e6d-b8bb-65dd68113a81"))
35: 	var newid uuid.UUID
36: 	for {
37: 		md5hash.Sum(newid[:0])
38: 		if !bytes.Equal(newid.Bytes(), u.Bytes()) {
39: 			return &newid
40: 		}
41: 		md5hash.Write([]byte("533eff8a-4113-4b10-b5ce-0f5d76b98cd2"))
42: 	}
43: }
44: 
45: func newAlterIDs(primary *ID, alterIDCount uint16) []*ID {
46: 	alterIDs := make([]*ID, alterIDCount)
47: 	prevID := primary.UUID
48: 	for idx := range alterIDs {
49: 		newid := nextID(prevID)
50: 		alterIDs[idx] = &ID{UUID: newid, CmdKey: primary.CmdKey[:]}
51: 		prevID = newid
52: 	}
53: 	alterIDs = append(alterIDs, primary)
54: 	return alterIDs
55: }


./transport\vmess\vmess.go
1: package vmess
2: 
3: import (
4: 	"fmt"
5: 	"math/rand"
6: 	"net"
7: 	"runtime"
8: 
9: 	"github.com/gofrs/uuid/v5"
10: )
11: 
12: // Version of vmess
13: const Version byte = 1
14: 
15: // Request Options
16: const (
17: 	OptionChunkStream  byte = 1
18: 	OptionChunkMasking byte = 4
19: )
20: 
21: // Security type vmess
22: type Security = byte
23: 
24: // Cipher types
25: const (
26: 	SecurityAES128GCM        Security = 3
27: 	SecurityCHACHA20POLY1305 Security = 4
28: 	SecurityNone             Security = 5
29: 	SecurityZero             Security = 6
30: )
31: 
32: // Command types
33: const (
34: 	CommandTCP byte = 1
35: 	CommandUDP byte = 2
36: )
37: 
38: // Addr types
39: const (
40: 	AtypIPv4       byte = 1
41: 	AtypDomainName byte = 2
42: 	AtypIPv6       byte = 3
43: )
44: 
45: // DstAddr store destination address
46: type DstAddr struct {
47: 	UDP      bool
48: 	AddrType byte
49: 	Addr     []byte
50: 	Port     uint
51: }
52: 
53: // Client is vmess connection generator
54: type Client struct {
55: 	user     []*ID
56: 	uuid     *uuid.UUID
57: 	security Security
58: 	isAead   bool
59: 	isVless  bool
60: }
61: 
62: // Config of vmess
63: type Config struct {
64: 	UUID     string
65: 	AlterID  uint16
66: 	Security string
67: 	Port     string
68: 	HostName string
69: 	IsAead   bool
70: 	IsVless  bool
71: }
72: 
73: // StreamConn return a Conn with net.Conn and DstAddr
74: func (c *Client) StreamConn(conn net.Conn, dst *DstAddr) (net.Conn, error) {
75: 	r := rand.Intn(len(c.user))
76: 	return newConn(conn, c.user[r], dst, c.security, c.isAead, c.isVless)
77: }
78: 
79: // NewClient return Client instance
80: func NewClient(config Config) (*Client, error) {
81: 	uid, err := uuid.FromString(config.UUID)
82: 	if err != nil {
83: 		return nil, err
84: 	}
85: 
86: 	if config.IsVless {
87: 		config.AlterID = 0
88: 		config.Security = "zero"
89: 	}
90: 
91: 	var security Security
92: 	switch config.Security {
93: 	case "aes-128-gcm":
94: 		security = SecurityAES128GCM
95: 	case "chacha20-poly1305":
96: 		security = SecurityCHACHA20POLY1305
97: 	case "none":
98: 		security = SecurityNone
99: 	case "zero":
100: 		security = SecurityZero
101: 	case "auto":
102: 		security = SecurityCHACHA20POLY1305
103: 		if runtime.GOARCH == "amd64" || runtime.GOARCH == "s390x" || runtime.GOARCH == "arm64" {
104: 			security = SecurityAES128GCM
105: 		}
106: 	default:
107: 		return nil, fmt.Errorf("unknown security type: %s", config.Security)
108: 	}
109: 
110: 	return &Client{
111: 		user:     newAlterIDs(newID(&uid), config.AlterID),
112: 		uuid:     &uid,
113: 		security: security,
114: 		isAead:   config.IsAead,
115: 		isVless:  config.IsVless,
116: 	}, nil
117: }


./transport\vmess\websocket.go
1: package vmess
2: 
3: import (
4: 	"bytes"
5: 	"context"
6: 	"crypto/tls"
7: 	"encoding/base64"
8: 	"errors"
9: 	"fmt"
10: 	"io"
11: 	"net"
12: 	"net/http"
13: 	"net/url"
14: 	"strconv"
15: 	"strings"
16: 	"sync"
17: 	"time"
18: 
19: 	"github.com/gorilla/websocket"
20: )
21: 
22: type websocketConn struct {
23: 	conn       *websocket.Conn
24: 	reader     io.Reader
25: 	remoteAddr net.Addr
26: 
27: 	// https://godoc.org/github.com/gorilla/websocket#hdr-Concurrency
28: 	rMux sync.Mutex
29: 	wMux sync.Mutex
30: }
31: 
32: type websocketWithEarlyDataConn struct {
33: 	net.Conn
34: 	underlay net.Conn
35: 	closed   bool
36: 	dialed   chan bool
37: 	cancel   context.CancelFunc
38: 	ctx      context.Context
39: 	config   *WebsocketConfig
40: }
41: 
42: type WebsocketConfig struct {
43: 	Host                string
44: 	Port                string
45: 	Path                string
46: 	Headers             http.Header
47: 	TLS                 bool
48: 	TLSConfig           *tls.Config
49: 	MaxEarlyData        int
50: 	EarlyDataHeaderName string
51: }
52: 
53: // Read implements net.Conn.Read()
54: func (wsc *websocketConn) Read(b []byte) (int, error) {
55: 	wsc.rMux.Lock()
56: 	defer wsc.rMux.Unlock()
57: 	for {
58: 		reader, err := wsc.getReader()
59: 		if err != nil {
60: 			return 0, err
61: 		}
62: 
63: 		nBytes, err := reader.Read(b)
64: 		if err == io.EOF {
65: 			wsc.reader = nil
66: 			continue
67: 		}
68: 		return nBytes, err
69: 	}
70: }
71: 
72: // Write implements io.Writer.
73: func (wsc *websocketConn) Write(b []byte) (int, error) {
74: 	wsc.wMux.Lock()
75: 	defer wsc.wMux.Unlock()
76: 	if err := wsc.conn.WriteMessage(websocket.BinaryMessage, b); err != nil {
77: 		return 0, err
78: 	}
79: 	return len(b), nil
80: }
81: 
82: func (wsc *websocketConn) Close() error {
83: 	var errors []string
84: 	if err := wsc.conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""), time.Now().Add(time.Second*5)); err != nil {
85: 		errors = append(errors, err.Error())
86: 	}
87: 	if err := wsc.conn.Close(); err != nil {
88: 		errors = append(errors, err.Error())
89: 	}
90: 	if len(errors) > 0 {
91: 		return fmt.Errorf("failed to close connection: %s", strings.Join(errors, ","))
92: 	}
93: 	return nil
94: }
95: 
96: func (wsc *websocketConn) getReader() (io.Reader, error) {
97: 	if wsc.reader != nil {
98: 		return wsc.reader, nil
99: 	}
100: 
101: 	_, reader, err := wsc.conn.NextReader()
102: 	if err != nil {
103: 		return nil, err
104: 	}
105: 	wsc.reader = reader
106: 	return reader, nil
107: }
108: 
109: func (wsc *websocketConn) LocalAddr() net.Addr {
110: 	return wsc.conn.LocalAddr()
111: }
112: 
113: func (wsc *websocketConn) RemoteAddr() net.Addr {
114: 	return wsc.remoteAddr
115: }
116: 
117: func (wsc *websocketConn) SetDeadline(t time.Time) error {
118: 	if err := wsc.SetReadDeadline(t); err != nil {
119: 		return err
120: 	}
121: 	return wsc.SetWriteDeadline(t)
122: }
123: 
124: func (wsc *websocketConn) SetReadDeadline(t time.Time) error {
125: 	return wsc.conn.SetReadDeadline(t)
126: }
127: 
128: func (wsc *websocketConn) SetWriteDeadline(t time.Time) error {
129: 	return wsc.conn.SetWriteDeadline(t)
130: }
131: 
132: func (wsedc *websocketWithEarlyDataConn) Dial(earlyData []byte) error {
133: 	base64DataBuf := &bytes.Buffer{}
134: 	base64EarlyDataEncoder := base64.NewEncoder(base64.RawURLEncoding, base64DataBuf)
135: 
136: 	earlyDataBuf := bytes.NewBuffer(earlyData)
137: 	if _, err := base64EarlyDataEncoder.Write(earlyDataBuf.Next(wsedc.config.MaxEarlyData)); err != nil {
138: 		return errors.New("failed to encode early data: " + err.Error())
139: 	}
140: 
141: 	if errc := base64EarlyDataEncoder.Close(); errc != nil {
142: 		return errors.New("failed to encode early data tail: " + errc.Error())
143: 	}
144: 
145: 	var err error
146: 	if wsedc.Conn, err = streamWebsocketConn(wsedc.underlay, wsedc.config, base64DataBuf); err != nil {
147: 		wsedc.Close()
148: 		return errors.New("failed to dial WebSocket: " + err.Error())
149: 	}
150: 
151: 	wsedc.dialed <- true
152: 	if earlyDataBuf.Len() != 0 {
153: 		_, err = wsedc.Conn.Write(earlyDataBuf.Bytes())
154: 	}
155: 
156: 	return err
157: }
158: 
159: func (wsedc *websocketWithEarlyDataConn) Write(b []byte) (int, error) {
160: 	if wsedc.closed {
161: 		return 0, io.ErrClosedPipe
162: 	}
163: 	if wsedc.Conn == nil {
164: 		if err := wsedc.Dial(b); err != nil {
165: 			return 0, err
166: 		}
167: 		return len(b), nil
168: 	}
169: 
170: 	return wsedc.Conn.Write(b)
171: }
172: 
173: func (wsedc *websocketWithEarlyDataConn) Read(b []byte) (int, error) {
174: 	if wsedc.closed {
175: 		return 0, io.ErrClosedPipe
176: 	}
177: 	if wsedc.Conn == nil {
178: 		select {
179: 		case <-wsedc.ctx.Done():
180: 			return 0, io.ErrUnexpectedEOF
181: 		case <-wsedc.dialed:
182: 		}
183: 	}
184: 	return wsedc.Conn.Read(b)
185: }
186: 
187: func (wsedc *websocketWithEarlyDataConn) Close() error {
188: 	wsedc.closed = true
189: 	wsedc.cancel()
190: 	if wsedc.Conn == nil {
191: 		return nil
192: 	}
193: 	return wsedc.Conn.Close()
194: }
195: 
196: func (wsedc *websocketWithEarlyDataConn) LocalAddr() net.Addr {
197: 	if wsedc.Conn == nil {
198: 		return wsedc.underlay.LocalAddr()
199: 	}
200: 	return wsedc.Conn.LocalAddr()
201: }
202: 
203: func (wsedc *websocketWithEarlyDataConn) RemoteAddr() net.Addr {
204: 	if wsedc.Conn == nil {
205: 		return wsedc.underlay.RemoteAddr()
206: 	}
207: 	return wsedc.Conn.RemoteAddr()
208: }
209: 
210: func (wsedc *websocketWithEarlyDataConn) SetDeadline(t time.Time) error {
211: 	if err := wsedc.SetReadDeadline(t); err != nil {
212: 		return err
213: 	}
214: 	return wsedc.SetWriteDeadline(t)
215: }
216: 
217: func (wsedc *websocketWithEarlyDataConn) SetReadDeadline(t time.Time) error {
218: 	if wsedc.Conn == nil {
219: 		return nil
220: 	}
221: 	return wsedc.Conn.SetReadDeadline(t)
222: }
223: 
224: func (wsedc *websocketWithEarlyDataConn) SetWriteDeadline(t time.Time) error {
225: 	if wsedc.Conn == nil {
226: 		return nil
227: 	}
228: 	return wsedc.Conn.SetWriteDeadline(t)
229: }
230: 
231: func streamWebsocketWithEarlyDataConn(conn net.Conn, c *WebsocketConfig) (net.Conn, error) {
232: 	ctx, cancel := context.WithCancel(context.Background())
233: 	conn = &websocketWithEarlyDataConn{
234: 		dialed:   make(chan bool, 1),
235: 		cancel:   cancel,
236: 		ctx:      ctx,
237: 		underlay: conn,
238: 		config:   c,
239: 	}
240: 	return conn, nil
241: }
242: 
243: func streamWebsocketConn(conn net.Conn, c *WebsocketConfig, earlyData *bytes.Buffer) (net.Conn, error) {
244: 	dialer := &websocket.Dialer{
245: 		NetDial: func(network, addr string) (net.Conn, error) {
246: 			return conn, nil
247: 		},
248: 		ReadBufferSize:   4 * 1024,
249: 		WriteBufferSize:  4 * 1024,
250: 		HandshakeTimeout: time.Second * 8,
251: 	}
252: 
253: 	scheme := "ws"
254: 	if c.TLS {
255: 		scheme = "wss"
256: 		dialer.TLSClientConfig = c.TLSConfig
257: 	}
258: 
259: 	u, err := url.Parse(c.Path)
260: 	if err != nil {
261: 		return nil, fmt.Errorf("parse url %s error: %w", c.Path, err)
262: 	}
263: 
264: 	uri := url.URL{
265: 		Scheme:   scheme,
266: 		Host:     net.JoinHostPort(c.Host, c.Port),
267: 		Path:     u.Path,
268: 		RawQuery: u.RawQuery,
269: 	}
270: 
271: 	headers := http.Header{}
272: 	if c.Headers != nil {
273: 		for k := range c.Headers {
274: 			headers.Add(k, c.Headers.Get(k))
275: 		}
276: 	}
277: 
278: 	if earlyData != nil {
279: 		if c.EarlyDataHeaderName == "" {
280: 			uri.Path += earlyData.String()
281: 		} else {
282: 			headers.Set(c.EarlyDataHeaderName, earlyData.String())
283: 		}
284: 	}
285: 
286: 	wsConn, resp, err := dialer.Dial(uri.String(), headers)
287: 	if err != nil {
288: 		reason := err.Error()
289: 		if resp != nil {
290: 			reason = resp.Status
291: 		}
292: 		return nil, fmt.Errorf("dial %s error: %s", uri.Host, reason)
293: 	}
294: 
295: 	return &websocketConn{
296: 		conn:       wsConn,
297: 		remoteAddr: conn.RemoteAddr(),
298: 	}, nil
299: }
300: 
301: func StreamWebsocketConn(conn net.Conn, c *WebsocketConfig) (net.Conn, error) {
302: 	if u, err := url.Parse(c.Path); err == nil {
303: 		if q := u.Query(); q.Get("ed") != "" {
304: 			if ed, err := strconv.Atoi(q.Get("ed")); err == nil {
305: 				c.MaxEarlyData = ed
306: 				c.EarlyDataHeaderName = "Sec-WebSocket-Protocol"
307: 				q.Del("ed")
308: 				u.RawQuery = q.Encode()
309: 				c.Path = u.String()
310: 			}
311: 		}
312: 	}
313: 
314: 	if c.MaxEarlyData > 0 {
315: 		return streamWebsocketWithEarlyDataConn(conn, c)
316: 	}
317: 
318: 	return streamWebsocketConn(conn, c, nil)
319: }


./tunnel\connection.go
1: package tunnel
2: 
3: import (
4: 	"errors"
5: 	"net"
6: 	"net/netip"
7: 	"time"
8: 
9: 	N "github.com/Dreamacro/clash/common/net"
10: 	"github.com/Dreamacro/clash/common/pool"
11: 	C "github.com/Dreamacro/clash/constant"
12: )
13: 
14: func handleUDPToRemote(packet C.UDPPacket, pc C.PacketConn, metadata *C.Metadata) error {
15: 	addr := metadata.UDPAddr()
16: 	if addr == nil {
17: 		return errors.New("udp addr invalid")
18: 	}
19: 
20: 	if _, err := pc.WriteTo(packet.Data(), addr); err != nil {
21: 		return err
22: 	}
23: 	// reset timeout
24: 	pc.SetReadDeadline(time.Now().Add(udpTimeout))
25: 
26: 	return nil
27: }
28: 
29: func handleUDPToLocal(packet C.UDPPacket, pc net.PacketConn, key string, oAddr, fAddr netip.Addr) {
30: 	buf := pool.Get(pool.UDPBufferSize)
31: 	defer pool.Put(buf)
32: 	defer natTable.Delete(key)
33: 	defer pc.Close()
34: 
35: 	for {
36: 		pc.SetReadDeadline(time.Now().Add(udpTimeout))
37: 		n, from, err := pc.ReadFrom(buf)
38: 		if err != nil {
39: 			return
40: 		}
41: 
42: 		fromUDPAddr := *from.(*net.UDPAddr)
43: 		if fAddr.IsValid() {
44: 			fromAddr, _ := netip.AddrFromSlice(fromUDPAddr.IP)
45: 			fromAddr = fromAddr.Unmap()
46: 			if oAddr == fromAddr {
47: 				fromUDPAddr.IP = fAddr.AsSlice()
48: 			}
49: 		}
50: 
51: 		_, err = packet.WriteBack(buf[:n], &fromUDPAddr)
52: 		if err != nil {
53: 			return
54: 		}
55: 	}
56: }
57: 
58: func handleSocket(ctx C.ConnContext, outbound net.Conn) {
59: 	N.Relay(ctx.Conn(), outbound)
60: }


./tunnel\mode.go
1: package tunnel
2: 
3: import (
4: 	"encoding/json"
5: 	"errors"
6: 	"strings"
7: )
8: 
9: type TunnelMode int
10: 
11: // ModeMapping is a mapping for Mode enum
12: var ModeMapping = map[string]TunnelMode{
13: 	Global.String(): Global,
14: 	Rule.String():   Rule,
15: 	Direct.String(): Direct,
16: }
17: 
18: const (
19: 	Global TunnelMode = iota
20: 	Rule
21: 	Direct
22: )
23: 
24: // UnmarshalJSON unserialize Mode
25: func (m *TunnelMode) UnmarshalJSON(data []byte) error {
26: 	var tp string
27: 	json.Unmarshal(data, &tp)
28: 	mode, exist := ModeMapping[strings.ToLower(tp)]
29: 	if !exist {
30: 		return errors.New("invalid mode")
31: 	}
32: 	*m = mode
33: 	return nil
34: }
35: 
36: // UnmarshalYAML unserialize Mode with yaml
37: func (m *TunnelMode) UnmarshalYAML(unmarshal func(any) error) error {
38: 	var tp string
39: 	unmarshal(&tp)
40: 	mode, exist := ModeMapping[strings.ToLower(tp)]
41: 	if !exist {
42: 		return errors.New("invalid mode")
43: 	}
44: 	*m = mode
45: 	return nil
46: }
47: 
48: // MarshalJSON serialize Mode
49: func (m TunnelMode) MarshalJSON() ([]byte, error) {
50: 	return json.Marshal(m.String())
51: }
52: 
53: // MarshalYAML serialize TunnelMode with yaml
54: func (m TunnelMode) MarshalYAML() (any, error) {
55: 	return m.String(), nil
56: }
57: 
58: func (m TunnelMode) String() string {
59: 	switch m {
60: 	case Global:
61: 		return "global"
62: 	case Rule:
63: 		return "rule"
64: 	case Direct:
65: 		return "direct"
66: 	default:
67: 		return "Unknown"
68: 	}
69: }


./tunnel\tunnel.go
1: package tunnel
2: 
3: import (
4: 	"context"
5: 	"fmt"
6: 	"net"
7: 	"net/netip"
8: 	"runtime"
9: 	"sync"
10: 	"time"
11: 
12: 	"github.com/Dreamacro/clash/adapter/inbound"
13: 	"github.com/Dreamacro/clash/component/nat"
14: 	P "github.com/Dreamacro/clash/component/process"
15: 	"github.com/Dreamacro/clash/component/resolver"
16: 	C "github.com/Dreamacro/clash/constant"
17: 	"github.com/Dreamacro/clash/constant/provider"
18: 	icontext "github.com/Dreamacro/clash/context"
19: 	"github.com/Dreamacro/clash/log"
20: 	"github.com/Dreamacro/clash/tunnel/statistic"
21: 
22: 	"go.uber.org/atomic"
23: )
24: 
25: var (
26: 	tcpQueue  = make(chan C.ConnContext, 200)
27: 	udpQueue  = make(chan *inbound.PacketAdapter, 200)
28: 	natTable  = nat.New()
29: 	rules     []C.Rule
30: 	proxies   = make(map[string]C.Proxy)
31: 	providers map[string]provider.ProxyProvider
32: 	configMux sync.RWMutex
33: 
34: 	// Outbound Rule
35: 	mode = Rule
36: 
37: 	// default timeout for UDP session
38: 	udpTimeout = 60 * time.Second
39: 
40: 	// experimental feature
41: 	UDPFallbackMatch = atomic.NewBool(false)
42: )
43: 
44: func init() {
45: 	go process()
46: }
47: 
48: // TCPIn return fan-in queue
49: func TCPIn() chan<- C.ConnContext {
50: 	return tcpQueue
51: }
52: 
53: // UDPIn return fan-in udp queue
54: func UDPIn() chan<- *inbound.PacketAdapter {
55: 	return udpQueue
56: }
57: 
58: // Rules return all rules
59: func Rules() []C.Rule {
60: 	return rules
61: }
62: 
63: // UpdateRules handle update rules
64: func UpdateRules(newRules []C.Rule) {
65: 	configMux.Lock()
66: 	rules = newRules
67: 	configMux.Unlock()
68: }
69: 
70: // Proxies return all proxies
71: func Proxies() map[string]C.Proxy {
72: 	return proxies
73: }
74: 
75: // Providers return all compatible providers
76: func Providers() map[string]provider.ProxyProvider {
77: 	return providers
78: }
79: 
80: // UpdateProxies handle update proxies
81: func UpdateProxies(newProxies map[string]C.Proxy, newProviders map[string]provider.ProxyProvider) {
82: 	configMux.Lock()
83: 	proxies = newProxies
84: 	providers = newProviders
85: 	configMux.Unlock()
86: }
87: 
88: // Mode return current mode
89: func Mode() TunnelMode {
90: 	return mode
91: }
92: 
93: // SetMode change the mode of tunnel
94: func SetMode(m TunnelMode) {
95: 	mode = m
96: }
97: 
98: // processUDP starts a loop to handle udp packet
99: func processUDP() {
100: 	queue := udpQueue
101: 	for conn := range queue {
102: 		handleUDPConn(conn)
103: 	}
104: }
105: 
106: func process() {
107: 	numUDPWorkers := 4
108: 	if num := runtime.GOMAXPROCS(0); num > numUDPWorkers {
109: 		numUDPWorkers = num
110: 	}
111: 	for i := 0; i < numUDPWorkers; i++ {
112: 		go processUDP()
113: 	}
114: 
115: 	queue := tcpQueue
116: 	for conn := range queue {
117: 		go handleTCPConn(conn)
118: 	}
119: }
120: 
121: func needLookupIP(metadata *C.Metadata) bool {
122: 	return resolver.MappingEnabled() && metadata.Host == "" && metadata.DstIP != nil
123: }
124: 
125: func preHandleMetadata(metadata *C.Metadata) error {
126: 	// handle IP string on host
127: 	if ip := net.ParseIP(metadata.Host); ip != nil {
128: 		metadata.DstIP = ip
129: 		metadata.Host = ""
130: 	}
131: 
132: 	// preprocess enhanced-mode metadata
133: 	if needLookupIP(metadata) {
134: 		host, exist := resolver.FindHostByIP(metadata.DstIP)
135: 		if exist {
136: 			metadata.Host = host
137: 			metadata.DNSMode = C.DNSMapping
138: 			if resolver.FakeIPEnabled() {
139: 				metadata.DstIP = nil
140: 				metadata.DNSMode = C.DNSFakeIP
141: 			} else if node := resolver.DefaultHosts.Search(host); node != nil {
142: 				// redir-host should lookup the hosts
143: 				metadata.DstIP = node.Data.(net.IP)
144: 			}
145: 		} else if resolver.IsFakeIP(metadata.DstIP) {
146: 			return fmt.Errorf("fake DNS record %s missing", metadata.DstIP)
147: 		}
148: 	}
149: 
150: 	return nil
151: }
152: 
153: func resolveMetadata(ctx C.PlainContext, metadata *C.Metadata) (proxy C.Proxy, rule C.Rule, err error) {
154: 	if metadata.SpecialProxy != "" {
155: 		var exist bool
156: 		proxy, exist = proxies[metadata.SpecialProxy]
157: 		if !exist {
158: 			err = fmt.Errorf("proxy %s not found", metadata.SpecialProxy)
159: 		}
160: 		return
161: 	}
162: 
163: 	switch mode {
164: 	case Direct:
165: 		proxy = proxies["DIRECT"]
166: 	case Global:
167: 		proxy = proxies["GLOBAL"]
168: 	case Rule:
169: 		proxy, rule, err = match(metadata)
170: 	default:
171: 		panic(fmt.Sprintf("unknown mode: %s", mode))
172: 	}
173: 
174: 	return
175: }
176: 
177: func handleUDPConn(packet *inbound.PacketAdapter) {
178: 	metadata := packet.Metadata()
179: 	if !metadata.Valid() {
180: 		packet.Drop()
181: 		log.Warnln("[Metadata] not valid: %#v", metadata)
182: 		return
183: 	}
184: 
185: 	// make a fAddr if request ip is fakeip
186: 	var fAddr netip.Addr
187: 	if resolver.IsExistFakeIP(metadata.DstIP) {
188: 		fAddr, _ = netip.AddrFromSlice(metadata.DstIP)
189: 		fAddr = fAddr.Unmap()
190: 	}
191: 
192: 	if err := preHandleMetadata(metadata); err != nil {
193: 		packet.Drop()
194: 		log.Debugln("[Metadata PreHandle] error: %s", err)
195: 		return
196: 	}
197: 
198: 	// local resolve UDP dns
199: 	if !metadata.Resolved() {
200: 		ips, err := resolver.LookupIP(context.Background(), metadata.Host)
201: 		if err != nil {
202: 			packet.Drop()
203: 			return
204: 		} else if len(ips) == 0 {
205: 			packet.Drop()
206: 			return
207: 		}
208: 		metadata.DstIP = ips[0]
209: 	}
210: 
211: 	key := packet.LocalAddr().String()
212: 
213: 	handle := func() bool {
214: 		pc := natTable.Get(key)
215: 		if pc != nil {
216: 			handleUDPToRemote(packet, pc, metadata)
217: 			return true
218: 		}
219: 		return false
220: 	}
221: 
222: 	if handle() {
223: 		packet.Drop()
224: 		return
225: 	}
226: 
227: 	lockKey := key + "-lock"
228: 	cond, loaded := natTable.GetOrCreateLock(lockKey)
229: 
230: 	go func() {
231: 		defer packet.Drop()
232: 
233: 		if loaded {
234: 			cond.L.Lock()
235: 			cond.Wait()
236: 			handle()
237: 			cond.L.Unlock()
238: 			return
239: 		}
240: 
241: 		defer func() {
242: 			natTable.Delete(lockKey)
243: 			cond.Broadcast()
244: 		}()
245: 
246: 		pCtx := icontext.NewPacketConnContext(metadata)
247: 		proxy, rule, err := resolveMetadata(pCtx, metadata)
248: 		if err != nil {
249: 			log.Warnln("[UDP] Parse metadata failed: %s", err.Error())
250: 			return
251: 		}
252: 
253: 		ctx, cancel := context.WithTimeout(context.Background(), C.DefaultUDPTimeout)
254: 		defer cancel()
255: 		rawPc, err := proxy.ListenPacketContext(ctx, metadata.Pure())
256: 		if err != nil {
257: 			if rule == nil {
258: 				log.Warnln(
259: 					"[UDP] dial %s %s --> %s error: %s",
260: 					proxy.Name(),
261: 					metadata.SourceAddress(),
262: 					metadata.RemoteAddress(),
263: 					err.Error(),
264: 				)
265: 			} else {
266: 				log.Warnln("[UDP] dial %s (match %s/%s) %s --> %s error: %s", proxy.Name(), rule.RuleType().String(), rule.Payload(), metadata.SourceAddress(), metadata.RemoteAddress(), err.Error())
267: 			}
268: 			return
269: 		}
270: 		pCtx.InjectPacketConn(rawPc)
271: 		pc := statistic.NewUDPTracker(rawPc, statistic.DefaultManager, metadata, rule)
272: 
273: 		switch true {
274: 		case metadata.SpecialProxy != "":
275: 			log.Infoln("[UDP] %s --> %s using %s", metadata.SourceAddress(), metadata.RemoteAddress(), metadata.SpecialProxy)
276: 		case rule != nil:
277: 			log.Infoln(
278: 				"[UDP] %s --> %s match %s(%s) using %s",
279: 				metadata.SourceAddress(),
280: 				metadata.RemoteAddress(),
281: 				rule.RuleType().String(),
282: 				rule.Payload(),
283: 				rawPc.Chains().String(),
284: 			)
285: 		case mode == Global:
286: 			log.Infoln("[UDP] %s --> %s using GLOBAL", metadata.SourceAddress(), metadata.RemoteAddress())
287: 		case mode == Direct:
288: 			log.Infoln("[UDP] %s --> %s using DIRECT", metadata.SourceAddress(), metadata.RemoteAddress())
289: 		default:
290: 			log.Infoln(
291: 				"[UDP] %s --> %s doesn't match any rule using DIRECT",
292: 				metadata.SourceAddress(),
293: 				metadata.RemoteAddress(),
294: 			)
295: 		}
296: 
297: 		oAddr, _ := netip.AddrFromSlice(metadata.DstIP)
298: 		oAddr = oAddr.Unmap()
299: 		go handleUDPToLocal(packet.UDPPacket, pc, key, oAddr, fAddr)
300: 
301: 		natTable.Set(key, pc)
302: 		handle()
303: 	}()
304: }
305: 
306: func handleTCPConn(connCtx C.ConnContext) {
307: 	defer connCtx.Conn().Close()
308: 
309: 	metadata := connCtx.Metadata()
310: 	if !metadata.Valid() {
311: 		log.Warnln("[Metadata] not valid: %#v", metadata)
312: 		return
313: 	}
314: 
315: 	if err := preHandleMetadata(metadata); err != nil {
316: 		log.Debugln("[Metadata PreHandle] error: %s", err)
317: 		return
318: 	}
319: 
320: 	proxy, rule, err := resolveMetadata(connCtx, metadata)
321: 	if err != nil {
322: 		log.Warnln("[Metadata] parse failed: %s", err.Error())
323: 		return
324: 	}
325: 
326: 	ctx, cancel := context.WithTimeout(context.Background(), C.DefaultTCPTimeout)
327: 	defer cancel()
328: 	remoteConn, err := proxy.DialContext(ctx, metadata.Pure())
329: 	if err != nil {
330: 		if rule == nil {
331: 			log.Warnln(
332: 				"[TCP] dial %s %s --> %s error: %s",
333: 				proxy.Name(),
334: 				metadata.SourceAddress(),
335: 				metadata.RemoteAddress(),
336: 				err.Error(),
337: 			)
338: 		} else {
339: 			log.Warnln("[TCP] dial %s (match %s/%s) %s --> %s error: %s", proxy.Name(), rule.RuleType().String(), rule.Payload(), metadata.SourceAddress(), metadata.RemoteAddress(), err.Error())
340: 		}
341: 		return
342: 	}
343: 	remoteConn = statistic.NewTCPTracker(remoteConn, statistic.DefaultManager, metadata, rule)
344: 	defer remoteConn.Close()
345: 
346: 	switch true {
347: 	case metadata.SpecialProxy != "":
348: 		log.Infoln("[TCP] %s --> %s using %s", metadata.SourceAddress(), metadata.RemoteAddress(), metadata.SpecialProxy)
349: 	case rule != nil:
350: 		log.Infoln(
351: 			"[TCP] %s --> %s match %s(%s) using %s",
352: 			metadata.SourceAddress(),
353: 			metadata.RemoteAddress(),
354: 			rule.RuleType().String(),
355: 			rule.Payload(),
356: 			remoteConn.Chains().String(),
357: 		)
358: 	case mode == Global:
359: 		log.Infoln("[TCP] %s --> %s using GLOBAL", metadata.SourceAddress(), metadata.RemoteAddress())
360: 	case mode == Direct:
361: 		log.Infoln("[TCP] %s --> %s using DIRECT", metadata.SourceAddress(), metadata.RemoteAddress())
362: 	default:
363: 		log.Infoln(
364: 			"[TCP] %s --> %s doesn't match any rule using DIRECT",
365: 			metadata.SourceAddress(),
366: 			metadata.RemoteAddress(),
367: 		)
368: 	}
369: 
370: 	handleSocket(connCtx, remoteConn)
371: }
372: 
373: func shouldResolveIP(rule C.Rule, metadata *C.Metadata) bool {
374: 	return rule.ShouldResolveIP() && metadata.Host != "" && metadata.DstIP == nil
375: }
376: 
377: func match(metadata *C.Metadata) (C.Proxy, C.Rule, error) {
378: 	configMux.RLock()
379: 	defer configMux.RUnlock()
380: 
381: 	var resolved bool
382: 	var processFound bool
383: 
384: 	if node := resolver.DefaultHosts.Search(metadata.Host); node != nil {
385: 		ip := node.Data.(net.IP)
386: 		metadata.DstIP = ip
387: 		resolved = true
388: 	}
389: 
390: 	for _, rule := range rules {
391: 		if !resolved && shouldResolveIP(rule, metadata) {
392: 			ip, err := resolver.ResolveIP(metadata.Host)
393: 			if err != nil {
394: 				log.Debugln("[DNS] resolve %s error: %s", metadata.Host, err.Error())
395: 			} else {
396: 				log.Debugln("[DNS] %s --> %s", metadata.Host, ip.String())
397: 				metadata.DstIP = ip
398: 			}
399: 			resolved = true
400: 		}
401: 
402: 		if !processFound && rule.ShouldFindProcess() {
403: 			processFound = true
404: 
405: 			srcIP, ok := netip.AddrFromSlice(metadata.SrcIP)
406: 			if ok && metadata.OriginDst.IsValid() {
407: 				srcIP = srcIP.Unmap()
408: 				path, err := P.FindProcessPath(metadata.NetWork.String(), netip.AddrPortFrom(srcIP, uint16(metadata.SrcPort)), metadata.OriginDst)
409: 				if err != nil {
410: 					log.Debugln("[Process] find process %s: %v", metadata.String(), err)
411: 				} else {
412: 					log.Debugln("[Process] %s from process %s", metadata.String(), path)
413: 					metadata.ProcessPath = path
414: 				}
415: 			}
416: 		}
417: 
418: 		if rule.Match(metadata) {
419: 			adapter, ok := proxies[rule.Adapter()]
420: 			if !ok {
421: 				continue
422: 			}
423: 
424: 			if metadata.NetWork == C.UDP && !adapter.SupportUDP() && UDPFallbackMatch.Load() {
425: 				log.Debugln("[Matcher] %s UDP is not supported, skip match", adapter.Name())
426: 				continue
427: 			}
428: 			return adapter, rule, nil
429: 		}
430: 	}
431: 
432: 	return proxies["DIRECT"], nil, nil
433: }


./tunnel\statistic\manager.go
1: package statistic
2: 
3: import (
4: 	"sync"
5: 	"time"
6: 
7: 	"go.uber.org/atomic"
8: )
9: 
10: var DefaultManager *Manager
11: 
12: func init() {
13: 	DefaultManager = &Manager{
14: 		uploadTemp:    atomic.NewInt64(0),
15: 		downloadTemp:  atomic.NewInt64(0),
16: 		uploadBlip:    atomic.NewInt64(0),
17: 		downloadBlip:  atomic.NewInt64(0),
18: 		uploadTotal:   atomic.NewInt64(0),
19: 		downloadTotal: atomic.NewInt64(0),
20: 	}
21: 
22: 	go DefaultManager.handle()
23: }
24: 
25: type Manager struct {
26: 	connections   sync.Map
27: 	uploadTemp    *atomic.Int64
28: 	downloadTemp  *atomic.Int64
29: 	uploadBlip    *atomic.Int64
30: 	downloadBlip  *atomic.Int64
31: 	uploadTotal   *atomic.Int64
32: 	downloadTotal *atomic.Int64
33: }
34: 
35: func (m *Manager) Join(c tracker) {
36: 	m.connections.Store(c.ID(), c)
37: }
38: 
39: func (m *Manager) Leave(c tracker) {
40: 	m.connections.Delete(c.ID())
41: }
42: 
43: func (m *Manager) PushUploaded(size int64) {
44: 	m.uploadTemp.Add(size)
45: 	m.uploadTotal.Add(size)
46: }
47: 
48: func (m *Manager) PushDownloaded(size int64) {
49: 	m.downloadTemp.Add(size)
50: 	m.downloadTotal.Add(size)
51: }
52: 
53: func (m *Manager) Now() (up int64, down int64) {
54: 	return m.uploadBlip.Load(), m.downloadBlip.Load()
55: }
56: 
57: func (m *Manager) Snapshot() *Snapshot {
58: 	connections := []tracker{}
59: 	m.connections.Range(func(key, value any) bool {
60: 		connections = append(connections, value.(tracker))
61: 		return true
62: 	})
63: 
64: 	return &Snapshot{
65: 		UploadTotal:   m.uploadTotal.Load(),
66: 		DownloadTotal: m.downloadTotal.Load(),
67: 		Connections:   connections,
68: 	}
69: }
70: 
71: func (m *Manager) ResetStatistic() {
72: 	m.uploadTemp.Store(0)
73: 	m.uploadBlip.Store(0)
74: 	m.uploadTotal.Store(0)
75: 	m.downloadTemp.Store(0)
76: 	m.downloadBlip.Store(0)
77: 	m.downloadTotal.Store(0)
78: }
79: 
80: func (m *Manager) handle() {
81: 	ticker := time.NewTicker(time.Second)
82: 
83: 	for range ticker.C {
84: 		m.uploadBlip.Store(m.uploadTemp.Load())
85: 		m.uploadTemp.Store(0)
86: 		m.downloadBlip.Store(m.downloadTemp.Load())
87: 		m.downloadTemp.Store(0)
88: 	}
89: }
90: 
91: type Snapshot struct {
92: 	DownloadTotal int64     `json:"downloadTotal"`
93: 	UploadTotal   int64     `json:"uploadTotal"`
94: 	Connections   []tracker `json:"connections"`
95: }


./tunnel\statistic\tracker.go
1: package statistic
2: 
3: import (
4: 	"net"
5: 	"time"
6: 
7: 	C "github.com/Dreamacro/clash/constant"
8: 
9: 	"github.com/gofrs/uuid/v5"
10: 	"go.uber.org/atomic"
11: )
12: 
13: type tracker interface {
14: 	ID() string
15: 	Close() error
16: }
17: 
18: type trackerInfo struct {
19: 	UUID          uuid.UUID     `json:"id"`
20: 	Metadata      *C.Metadata   `json:"metadata"`
21: 	UploadTotal   *atomic.Int64 `json:"upload"`
22: 	DownloadTotal *atomic.Int64 `json:"download"`
23: 	Start         time.Time     `json:"start"`
24: 	Chain         C.Chain       `json:"chains"`
25: 	Rule          string        `json:"rule"`
26: 	RulePayload   string        `json:"rulePayload"`
27: }
28: 
29: type tcpTracker struct {
30: 	C.Conn `json:"-"`
31: 	*trackerInfo
32: 	manager *Manager
33: }
34: 
35: func (tt *tcpTracker) ID() string {
36: 	return tt.UUID.String()
37: }
38: 
39: func (tt *tcpTracker) Read(b []byte) (int, error) {
40: 	n, err := tt.Conn.Read(b)
41: 	download := int64(n)
42: 	tt.manager.PushDownloaded(download)
43: 	tt.DownloadTotal.Add(download)
44: 	return n, err
45: }
46: 
47: func (tt *tcpTracker) Write(b []byte) (int, error) {
48: 	n, err := tt.Conn.Write(b)
49: 	upload := int64(n)
50: 	tt.manager.PushUploaded(upload)
51: 	tt.UploadTotal.Add(upload)
52: 	return n, err
53: }
54: 
55: func (tt *tcpTracker) Close() error {
56: 	tt.manager.Leave(tt)
57: 	return tt.Conn.Close()
58: }
59: 
60: func NewTCPTracker(conn C.Conn, manager *Manager, metadata *C.Metadata, rule C.Rule) *tcpTracker {
61: 	uuid, _ := uuid.NewV4()
62: 
63: 	t := &tcpTracker{
64: 		Conn:    conn,
65: 		manager: manager,
66: 		trackerInfo: &trackerInfo{
67: 			UUID:          uuid,
68: 			Start:         time.Now(),
69: 			Metadata:      metadata,
70: 			Chain:         conn.Chains(),
71: 			Rule:          "",
72: 			UploadTotal:   atomic.NewInt64(0),
73: 			DownloadTotal: atomic.NewInt64(0),
74: 		},
75: 	}
76: 
77: 	if rule != nil {
78: 		t.trackerInfo.Rule = rule.RuleType().String()
79: 		t.trackerInfo.RulePayload = rule.Payload()
80: 	}
81: 
82: 	manager.Join(t)
83: 	return t
84: }
85: 
86: type udpTracker struct {
87: 	C.PacketConn `json:"-"`
88: 	*trackerInfo
89: 	manager *Manager
90: }
91: 
92: func (ut *udpTracker) ID() string {
93: 	return ut.UUID.String()
94: }
95: 
96: func (ut *udpTracker) ReadFrom(b []byte) (int, net.Addr, error) {
97: 	n, addr, err := ut.PacketConn.ReadFrom(b)
98: 	download := int64(n)
99: 	ut.manager.PushDownloaded(download)
100: 	ut.DownloadTotal.Add(download)
101: 	return n, addr, err
102: }
103: 
104: func (ut *udpTracker) WriteTo(b []byte, addr net.Addr) (int, error) {
105: 	n, err := ut.PacketConn.WriteTo(b, addr)
106: 	upload := int64(n)
107: 	ut.manager.PushUploaded(upload)
108: 	ut.UploadTotal.Add(upload)
109: 	return n, err
110: }
111: 
112: func (ut *udpTracker) Close() error {
113: 	ut.manager.Leave(ut)
114: 	return ut.PacketConn.Close()
115: }
116: 
117: func NewUDPTracker(conn C.PacketConn, manager *Manager, metadata *C.Metadata, rule C.Rule) *udpTracker {
118: 	uuid, _ := uuid.NewV4()
119: 
120: 	ut := &udpTracker{
121: 		PacketConn: conn,
122: 		manager:    manager,
123: 		trackerInfo: &trackerInfo{
124: 			UUID:          uuid,
125: 			Start:         time.Now(),
126: 			Metadata:      metadata,
127: 			Chain:         conn.Chains(),
128: 			Rule:          "",
129: 			UploadTotal:   atomic.NewInt64(0),
130: 			DownloadTotal: atomic.NewInt64(0),
131: 		},
132: 	}
133: 
134: 	if rule != nil {
135: 		ut.trackerInfo.Rule = rule.RuleType().String()
136: 		ut.trackerInfo.RulePayload = rule.Payload()
137: 	}
138: 
139: 	manager.Join(ut)
140: 	return ut
141: }


